/* soapC.cpp
   Generated by gSOAP 2.7.16 from LibServicePort.h
   Copyright(C) 2000-2010, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif
#include "stdafx.h"
#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.7.16 2017-06-26 08:00:51 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_float:
		return soap_in_float(soap, NULL, NULL, "xsd:float");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ns1__getRedrTypesResponse:
		return soap_in_ns1__getRedrTypesResponse(soap, NULL, NULL, "ns1:getRedrTypesResponse");
	case SOAP_TYPE_ns1__getRedrTypes:
		return soap_in_ns1__getRedrTypes(soap, NULL, NULL, "ns1:getRedrTypes");
	case SOAP_TYPE_ns1__exceedFine1Response:
		return soap_in_ns1__exceedFine1Response(soap, NULL, NULL, "ns1:exceedFine1Response");
	case SOAP_TYPE_ns1__exceedFine1:
		return soap_in_ns1__exceedFine1(soap, NULL, NULL, "ns1:exceedFine1");
	case SOAP_TYPE_ns1__lostPay:
		return soap_in_ns1__lostPay(soap, NULL, NULL, "ns1:lostPay");
	case SOAP_TYPE_ns1__getLostPaysResponse:
		return soap_in_ns1__getLostPaysResponse(soap, NULL, NULL, "ns1:getLostPaysResponse");
	case SOAP_TYPE_ns1__getLostPays:
		return soap_in_ns1__getLostPays(soap, NULL, NULL, "ns1:getLostPays");
	case SOAP_TYPE_ns1__getAccounts1Response:
		return soap_in_ns1__getAccounts1Response(soap, NULL, NULL, "ns1:getAccounts1Response");
	case SOAP_TYPE_ns1__getAccounts1:
		return soap_in_ns1__getAccounts1(soap, NULL, NULL, "ns1:getAccounts1");
	case SOAP_TYPE_ns1__registerReaderResponse:
		return soap_in_ns1__registerReaderResponse(soap, NULL, NULL, "ns1:registerReaderResponse");
	case SOAP_TYPE_ns1__registerReader:
		return soap_in_ns1__registerReader(soap, NULL, NULL, "ns1:registerReader");
	case SOAP_TYPE_ns1__preg:
		return soap_in_ns1__preg(soap, NULL, NULL, "ns1:preg");
	case SOAP_TYPE_ns1__getPregsResponse:
		return soap_in_ns1__getPregsResponse(soap, NULL, NULL, "ns1:getPregsResponse");
	case SOAP_TYPE_ns1__getPregs:
		return soap_in_ns1__getPregs(soap, NULL, NULL, "ns1:getPregs");
	case SOAP_TYPE_ns1__account:
		return soap_in_ns1__account(soap, NULL, NULL, "ns1:account");
	case SOAP_TYPE_ns1__getAccountsResponse:
		return soap_in_ns1__getAccountsResponse(soap, NULL, NULL, "ns1:getAccountsResponse");
	case SOAP_TYPE_ns1__getAccounts:
		return soap_in_ns1__getAccounts(soap, NULL, NULL, "ns1:getAccounts");
	case SOAP_TYPE_ns1__marc:
		return soap_in_ns1__marc(soap, NULL, NULL, "ns1:marc");
	case SOAP_TYPE_ns1__getMarcResponse:
		return soap_in_ns1__getMarcResponse(soap, NULL, NULL, "ns1:getMarcResponse");
	case SOAP_TYPE_ns1__getMarc:
		return soap_in_ns1__getMarc(soap, NULL, NULL, "ns1:getMarc");
	case SOAP_TYPE_ns1__getLendHistResponse:
		return soap_in_ns1__getLendHistResponse(soap, NULL, NULL, "ns1:getLendHistResponse");
	case SOAP_TYPE_ns1__getLendHist:
		return soap_in_ns1__getLendHist(soap, NULL, NULL, "ns1:getLendHist");
	case SOAP_TYPE_ns1__certLossResponse:
		return soap_in_ns1__certLossResponse(soap, NULL, NULL, "ns1:certLossResponse");
	case SOAP_TYPE_ns1__certLoss:
		return soap_in_ns1__certLoss(soap, NULL, NULL, "ns1:certLoss");
	case SOAP_TYPE_ns1__getViolationsResponse:
		return soap_in_ns1__getViolationsResponse(soap, NULL, NULL, "ns1:getViolationsResponse");
	case SOAP_TYPE_ns1__getViolations:
		return soap_in_ns1__getViolations(soap, NULL, NULL, "ns1:getViolations");
	case SOAP_TYPE_ns1__pregOrRelegate:
		return soap_in_ns1__pregOrRelegate(soap, NULL, NULL, "ns1:pregOrRelegate");
	case SOAP_TYPE_ns1__relegate:
		return soap_in_ns1__relegate(soap, NULL, NULL, "ns1:relegate");
	case SOAP_TYPE_ns1__getRelegatesResponse:
		return soap_in_ns1__getRelegatesResponse(soap, NULL, NULL, "ns1:getRelegatesResponse");
	case SOAP_TYPE_ns1__getRelegates:
		return soap_in_ns1__getRelegates(soap, NULL, NULL, "ns1:getRelegates");
	case SOAP_TYPE_ns1__violation:
		return soap_in_ns1__violation(soap, NULL, NULL, "ns1:violation");
	case SOAP_TYPE_ns1__getViolations1Response:
		return soap_in_ns1__getViolations1Response(soap, NULL, NULL, "ns1:getViolations1Response");
	case SOAP_TYPE_ns1__getViolations1:
		return soap_in_ns1__getViolations1(soap, NULL, NULL, "ns1:getViolations1");
	case SOAP_TYPE_ns1__debt:
		return soap_in_ns1__debt(soap, NULL, NULL, "ns1:debt");
	case SOAP_TYPE_ns1__getDebtsResponse:
		return soap_in_ns1__getDebtsResponse(soap, NULL, NULL, "ns1:getDebtsResponse");
	case SOAP_TYPE_ns1__getDebts:
		return soap_in_ns1__getDebts(soap, NULL, NULL, "ns1:getDebts");
	case SOAP_TYPE_ns1__checkRedrResult:
		return soap_in_ns1__checkRedrResult(soap, NULL, NULL, "ns1:checkRedrResult");
	case SOAP_TYPE_ns1__checkReaderResponse:
		return soap_in_ns1__checkReaderResponse(soap, NULL, NULL, "ns1:checkReaderResponse");
	case SOAP_TYPE_ns1__checkReader:
		return soap_in_ns1__checkReader(soap, NULL, NULL, "ns1:checkReader");
	case SOAP_TYPE_ns1__simpleBean:
		return soap_in_ns1__simpleBean(soap, NULL, NULL, "ns1:simpleBean");
	case SOAP_TYPE_ns1__getDepsResponse:
		return soap_in_ns1__getDepsResponse(soap, NULL, NULL, "ns1:getDepsResponse");
	case SOAP_TYPE_ns1__getDeps:
		return soap_in_ns1__getDeps(soap, NULL, NULL, "ns1:getDeps");
	case SOAP_TYPE_ns1__reader:
		return soap_in_ns1__reader(soap, NULL, NULL, "ns1:reader");
	case SOAP_TYPE_ns1__getReaderResponse:
		return soap_in_ns1__getReaderResponse(soap, NULL, NULL, "ns1:getReaderResponse");
	case SOAP_TYPE_ns1__getReader:
		return soap_in_ns1__getReader(soap, NULL, NULL, "ns1:getReader");
	case SOAP_TYPE_ns1__circ:
		return soap_in_ns1__circ(soap, NULL, NULL, "ns1:circ");
	case SOAP_TYPE_ns1__getCircsResponse:
		return soap_in_ns1__getCircsResponse(soap, NULL, NULL, "ns1:getCircsResponse");
	case SOAP_TYPE_ns1__getCircs:
		return soap_in_ns1__getCircs(soap, NULL, NULL, "ns1:getCircs");
	case SOAP_TYPE_ns1__exceedFineResponse:
		return soap_in_ns1__exceedFineResponse(soap, NULL, NULL, "ns1:exceedFineResponse");
	case SOAP_TYPE_ns1__exceedFine:
		return soap_in_ns1__exceedFine(soap, NULL, NULL, "ns1:exceedFine");
	case SOAP_TYPE_ns1__voltFineResponse:
		return soap_in_ns1__voltFineResponse(soap, NULL, NULL, "ns1:voltFineResponse");
	case SOAP_TYPE_ns1__voltFine:
		return soap_in_ns1__voltFine(soap, NULL, NULL, "ns1:voltFine");
	case SOAP_TYPE_ns1__logoutResponse:
		return soap_in_ns1__logoutResponse(soap, NULL, NULL, "ns1:logoutResponse");
	case SOAP_TYPE_ns1__logout:
		return soap_in_ns1__logout(soap, NULL, NULL, "ns1:logout");
	case SOAP_TYPE_ns1__getPregArrivalsResponse:
		return soap_in_ns1__getPregArrivalsResponse(soap, NULL, NULL, "ns1:getPregArrivalsResponse");
	case SOAP_TYPE_ns1__getPregArrivals:
		return soap_in_ns1__getPregArrivals(soap, NULL, NULL, "ns1:getPregArrivals");
	case SOAP_TYPE_ns1__arrival:
		return soap_in_ns1__arrival(soap, NULL, NULL, "ns1:arrival");
	case SOAP_TYPE_ns1__getRelegateArrivalsResponse:
		return soap_in_ns1__getRelegateArrivalsResponse(soap, NULL, NULL, "ns1:getRelegateArrivalsResponse");
	case SOAP_TYPE_ns1__getRelegateArrivals:
		return soap_in_ns1__getRelegateArrivals(soap, NULL, NULL, "ns1:getRelegateArrivals");
	case SOAP_TYPE_ns1__item:
		return soap_in_ns1__item(soap, NULL, NULL, "ns1:item");
	case SOAP_TYPE_ns1__getItemsResponse:
		return soap_in_ns1__getItemsResponse(soap, NULL, NULL, "ns1:getItemsResponse");
	case SOAP_TYPE_ns1__getItems:
		return soap_in_ns1__getItems(soap, NULL, NULL, "ns1:getItems");
	case SOAP_TYPE_ns1__SystemException:
		return soap_in_ns1__SystemException(soap, NULL, NULL, "ns1:SystemException");
	case SOAP_TYPE_ns1__NoAuthorityException:
		return soap_in_ns1__NoAuthorityException(soap, NULL, NULL, "ns1:NoAuthorityException");
	case SOAP_TYPE_ns1__book:
		return soap_in_ns1__book(soap, NULL, NULL, "ns1:book");
	case SOAP_TYPE_ns1__getBookResponse:
		return soap_in_ns1__getBookResponse(soap, NULL, NULL, "ns1:getBookResponse");
	case SOAP_TYPE_ns1__getBook:
		return soap_in_ns1__getBook(soap, NULL, NULL, "ns1:getBook");
	case SOAP_TYPE_PointerTons1__getAccounts1Response:
		return soap_in_PointerTons1__getAccounts1Response(soap, NULL, NULL, "ns1:getAccounts1Response");
	case SOAP_TYPE_PointerTons1__getAccounts1:
		return soap_in_PointerTons1__getAccounts1(soap, NULL, NULL, "ns1:getAccounts1");
	case SOAP_TYPE_PointerTons1__getDepsResponse:
		return soap_in_PointerTons1__getDepsResponse(soap, NULL, NULL, "ns1:getDepsResponse");
	case SOAP_TYPE_PointerTons1__getDeps:
		return soap_in_PointerTons1__getDeps(soap, NULL, NULL, "ns1:getDeps");
	case SOAP_TYPE_PointerTons1__getRedrTypesResponse:
		return soap_in_PointerTons1__getRedrTypesResponse(soap, NULL, NULL, "ns1:getRedrTypesResponse");
	case SOAP_TYPE_PointerTons1__getRedrTypes:
		return soap_in_PointerTons1__getRedrTypes(soap, NULL, NULL, "ns1:getRedrTypes");
	case SOAP_TYPE_PointerTons1__registerReaderResponse:
		return soap_in_PointerTons1__registerReaderResponse(soap, NULL, NULL, "ns1:registerReaderResponse");
	case SOAP_TYPE_PointerTons1__registerReader:
		return soap_in_PointerTons1__registerReader(soap, NULL, NULL, "ns1:registerReader");
	case SOAP_TYPE_PointerTons1__exceedFine1Response:
		return soap_in_PointerTons1__exceedFine1Response(soap, NULL, NULL, "ns1:exceedFine1Response");
	case SOAP_TYPE_PointerTons1__exceedFine1:
		return soap_in_PointerTons1__exceedFine1(soap, NULL, NULL, "ns1:exceedFine1");
	case SOAP_TYPE_PointerTons1__getViolations1Response:
		return soap_in_PointerTons1__getViolations1Response(soap, NULL, NULL, "ns1:getViolations1Response");
	case SOAP_TYPE_PointerTons1__getViolations1:
		return soap_in_PointerTons1__getViolations1(soap, NULL, NULL, "ns1:getViolations1");
	case SOAP_TYPE_PointerTons1__voltFineResponse:
		return soap_in_PointerTons1__voltFineResponse(soap, NULL, NULL, "ns1:voltFineResponse");
	case SOAP_TYPE_PointerTons1__voltFine:
		return soap_in_PointerTons1__voltFine(soap, NULL, NULL, "ns1:voltFine");
	case SOAP_TYPE_PointerTons1__checkReaderResponse:
		return soap_in_PointerTons1__checkReaderResponse(soap, NULL, NULL, "ns1:checkReaderResponse");
	case SOAP_TYPE_PointerTons1__checkReader:
		return soap_in_PointerTons1__checkReader(soap, NULL, NULL, "ns1:checkReader");
	case SOAP_TYPE_PointerTons1__getMarcResponse:
		return soap_in_PointerTons1__getMarcResponse(soap, NULL, NULL, "ns1:getMarcResponse");
	case SOAP_TYPE_PointerTons1__getMarc:
		return soap_in_PointerTons1__getMarc(soap, NULL, NULL, "ns1:getMarc");
	case SOAP_TYPE_PointerTons1__getLendHistResponse:
		return soap_in_PointerTons1__getLendHistResponse(soap, NULL, NULL, "ns1:getLendHistResponse");
	case SOAP_TYPE_PointerTons1__getLendHist:
		return soap_in_PointerTons1__getLendHist(soap, NULL, NULL, "ns1:getLendHist");
	case SOAP_TYPE_PointerTons1__logoutResponse:
		return soap_in_PointerTons1__logoutResponse(soap, NULL, NULL, "ns1:logoutResponse");
	case SOAP_TYPE_PointerTons1__logout:
		return soap_in_PointerTons1__logout(soap, NULL, NULL, "ns1:logout");
	case SOAP_TYPE_PointerTons1__certLossResponse:
		return soap_in_PointerTons1__certLossResponse(soap, NULL, NULL, "ns1:certLossResponse");
	case SOAP_TYPE_PointerTons1__certLoss:
		return soap_in_PointerTons1__certLoss(soap, NULL, NULL, "ns1:certLoss");
	case SOAP_TYPE_PointerTons1__exceedFineResponse:
		return soap_in_PointerTons1__exceedFineResponse(soap, NULL, NULL, "ns1:exceedFineResponse");
	case SOAP_TYPE_PointerTons1__exceedFine:
		return soap_in_PointerTons1__exceedFine(soap, NULL, NULL, "ns1:exceedFine");
	case SOAP_TYPE_PointerTons1__getLostPaysResponse:
		return soap_in_PointerTons1__getLostPaysResponse(soap, NULL, NULL, "ns1:getLostPaysResponse");
	case SOAP_TYPE_PointerTons1__getLostPays:
		return soap_in_PointerTons1__getLostPays(soap, NULL, NULL, "ns1:getLostPays");
	case SOAP_TYPE_PointerTons1__getAccountsResponse:
		return soap_in_PointerTons1__getAccountsResponse(soap, NULL, NULL, "ns1:getAccountsResponse");
	case SOAP_TYPE_PointerTons1__getAccounts:
		return soap_in_PointerTons1__getAccounts(soap, NULL, NULL, "ns1:getAccounts");
	case SOAP_TYPE_PointerTons1__getRelegatesResponse:
		return soap_in_PointerTons1__getRelegatesResponse(soap, NULL, NULL, "ns1:getRelegatesResponse");
	case SOAP_TYPE_PointerTons1__getRelegates:
		return soap_in_PointerTons1__getRelegates(soap, NULL, NULL, "ns1:getRelegates");
	case SOAP_TYPE_PointerTons1__getPregsResponse:
		return soap_in_PointerTons1__getPregsResponse(soap, NULL, NULL, "ns1:getPregsResponse");
	case SOAP_TYPE_PointerTons1__getPregs:
		return soap_in_PointerTons1__getPregs(soap, NULL, NULL, "ns1:getPregs");
	case SOAP_TYPE_PointerTons1__getRelegateArrivalsResponse:
		return soap_in_PointerTons1__getRelegateArrivalsResponse(soap, NULL, NULL, "ns1:getRelegateArrivalsResponse");
	case SOAP_TYPE_PointerTons1__getRelegateArrivals:
		return soap_in_PointerTons1__getRelegateArrivals(soap, NULL, NULL, "ns1:getRelegateArrivals");
	case SOAP_TYPE_PointerTons1__getPregArrivalsResponse:
		return soap_in_PointerTons1__getPregArrivalsResponse(soap, NULL, NULL, "ns1:getPregArrivalsResponse");
	case SOAP_TYPE_PointerTons1__getPregArrivals:
		return soap_in_PointerTons1__getPregArrivals(soap, NULL, NULL, "ns1:getPregArrivals");
	case SOAP_TYPE_PointerTons1__getDebtsResponse:
		return soap_in_PointerTons1__getDebtsResponse(soap, NULL, NULL, "ns1:getDebtsResponse");
	case SOAP_TYPE_PointerTons1__getDebts:
		return soap_in_PointerTons1__getDebts(soap, NULL, NULL, "ns1:getDebts");
	case SOAP_TYPE_PointerTons1__getViolationsResponse:
		return soap_in_PointerTons1__getViolationsResponse(soap, NULL, NULL, "ns1:getViolationsResponse");
	case SOAP_TYPE_PointerTons1__getViolations:
		return soap_in_PointerTons1__getViolations(soap, NULL, NULL, "ns1:getViolations");
	case SOAP_TYPE_PointerTons1__getCircsResponse:
		return soap_in_PointerTons1__getCircsResponse(soap, NULL, NULL, "ns1:getCircsResponse");
	case SOAP_TYPE_PointerTons1__getCircs:
		return soap_in_PointerTons1__getCircs(soap, NULL, NULL, "ns1:getCircs");
	case SOAP_TYPE_PointerTons1__getBookResponse:
		return soap_in_PointerTons1__getBookResponse(soap, NULL, NULL, "ns1:getBookResponse");
	case SOAP_TYPE_PointerTons1__getBook:
		return soap_in_PointerTons1__getBook(soap, NULL, NULL, "ns1:getBook");
	case SOAP_TYPE_PointerTons1__getItemsResponse:
		return soap_in_PointerTons1__getItemsResponse(soap, NULL, NULL, "ns1:getItemsResponse");
	case SOAP_TYPE_PointerTons1__getItems:
		return soap_in_PointerTons1__getItems(soap, NULL, NULL, "ns1:getItems");
	case SOAP_TYPE_PointerTons1__getReaderResponse:
		return soap_in_PointerTons1__getReaderResponse(soap, NULL, NULL, "ns1:getReaderResponse");
	case SOAP_TYPE_PointerTons1__getReader:
		return soap_in_PointerTons1__getReader(soap, NULL, NULL, "ns1:getReader");
	case SOAP_TYPE_PointerTons1__SystemException:
		return soap_in_PointerTons1__SystemException(soap, NULL, NULL, "ns1:SystemException");
	case SOAP_TYPE_PointerTons1__NoAuthorityException:
		return soap_in_PointerTons1__NoAuthorityException(soap, NULL, NULL, "ns1:NoAuthorityException");
	case SOAP_TYPE_PointerTons1__lostPay:
		return soap_in_PointerTons1__lostPay(soap, NULL, NULL, "ns1:lostPay");
	case SOAP_TYPE_PointerTons1__preg:
		return soap_in_PointerTons1__preg(soap, NULL, NULL, "ns1:preg");
	case SOAP_TYPE_PointerTons1__account:
		return soap_in_PointerTons1__account(soap, NULL, NULL, "ns1:account");
	case SOAP_TYPE_PointerTons1__marc:
		return soap_in_PointerTons1__marc(soap, NULL, NULL, "ns1:marc");
	case SOAP_TYPE_PointerTons1__relegate:
		return soap_in_PointerTons1__relegate(soap, NULL, NULL, "ns1:relegate");
	case SOAP_TYPE_PointerTons1__violation:
		return soap_in_PointerTons1__violation(soap, NULL, NULL, "ns1:violation");
	case SOAP_TYPE_PointerTons1__debt:
		return soap_in_PointerTons1__debt(soap, NULL, NULL, "ns1:debt");
	case SOAP_TYPE_PointerTons1__checkRedrResult:
		return soap_in_PointerTons1__checkRedrResult(soap, NULL, NULL, "ns1:checkRedrResult");
	case SOAP_TYPE_PointerTons1__simpleBean:
		return soap_in_PointerTons1__simpleBean(soap, NULL, NULL, "ns1:simpleBean");
	case SOAP_TYPE_PointerTons1__reader:
		return soap_in_PointerTons1__reader(soap, NULL, NULL, "ns1:reader");
	case SOAP_TYPE_PointerTons1__circ:
		return soap_in_PointerTons1__circ(soap, NULL, NULL, "ns1:circ");
	case SOAP_TYPE_PointerTons1__arrival:
		return soap_in_PointerTons1__arrival(soap, NULL, NULL, "ns1:arrival");
	case SOAP_TYPE_PointerTons1__item:
		return soap_in_PointerTons1__item(soap, NULL, NULL, "ns1:item");
	case SOAP_TYPE_wstring:
	{	wchar_t **s;
		s = soap_in_wstring(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTons1__book:
		return soap_in_PointerTons1__book(soap, NULL, NULL, "ns1:book");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getRedrTypesResponse"))
		{	*type = SOAP_TYPE_ns1__getRedrTypesResponse;
			return soap_in_ns1__getRedrTypesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getRedrTypes"))
		{	*type = SOAP_TYPE_ns1__getRedrTypes;
			return soap_in_ns1__getRedrTypes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:exceedFine1Response"))
		{	*type = SOAP_TYPE_ns1__exceedFine1Response;
			return soap_in_ns1__exceedFine1Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:exceedFine1"))
		{	*type = SOAP_TYPE_ns1__exceedFine1;
			return soap_in_ns1__exceedFine1(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:lostPay"))
		{	*type = SOAP_TYPE_ns1__lostPay;
			return soap_in_ns1__lostPay(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getLostPaysResponse"))
		{	*type = SOAP_TYPE_ns1__getLostPaysResponse;
			return soap_in_ns1__getLostPaysResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getLostPays"))
		{	*type = SOAP_TYPE_ns1__getLostPays;
			return soap_in_ns1__getLostPays(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAccounts1Response"))
		{	*type = SOAP_TYPE_ns1__getAccounts1Response;
			return soap_in_ns1__getAccounts1Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAccounts1"))
		{	*type = SOAP_TYPE_ns1__getAccounts1;
			return soap_in_ns1__getAccounts1(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:registerReaderResponse"))
		{	*type = SOAP_TYPE_ns1__registerReaderResponse;
			return soap_in_ns1__registerReaderResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:registerReader"))
		{	*type = SOAP_TYPE_ns1__registerReader;
			return soap_in_ns1__registerReader(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:preg"))
		{	*type = SOAP_TYPE_ns1__preg;
			return soap_in_ns1__preg(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPregsResponse"))
		{	*type = SOAP_TYPE_ns1__getPregsResponse;
			return soap_in_ns1__getPregsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPregs"))
		{	*type = SOAP_TYPE_ns1__getPregs;
			return soap_in_ns1__getPregs(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:account"))
		{	*type = SOAP_TYPE_ns1__account;
			return soap_in_ns1__account(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAccountsResponse"))
		{	*type = SOAP_TYPE_ns1__getAccountsResponse;
			return soap_in_ns1__getAccountsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAccounts"))
		{	*type = SOAP_TYPE_ns1__getAccounts;
			return soap_in_ns1__getAccounts(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:marc"))
		{	*type = SOAP_TYPE_ns1__marc;
			return soap_in_ns1__marc(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getMarcResponse"))
		{	*type = SOAP_TYPE_ns1__getMarcResponse;
			return soap_in_ns1__getMarcResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getMarc"))
		{	*type = SOAP_TYPE_ns1__getMarc;
			return soap_in_ns1__getMarc(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getLendHistResponse"))
		{	*type = SOAP_TYPE_ns1__getLendHistResponse;
			return soap_in_ns1__getLendHistResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getLendHist"))
		{	*type = SOAP_TYPE_ns1__getLendHist;
			return soap_in_ns1__getLendHist(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:certLossResponse"))
		{	*type = SOAP_TYPE_ns1__certLossResponse;
			return soap_in_ns1__certLossResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:certLoss"))
		{	*type = SOAP_TYPE_ns1__certLoss;
			return soap_in_ns1__certLoss(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getViolationsResponse"))
		{	*type = SOAP_TYPE_ns1__getViolationsResponse;
			return soap_in_ns1__getViolationsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getViolations"))
		{	*type = SOAP_TYPE_ns1__getViolations;
			return soap_in_ns1__getViolations(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:pregOrRelegate"))
		{	*type = SOAP_TYPE_ns1__pregOrRelegate;
			return soap_in_ns1__pregOrRelegate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:relegate"))
		{	*type = SOAP_TYPE_ns1__relegate;
			return soap_in_ns1__relegate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getRelegatesResponse"))
		{	*type = SOAP_TYPE_ns1__getRelegatesResponse;
			return soap_in_ns1__getRelegatesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getRelegates"))
		{	*type = SOAP_TYPE_ns1__getRelegates;
			return soap_in_ns1__getRelegates(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:violation"))
		{	*type = SOAP_TYPE_ns1__violation;
			return soap_in_ns1__violation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getViolations1Response"))
		{	*type = SOAP_TYPE_ns1__getViolations1Response;
			return soap_in_ns1__getViolations1Response(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getViolations1"))
		{	*type = SOAP_TYPE_ns1__getViolations1;
			return soap_in_ns1__getViolations1(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:debt"))
		{	*type = SOAP_TYPE_ns1__debt;
			return soap_in_ns1__debt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDebtsResponse"))
		{	*type = SOAP_TYPE_ns1__getDebtsResponse;
			return soap_in_ns1__getDebtsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDebts"))
		{	*type = SOAP_TYPE_ns1__getDebts;
			return soap_in_ns1__getDebts(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:checkRedrResult"))
		{	*type = SOAP_TYPE_ns1__checkRedrResult;
			return soap_in_ns1__checkRedrResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:checkReaderResponse"))
		{	*type = SOAP_TYPE_ns1__checkReaderResponse;
			return soap_in_ns1__checkReaderResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:checkReader"))
		{	*type = SOAP_TYPE_ns1__checkReader;
			return soap_in_ns1__checkReader(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:simpleBean"))
		{	*type = SOAP_TYPE_ns1__simpleBean;
			return soap_in_ns1__simpleBean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDepsResponse"))
		{	*type = SOAP_TYPE_ns1__getDepsResponse;
			return soap_in_ns1__getDepsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDeps"))
		{	*type = SOAP_TYPE_ns1__getDeps;
			return soap_in_ns1__getDeps(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:reader"))
		{	*type = SOAP_TYPE_ns1__reader;
			return soap_in_ns1__reader(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getReaderResponse"))
		{	*type = SOAP_TYPE_ns1__getReaderResponse;
			return soap_in_ns1__getReaderResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getReader"))
		{	*type = SOAP_TYPE_ns1__getReader;
			return soap_in_ns1__getReader(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:circ"))
		{	*type = SOAP_TYPE_ns1__circ;
			return soap_in_ns1__circ(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCircsResponse"))
		{	*type = SOAP_TYPE_ns1__getCircsResponse;
			return soap_in_ns1__getCircsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCircs"))
		{	*type = SOAP_TYPE_ns1__getCircs;
			return soap_in_ns1__getCircs(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:exceedFineResponse"))
		{	*type = SOAP_TYPE_ns1__exceedFineResponse;
			return soap_in_ns1__exceedFineResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:exceedFine"))
		{	*type = SOAP_TYPE_ns1__exceedFine;
			return soap_in_ns1__exceedFine(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:voltFineResponse"))
		{	*type = SOAP_TYPE_ns1__voltFineResponse;
			return soap_in_ns1__voltFineResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:voltFine"))
		{	*type = SOAP_TYPE_ns1__voltFine;
			return soap_in_ns1__voltFine(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:logoutResponse"))
		{	*type = SOAP_TYPE_ns1__logoutResponse;
			return soap_in_ns1__logoutResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:logout"))
		{	*type = SOAP_TYPE_ns1__logout;
			return soap_in_ns1__logout(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPregArrivalsResponse"))
		{	*type = SOAP_TYPE_ns1__getPregArrivalsResponse;
			return soap_in_ns1__getPregArrivalsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPregArrivals"))
		{	*type = SOAP_TYPE_ns1__getPregArrivals;
			return soap_in_ns1__getPregArrivals(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:arrival"))
		{	*type = SOAP_TYPE_ns1__arrival;
			return soap_in_ns1__arrival(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getRelegateArrivalsResponse"))
		{	*type = SOAP_TYPE_ns1__getRelegateArrivalsResponse;
			return soap_in_ns1__getRelegateArrivalsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getRelegateArrivals"))
		{	*type = SOAP_TYPE_ns1__getRelegateArrivals;
			return soap_in_ns1__getRelegateArrivals(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:item"))
		{	*type = SOAP_TYPE_ns1__item;
			return soap_in_ns1__item(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getItemsResponse"))
		{	*type = SOAP_TYPE_ns1__getItemsResponse;
			return soap_in_ns1__getItemsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getItems"))
		{	*type = SOAP_TYPE_ns1__getItems;
			return soap_in_ns1__getItems(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SystemException"))
		{	*type = SOAP_TYPE_ns1__SystemException;
			return soap_in_ns1__SystemException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:NoAuthorityException"))
		{	*type = SOAP_TYPE_ns1__NoAuthorityException;
			return soap_in_ns1__NoAuthorityException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:book"))
		{	*type = SOAP_TYPE_ns1__book;
			return soap_in_ns1__book(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getBookResponse"))
		{	*type = SOAP_TYPE_ns1__getBookResponse;
			return soap_in_ns1__getBookResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getBook"))
		{	*type = SOAP_TYPE_ns1__getBook;
			return soap_in_ns1__getBook(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:float"))
		{	*type = SOAP_TYPE_float;
			return soap_in_float(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_float:
		return soap_out_float(soap, tag, id, (const float *)ptr, "xsd:float");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_ns1__getRedrTypesResponse:
		return ((ns1__getRedrTypesResponse *)ptr)->soap_out(soap, tag, id, "ns1:getRedrTypesResponse");
	case SOAP_TYPE_ns1__getRedrTypes:
		return ((ns1__getRedrTypes *)ptr)->soap_out(soap, tag, id, "ns1:getRedrTypes");
	case SOAP_TYPE_ns1__exceedFine1Response:
		return ((ns1__exceedFine1Response *)ptr)->soap_out(soap, tag, id, "ns1:exceedFine1Response");
	case SOAP_TYPE_ns1__exceedFine1:
		return ((ns1__exceedFine1 *)ptr)->soap_out(soap, tag, id, "ns1:exceedFine1");
	case SOAP_TYPE_ns1__lostPay:
		return ((ns1__lostPay *)ptr)->soap_out(soap, tag, id, "ns1:lostPay");
	case SOAP_TYPE_ns1__getLostPaysResponse:
		return ((ns1__getLostPaysResponse *)ptr)->soap_out(soap, tag, id, "ns1:getLostPaysResponse");
	case SOAP_TYPE_ns1__getLostPays:
		return ((ns1__getLostPays *)ptr)->soap_out(soap, tag, id, "ns1:getLostPays");
	case SOAP_TYPE_ns1__getAccounts1Response:
		return ((ns1__getAccounts1Response *)ptr)->soap_out(soap, tag, id, "ns1:getAccounts1Response");
	case SOAP_TYPE_ns1__getAccounts1:
		return ((ns1__getAccounts1 *)ptr)->soap_out(soap, tag, id, "ns1:getAccounts1");
	case SOAP_TYPE_ns1__registerReaderResponse:
		return ((ns1__registerReaderResponse *)ptr)->soap_out(soap, tag, id, "ns1:registerReaderResponse");
	case SOAP_TYPE_ns1__registerReader:
		return ((ns1__registerReader *)ptr)->soap_out(soap, tag, id, "ns1:registerReader");
	case SOAP_TYPE_ns1__preg:
		return ((ns1__preg *)ptr)->soap_out(soap, tag, id, "ns1:preg");
	case SOAP_TYPE_ns1__getPregsResponse:
		return ((ns1__getPregsResponse *)ptr)->soap_out(soap, tag, id, "ns1:getPregsResponse");
	case SOAP_TYPE_ns1__getPregs:
		return ((ns1__getPregs *)ptr)->soap_out(soap, tag, id, "ns1:getPregs");
	case SOAP_TYPE_ns1__account:
		return ((ns1__account *)ptr)->soap_out(soap, tag, id, "ns1:account");
	case SOAP_TYPE_ns1__getAccountsResponse:
		return ((ns1__getAccountsResponse *)ptr)->soap_out(soap, tag, id, "ns1:getAccountsResponse");
	case SOAP_TYPE_ns1__getAccounts:
		return ((ns1__getAccounts *)ptr)->soap_out(soap, tag, id, "ns1:getAccounts");
	case SOAP_TYPE_ns1__marc:
		return ((ns1__marc *)ptr)->soap_out(soap, tag, id, "ns1:marc");
	case SOAP_TYPE_ns1__getMarcResponse:
		return ((ns1__getMarcResponse *)ptr)->soap_out(soap, tag, id, "ns1:getMarcResponse");
	case SOAP_TYPE_ns1__getMarc:
		return ((ns1__getMarc *)ptr)->soap_out(soap, tag, id, "ns1:getMarc");
	case SOAP_TYPE_ns1__getLendHistResponse:
		return ((ns1__getLendHistResponse *)ptr)->soap_out(soap, tag, id, "ns1:getLendHistResponse");
	case SOAP_TYPE_ns1__getLendHist:
		return ((ns1__getLendHist *)ptr)->soap_out(soap, tag, id, "ns1:getLendHist");
	case SOAP_TYPE_ns1__certLossResponse:
		return ((ns1__certLossResponse *)ptr)->soap_out(soap, tag, id, "ns1:certLossResponse");
	case SOAP_TYPE_ns1__certLoss:
		return ((ns1__certLoss *)ptr)->soap_out(soap, tag, id, "ns1:certLoss");
	case SOAP_TYPE_ns1__getViolationsResponse:
		return ((ns1__getViolationsResponse *)ptr)->soap_out(soap, tag, id, "ns1:getViolationsResponse");
	case SOAP_TYPE_ns1__getViolations:
		return ((ns1__getViolations *)ptr)->soap_out(soap, tag, id, "ns1:getViolations");
	case SOAP_TYPE_ns1__pregOrRelegate:
		return ((ns1__pregOrRelegate *)ptr)->soap_out(soap, tag, id, "ns1:pregOrRelegate");
	case SOAP_TYPE_ns1__relegate:
		return ((ns1__relegate *)ptr)->soap_out(soap, tag, id, "ns1:relegate");
	case SOAP_TYPE_ns1__getRelegatesResponse:
		return ((ns1__getRelegatesResponse *)ptr)->soap_out(soap, tag, id, "ns1:getRelegatesResponse");
	case SOAP_TYPE_ns1__getRelegates:
		return ((ns1__getRelegates *)ptr)->soap_out(soap, tag, id, "ns1:getRelegates");
	case SOAP_TYPE_ns1__violation:
		return ((ns1__violation *)ptr)->soap_out(soap, tag, id, "ns1:violation");
	case SOAP_TYPE_ns1__getViolations1Response:
		return ((ns1__getViolations1Response *)ptr)->soap_out(soap, tag, id, "ns1:getViolations1Response");
	case SOAP_TYPE_ns1__getViolations1:
		return ((ns1__getViolations1 *)ptr)->soap_out(soap, tag, id, "ns1:getViolations1");
	case SOAP_TYPE_ns1__debt:
		return ((ns1__debt *)ptr)->soap_out(soap, tag, id, "ns1:debt");
	case SOAP_TYPE_ns1__getDebtsResponse:
		return ((ns1__getDebtsResponse *)ptr)->soap_out(soap, tag, id, "ns1:getDebtsResponse");
	case SOAP_TYPE_ns1__getDebts:
		return ((ns1__getDebts *)ptr)->soap_out(soap, tag, id, "ns1:getDebts");
	case SOAP_TYPE_ns1__checkRedrResult:
		return ((ns1__checkRedrResult *)ptr)->soap_out(soap, tag, id, "ns1:checkRedrResult");
	case SOAP_TYPE_ns1__checkReaderResponse:
		return ((ns1__checkReaderResponse *)ptr)->soap_out(soap, tag, id, "ns1:checkReaderResponse");
	case SOAP_TYPE_ns1__checkReader:
		return ((ns1__checkReader *)ptr)->soap_out(soap, tag, id, "ns1:checkReader");
	case SOAP_TYPE_ns1__simpleBean:
		return ((ns1__simpleBean *)ptr)->soap_out(soap, tag, id, "ns1:simpleBean");
	case SOAP_TYPE_ns1__getDepsResponse:
		return ((ns1__getDepsResponse *)ptr)->soap_out(soap, tag, id, "ns1:getDepsResponse");
	case SOAP_TYPE_ns1__getDeps:
		return ((ns1__getDeps *)ptr)->soap_out(soap, tag, id, "ns1:getDeps");
	case SOAP_TYPE_ns1__reader:
		return ((ns1__reader *)ptr)->soap_out(soap, tag, id, "ns1:reader");
	case SOAP_TYPE_ns1__getReaderResponse:
		return ((ns1__getReaderResponse *)ptr)->soap_out(soap, tag, id, "ns1:getReaderResponse");
	case SOAP_TYPE_ns1__getReader:
		return ((ns1__getReader *)ptr)->soap_out(soap, tag, id, "ns1:getReader");
	case SOAP_TYPE_ns1__circ:
		return ((ns1__circ *)ptr)->soap_out(soap, tag, id, "ns1:circ");
	case SOAP_TYPE_ns1__getCircsResponse:
		return ((ns1__getCircsResponse *)ptr)->soap_out(soap, tag, id, "ns1:getCircsResponse");
	case SOAP_TYPE_ns1__getCircs:
		return ((ns1__getCircs *)ptr)->soap_out(soap, tag, id, "ns1:getCircs");
	case SOAP_TYPE_ns1__exceedFineResponse:
		return ((ns1__exceedFineResponse *)ptr)->soap_out(soap, tag, id, "ns1:exceedFineResponse");
	case SOAP_TYPE_ns1__exceedFine:
		return ((ns1__exceedFine *)ptr)->soap_out(soap, tag, id, "ns1:exceedFine");
	case SOAP_TYPE_ns1__voltFineResponse:
		return ((ns1__voltFineResponse *)ptr)->soap_out(soap, tag, id, "ns1:voltFineResponse");
	case SOAP_TYPE_ns1__voltFine:
		return ((ns1__voltFine *)ptr)->soap_out(soap, tag, id, "ns1:voltFine");
	case SOAP_TYPE_ns1__logoutResponse:
		return ((ns1__logoutResponse *)ptr)->soap_out(soap, tag, id, "ns1:logoutResponse");
	case SOAP_TYPE_ns1__logout:
		return ((ns1__logout *)ptr)->soap_out(soap, tag, id, "ns1:logout");
	case SOAP_TYPE_ns1__getPregArrivalsResponse:
		return ((ns1__getPregArrivalsResponse *)ptr)->soap_out(soap, tag, id, "ns1:getPregArrivalsResponse");
	case SOAP_TYPE_ns1__getPregArrivals:
		return ((ns1__getPregArrivals *)ptr)->soap_out(soap, tag, id, "ns1:getPregArrivals");
	case SOAP_TYPE_ns1__arrival:
		return ((ns1__arrival *)ptr)->soap_out(soap, tag, id, "ns1:arrival");
	case SOAP_TYPE_ns1__getRelegateArrivalsResponse:
		return ((ns1__getRelegateArrivalsResponse *)ptr)->soap_out(soap, tag, id, "ns1:getRelegateArrivalsResponse");
	case SOAP_TYPE_ns1__getRelegateArrivals:
		return ((ns1__getRelegateArrivals *)ptr)->soap_out(soap, tag, id, "ns1:getRelegateArrivals");
	case SOAP_TYPE_ns1__item:
		return ((ns1__item *)ptr)->soap_out(soap, tag, id, "ns1:item");
	case SOAP_TYPE_ns1__getItemsResponse:
		return ((ns1__getItemsResponse *)ptr)->soap_out(soap, tag, id, "ns1:getItemsResponse");
	case SOAP_TYPE_ns1__getItems:
		return ((ns1__getItems *)ptr)->soap_out(soap, tag, id, "ns1:getItems");
	case SOAP_TYPE_ns1__SystemException:
		return ((ns1__SystemException *)ptr)->soap_out(soap, tag, id, "ns1:SystemException");
	case SOAP_TYPE_ns1__NoAuthorityException:
		return ((ns1__NoAuthorityException *)ptr)->soap_out(soap, tag, id, "ns1:NoAuthorityException");
	case SOAP_TYPE_ns1__book:
		return ((ns1__book *)ptr)->soap_out(soap, tag, id, "ns1:book");
	case SOAP_TYPE_ns1__getBookResponse:
		return ((ns1__getBookResponse *)ptr)->soap_out(soap, tag, id, "ns1:getBookResponse");
	case SOAP_TYPE_ns1__getBook:
		return ((ns1__getBook *)ptr)->soap_out(soap, tag, id, "ns1:getBook");
	case SOAP_TYPE_PointerTons1__getAccounts1Response:
		return soap_out_PointerTons1__getAccounts1Response(soap, tag, id, (ns1__getAccounts1Response *const*)ptr, "ns1:getAccounts1Response");
	case SOAP_TYPE_PointerTons1__getAccounts1:
		return soap_out_PointerTons1__getAccounts1(soap, tag, id, (ns1__getAccounts1 *const*)ptr, "ns1:getAccounts1");
	case SOAP_TYPE_PointerTons1__getDepsResponse:
		return soap_out_PointerTons1__getDepsResponse(soap, tag, id, (ns1__getDepsResponse *const*)ptr, "ns1:getDepsResponse");
	case SOAP_TYPE_PointerTons1__getDeps:
		return soap_out_PointerTons1__getDeps(soap, tag, id, (ns1__getDeps *const*)ptr, "ns1:getDeps");
	case SOAP_TYPE_PointerTons1__getRedrTypesResponse:
		return soap_out_PointerTons1__getRedrTypesResponse(soap, tag, id, (ns1__getRedrTypesResponse *const*)ptr, "ns1:getRedrTypesResponse");
	case SOAP_TYPE_PointerTons1__getRedrTypes:
		return soap_out_PointerTons1__getRedrTypes(soap, tag, id, (ns1__getRedrTypes *const*)ptr, "ns1:getRedrTypes");
	case SOAP_TYPE_PointerTons1__registerReaderResponse:
		return soap_out_PointerTons1__registerReaderResponse(soap, tag, id, (ns1__registerReaderResponse *const*)ptr, "ns1:registerReaderResponse");
	case SOAP_TYPE_PointerTons1__registerReader:
		return soap_out_PointerTons1__registerReader(soap, tag, id, (ns1__registerReader *const*)ptr, "ns1:registerReader");
	case SOAP_TYPE_PointerTons1__exceedFine1Response:
		return soap_out_PointerTons1__exceedFine1Response(soap, tag, id, (ns1__exceedFine1Response *const*)ptr, "ns1:exceedFine1Response");
	case SOAP_TYPE_PointerTons1__exceedFine1:
		return soap_out_PointerTons1__exceedFine1(soap, tag, id, (ns1__exceedFine1 *const*)ptr, "ns1:exceedFine1");
	case SOAP_TYPE_PointerTons1__getViolations1Response:
		return soap_out_PointerTons1__getViolations1Response(soap, tag, id, (ns1__getViolations1Response *const*)ptr, "ns1:getViolations1Response");
	case SOAP_TYPE_PointerTons1__getViolations1:
		return soap_out_PointerTons1__getViolations1(soap, tag, id, (ns1__getViolations1 *const*)ptr, "ns1:getViolations1");
	case SOAP_TYPE_PointerTons1__voltFineResponse:
		return soap_out_PointerTons1__voltFineResponse(soap, tag, id, (ns1__voltFineResponse *const*)ptr, "ns1:voltFineResponse");
	case SOAP_TYPE_PointerTons1__voltFine:
		return soap_out_PointerTons1__voltFine(soap, tag, id, (ns1__voltFine *const*)ptr, "ns1:voltFine");
	case SOAP_TYPE_PointerTons1__checkReaderResponse:
		return soap_out_PointerTons1__checkReaderResponse(soap, tag, id, (ns1__checkReaderResponse *const*)ptr, "ns1:checkReaderResponse");
	case SOAP_TYPE_PointerTons1__checkReader:
		return soap_out_PointerTons1__checkReader(soap, tag, id, (ns1__checkReader *const*)ptr, "ns1:checkReader");
	case SOAP_TYPE_PointerTons1__getMarcResponse:
		return soap_out_PointerTons1__getMarcResponse(soap, tag, id, (ns1__getMarcResponse *const*)ptr, "ns1:getMarcResponse");
	case SOAP_TYPE_PointerTons1__getMarc:
		return soap_out_PointerTons1__getMarc(soap, tag, id, (ns1__getMarc *const*)ptr, "ns1:getMarc");
	case SOAP_TYPE_PointerTons1__getLendHistResponse:
		return soap_out_PointerTons1__getLendHistResponse(soap, tag, id, (ns1__getLendHistResponse *const*)ptr, "ns1:getLendHistResponse");
	case SOAP_TYPE_PointerTons1__getLendHist:
		return soap_out_PointerTons1__getLendHist(soap, tag, id, (ns1__getLendHist *const*)ptr, "ns1:getLendHist");
	case SOAP_TYPE_PointerTons1__logoutResponse:
		return soap_out_PointerTons1__logoutResponse(soap, tag, id, (ns1__logoutResponse *const*)ptr, "ns1:logoutResponse");
	case SOAP_TYPE_PointerTons1__logout:
		return soap_out_PointerTons1__logout(soap, tag, id, (ns1__logout *const*)ptr, "ns1:logout");
	case SOAP_TYPE_PointerTons1__certLossResponse:
		return soap_out_PointerTons1__certLossResponse(soap, tag, id, (ns1__certLossResponse *const*)ptr, "ns1:certLossResponse");
	case SOAP_TYPE_PointerTons1__certLoss:
		return soap_out_PointerTons1__certLoss(soap, tag, id, (ns1__certLoss *const*)ptr, "ns1:certLoss");
	case SOAP_TYPE_PointerTons1__exceedFineResponse:
		return soap_out_PointerTons1__exceedFineResponse(soap, tag, id, (ns1__exceedFineResponse *const*)ptr, "ns1:exceedFineResponse");
	case SOAP_TYPE_PointerTons1__exceedFine:
		return soap_out_PointerTons1__exceedFine(soap, tag, id, (ns1__exceedFine *const*)ptr, "ns1:exceedFine");
	case SOAP_TYPE_PointerTons1__getLostPaysResponse:
		return soap_out_PointerTons1__getLostPaysResponse(soap, tag, id, (ns1__getLostPaysResponse *const*)ptr, "ns1:getLostPaysResponse");
	case SOAP_TYPE_PointerTons1__getLostPays:
		return soap_out_PointerTons1__getLostPays(soap, tag, id, (ns1__getLostPays *const*)ptr, "ns1:getLostPays");
	case SOAP_TYPE_PointerTons1__getAccountsResponse:
		return soap_out_PointerTons1__getAccountsResponse(soap, tag, id, (ns1__getAccountsResponse *const*)ptr, "ns1:getAccountsResponse");
	case SOAP_TYPE_PointerTons1__getAccounts:
		return soap_out_PointerTons1__getAccounts(soap, tag, id, (ns1__getAccounts *const*)ptr, "ns1:getAccounts");
	case SOAP_TYPE_PointerTons1__getRelegatesResponse:
		return soap_out_PointerTons1__getRelegatesResponse(soap, tag, id, (ns1__getRelegatesResponse *const*)ptr, "ns1:getRelegatesResponse");
	case SOAP_TYPE_PointerTons1__getRelegates:
		return soap_out_PointerTons1__getRelegates(soap, tag, id, (ns1__getRelegates *const*)ptr, "ns1:getRelegates");
	case SOAP_TYPE_PointerTons1__getPregsResponse:
		return soap_out_PointerTons1__getPregsResponse(soap, tag, id, (ns1__getPregsResponse *const*)ptr, "ns1:getPregsResponse");
	case SOAP_TYPE_PointerTons1__getPregs:
		return soap_out_PointerTons1__getPregs(soap, tag, id, (ns1__getPregs *const*)ptr, "ns1:getPregs");
	case SOAP_TYPE_PointerTons1__getRelegateArrivalsResponse:
		return soap_out_PointerTons1__getRelegateArrivalsResponse(soap, tag, id, (ns1__getRelegateArrivalsResponse *const*)ptr, "ns1:getRelegateArrivalsResponse");
	case SOAP_TYPE_PointerTons1__getRelegateArrivals:
		return soap_out_PointerTons1__getRelegateArrivals(soap, tag, id, (ns1__getRelegateArrivals *const*)ptr, "ns1:getRelegateArrivals");
	case SOAP_TYPE_PointerTons1__getPregArrivalsResponse:
		return soap_out_PointerTons1__getPregArrivalsResponse(soap, tag, id, (ns1__getPregArrivalsResponse *const*)ptr, "ns1:getPregArrivalsResponse");
	case SOAP_TYPE_PointerTons1__getPregArrivals:
		return soap_out_PointerTons1__getPregArrivals(soap, tag, id, (ns1__getPregArrivals *const*)ptr, "ns1:getPregArrivals");
	case SOAP_TYPE_PointerTons1__getDebtsResponse:
		return soap_out_PointerTons1__getDebtsResponse(soap, tag, id, (ns1__getDebtsResponse *const*)ptr, "ns1:getDebtsResponse");
	case SOAP_TYPE_PointerTons1__getDebts:
		return soap_out_PointerTons1__getDebts(soap, tag, id, (ns1__getDebts *const*)ptr, "ns1:getDebts");
	case SOAP_TYPE_PointerTons1__getViolationsResponse:
		return soap_out_PointerTons1__getViolationsResponse(soap, tag, id, (ns1__getViolationsResponse *const*)ptr, "ns1:getViolationsResponse");
	case SOAP_TYPE_PointerTons1__getViolations:
		return soap_out_PointerTons1__getViolations(soap, tag, id, (ns1__getViolations *const*)ptr, "ns1:getViolations");
	case SOAP_TYPE_PointerTons1__getCircsResponse:
		return soap_out_PointerTons1__getCircsResponse(soap, tag, id, (ns1__getCircsResponse *const*)ptr, "ns1:getCircsResponse");
	case SOAP_TYPE_PointerTons1__getCircs:
		return soap_out_PointerTons1__getCircs(soap, tag, id, (ns1__getCircs *const*)ptr, "ns1:getCircs");
	case SOAP_TYPE_PointerTons1__getBookResponse:
		return soap_out_PointerTons1__getBookResponse(soap, tag, id, (ns1__getBookResponse *const*)ptr, "ns1:getBookResponse");
	case SOAP_TYPE_PointerTons1__getBook:
		return soap_out_PointerTons1__getBook(soap, tag, id, (ns1__getBook *const*)ptr, "ns1:getBook");
	case SOAP_TYPE_PointerTons1__getItemsResponse:
		return soap_out_PointerTons1__getItemsResponse(soap, tag, id, (ns1__getItemsResponse *const*)ptr, "ns1:getItemsResponse");
	case SOAP_TYPE_PointerTons1__getItems:
		return soap_out_PointerTons1__getItems(soap, tag, id, (ns1__getItems *const*)ptr, "ns1:getItems");
	case SOAP_TYPE_PointerTons1__getReaderResponse:
		return soap_out_PointerTons1__getReaderResponse(soap, tag, id, (ns1__getReaderResponse *const*)ptr, "ns1:getReaderResponse");
	case SOAP_TYPE_PointerTons1__getReader:
		return soap_out_PointerTons1__getReader(soap, tag, id, (ns1__getReader *const*)ptr, "ns1:getReader");
	case SOAP_TYPE_PointerTons1__SystemException:
		return soap_out_PointerTons1__SystemException(soap, tag, id, (ns1__SystemException *const*)ptr, "ns1:SystemException");
	case SOAP_TYPE_PointerTons1__NoAuthorityException:
		return soap_out_PointerTons1__NoAuthorityException(soap, tag, id, (ns1__NoAuthorityException *const*)ptr, "ns1:NoAuthorityException");
	case SOAP_TYPE_PointerTons1__lostPay:
		return soap_out_PointerTons1__lostPay(soap, tag, id, (ns1__lostPay *const*)ptr, "ns1:lostPay");
	case SOAP_TYPE_PointerTons1__preg:
		return soap_out_PointerTons1__preg(soap, tag, id, (ns1__preg *const*)ptr, "ns1:preg");
	case SOAP_TYPE_PointerTons1__account:
		return soap_out_PointerTons1__account(soap, tag, id, (ns1__account *const*)ptr, "ns1:account");
	case SOAP_TYPE_PointerTons1__marc:
		return soap_out_PointerTons1__marc(soap, tag, id, (ns1__marc *const*)ptr, "ns1:marc");
	case SOAP_TYPE_PointerTons1__relegate:
		return soap_out_PointerTons1__relegate(soap, tag, id, (ns1__relegate *const*)ptr, "ns1:relegate");
	case SOAP_TYPE_PointerTons1__violation:
		return soap_out_PointerTons1__violation(soap, tag, id, (ns1__violation *const*)ptr, "ns1:violation");
	case SOAP_TYPE_PointerTons1__debt:
		return soap_out_PointerTons1__debt(soap, tag, id, (ns1__debt *const*)ptr, "ns1:debt");
	case SOAP_TYPE_PointerTons1__checkRedrResult:
		return soap_out_PointerTons1__checkRedrResult(soap, tag, id, (ns1__checkRedrResult *const*)ptr, "ns1:checkRedrResult");
	case SOAP_TYPE_PointerTons1__simpleBean:
		return soap_out_PointerTons1__simpleBean(soap, tag, id, (ns1__simpleBean *const*)ptr, "ns1:simpleBean");
	case SOAP_TYPE_PointerTons1__reader:
		return soap_out_PointerTons1__reader(soap, tag, id, (ns1__reader *const*)ptr, "ns1:reader");
	case SOAP_TYPE_PointerTons1__circ:
		return soap_out_PointerTons1__circ(soap, tag, id, (ns1__circ *const*)ptr, "ns1:circ");
	case SOAP_TYPE_PointerTons1__arrival:
		return soap_out_PointerTons1__arrival(soap, tag, id, (ns1__arrival *const*)ptr, "ns1:arrival");
	case SOAP_TYPE_PointerTons1__item:
		return soap_out_PointerTons1__item(soap, tag, id, (ns1__item *const*)ptr, "ns1:item");
	case SOAP_TYPE_wstring:
		return soap_out_wstring(soap, tag, id, (wchar_t*const*)&ptr, "xsd:string");
	case SOAP_TYPE_PointerTons1__book:
		return soap_out_PointerTons1__book(soap, tag, id, (ns1__book *const*)ptr, "ns1:book");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__getRedrTypesResponse:
		((ns1__getRedrTypesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getRedrTypes:
		((ns1__getRedrTypes *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__exceedFine1Response:
		((ns1__exceedFine1Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__exceedFine1:
		((ns1__exceedFine1 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__lostPay:
		((ns1__lostPay *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getLostPaysResponse:
		((ns1__getLostPaysResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getLostPays:
		((ns1__getLostPays *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getAccounts1Response:
		((ns1__getAccounts1Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getAccounts1:
		((ns1__getAccounts1 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__registerReaderResponse:
		((ns1__registerReaderResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__registerReader:
		((ns1__registerReader *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__preg:
		((ns1__preg *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getPregsResponse:
		((ns1__getPregsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getPregs:
		((ns1__getPregs *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__account:
		((ns1__account *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getAccountsResponse:
		((ns1__getAccountsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getAccounts:
		((ns1__getAccounts *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__marc:
		((ns1__marc *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getMarcResponse:
		((ns1__getMarcResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getMarc:
		((ns1__getMarc *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getLendHistResponse:
		((ns1__getLendHistResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getLendHist:
		((ns1__getLendHist *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__certLossResponse:
		((ns1__certLossResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__certLoss:
		((ns1__certLoss *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getViolationsResponse:
		((ns1__getViolationsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getViolations:
		((ns1__getViolations *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__pregOrRelegate:
		((ns1__pregOrRelegate *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__relegate:
		((ns1__relegate *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getRelegatesResponse:
		((ns1__getRelegatesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getRelegates:
		((ns1__getRelegates *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__violation:
		((ns1__violation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getViolations1Response:
		((ns1__getViolations1Response *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getViolations1:
		((ns1__getViolations1 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__debt:
		((ns1__debt *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getDebtsResponse:
		((ns1__getDebtsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getDebts:
		((ns1__getDebts *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__checkRedrResult:
		((ns1__checkRedrResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__checkReaderResponse:
		((ns1__checkReaderResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__checkReader:
		((ns1__checkReader *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__simpleBean:
		((ns1__simpleBean *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getDepsResponse:
		((ns1__getDepsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getDeps:
		((ns1__getDeps *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__reader:
		((ns1__reader *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getReaderResponse:
		((ns1__getReaderResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getReader:
		((ns1__getReader *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__circ:
		((ns1__circ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getCircsResponse:
		((ns1__getCircsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getCircs:
		((ns1__getCircs *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__exceedFineResponse:
		((ns1__exceedFineResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__exceedFine:
		((ns1__exceedFine *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__voltFineResponse:
		((ns1__voltFineResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__voltFine:
		((ns1__voltFine *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__logoutResponse:
		((ns1__logoutResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__logout:
		((ns1__logout *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getPregArrivalsResponse:
		((ns1__getPregArrivalsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getPregArrivals:
		((ns1__getPregArrivals *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__arrival:
		((ns1__arrival *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getRelegateArrivalsResponse:
		((ns1__getRelegateArrivalsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getRelegateArrivals:
		((ns1__getRelegateArrivals *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__item:
		((ns1__item *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getItemsResponse:
		((ns1__getItemsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getItems:
		((ns1__getItems *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SystemException:
		((ns1__SystemException *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__NoAuthorityException:
		((ns1__NoAuthorityException *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__book:
		((ns1__book *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getBookResponse:
		((ns1__getBookResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getBook:
		((ns1__getBook *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns1__getAccounts1:
		soap_serialize___ns1__getAccounts1(soap, (const struct __ns1__getAccounts1 *)ptr);
		break;
	case SOAP_TYPE___ns1__getDeps:
		soap_serialize___ns1__getDeps(soap, (const struct __ns1__getDeps *)ptr);
		break;
	case SOAP_TYPE___ns1__getRedrTypes:
		soap_serialize___ns1__getRedrTypes(soap, (const struct __ns1__getRedrTypes *)ptr);
		break;
	case SOAP_TYPE___ns1__registerReader:
		soap_serialize___ns1__registerReader(soap, (const struct __ns1__registerReader *)ptr);
		break;
	case SOAP_TYPE___ns1__exceedFine1:
		soap_serialize___ns1__exceedFine1(soap, (const struct __ns1__exceedFine1 *)ptr);
		break;
	case SOAP_TYPE___ns1__getViolations1:
		soap_serialize___ns1__getViolations1(soap, (const struct __ns1__getViolations1 *)ptr);
		break;
	case SOAP_TYPE___ns1__voltFine:
		soap_serialize___ns1__voltFine(soap, (const struct __ns1__voltFine *)ptr);
		break;
	case SOAP_TYPE___ns1__checkReader:
		soap_serialize___ns1__checkReader(soap, (const struct __ns1__checkReader *)ptr);
		break;
	case SOAP_TYPE___ns1__getMarc:
		soap_serialize___ns1__getMarc(soap, (const struct __ns1__getMarc *)ptr);
		break;
	case SOAP_TYPE___ns1__getLendHist:
		soap_serialize___ns1__getLendHist(soap, (const struct __ns1__getLendHist *)ptr);
		break;
	case SOAP_TYPE___ns1__logout:
		soap_serialize___ns1__logout(soap, (const struct __ns1__logout *)ptr);
		break;
	case SOAP_TYPE___ns1__certLoss:
		soap_serialize___ns1__certLoss(soap, (const struct __ns1__certLoss *)ptr);
		break;
	case SOAP_TYPE___ns1__exceedFine:
		soap_serialize___ns1__exceedFine(soap, (const struct __ns1__exceedFine *)ptr);
		break;
	case SOAP_TYPE___ns1__getLostPays:
		soap_serialize___ns1__getLostPays(soap, (const struct __ns1__getLostPays *)ptr);
		break;
	case SOAP_TYPE___ns1__getAccounts:
		soap_serialize___ns1__getAccounts(soap, (const struct __ns1__getAccounts *)ptr);
		break;
	case SOAP_TYPE___ns1__getRelegates:
		soap_serialize___ns1__getRelegates(soap, (const struct __ns1__getRelegates *)ptr);
		break;
	case SOAP_TYPE___ns1__getPregs:
		soap_serialize___ns1__getPregs(soap, (const struct __ns1__getPregs *)ptr);
		break;
	case SOAP_TYPE___ns1__getRelegateArrivals:
		soap_serialize___ns1__getRelegateArrivals(soap, (const struct __ns1__getRelegateArrivals *)ptr);
		break;
	case SOAP_TYPE___ns1__getPregArrivals:
		soap_serialize___ns1__getPregArrivals(soap, (const struct __ns1__getPregArrivals *)ptr);
		break;
	case SOAP_TYPE___ns1__getDebts:
		soap_serialize___ns1__getDebts(soap, (const struct __ns1__getDebts *)ptr);
		break;
	case SOAP_TYPE___ns1__getViolations:
		soap_serialize___ns1__getViolations(soap, (const struct __ns1__getViolations *)ptr);
		break;
	case SOAP_TYPE___ns1__getCircs:
		soap_serialize___ns1__getCircs(soap, (const struct __ns1__getCircs *)ptr);
		break;
	case SOAP_TYPE___ns1__getBook:
		soap_serialize___ns1__getBook(soap, (const struct __ns1__getBook *)ptr);
		break;
	case SOAP_TYPE___ns1__getItems:
		soap_serialize___ns1__getItems(soap, (const struct __ns1__getItems *)ptr);
		break;
	case SOAP_TYPE___ns1__getReader:
		soap_serialize___ns1__getReader(soap, (const struct __ns1__getReader *)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getAccounts1Response:
		soap_serialize_PointerTons1__getAccounts1Response(soap, (ns1__getAccounts1Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getAccounts1:
		soap_serialize_PointerTons1__getAccounts1(soap, (ns1__getAccounts1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getDepsResponse:
		soap_serialize_PointerTons1__getDepsResponse(soap, (ns1__getDepsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getDeps:
		soap_serialize_PointerTons1__getDeps(soap, (ns1__getDeps *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getRedrTypesResponse:
		soap_serialize_PointerTons1__getRedrTypesResponse(soap, (ns1__getRedrTypesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getRedrTypes:
		soap_serialize_PointerTons1__getRedrTypes(soap, (ns1__getRedrTypes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__registerReaderResponse:
		soap_serialize_PointerTons1__registerReaderResponse(soap, (ns1__registerReaderResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__registerReader:
		soap_serialize_PointerTons1__registerReader(soap, (ns1__registerReader *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__exceedFine1Response:
		soap_serialize_PointerTons1__exceedFine1Response(soap, (ns1__exceedFine1Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__exceedFine1:
		soap_serialize_PointerTons1__exceedFine1(soap, (ns1__exceedFine1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getViolations1Response:
		soap_serialize_PointerTons1__getViolations1Response(soap, (ns1__getViolations1Response *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getViolations1:
		soap_serialize_PointerTons1__getViolations1(soap, (ns1__getViolations1 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__voltFineResponse:
		soap_serialize_PointerTons1__voltFineResponse(soap, (ns1__voltFineResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__voltFine:
		soap_serialize_PointerTons1__voltFine(soap, (ns1__voltFine *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__checkReaderResponse:
		soap_serialize_PointerTons1__checkReaderResponse(soap, (ns1__checkReaderResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__checkReader:
		soap_serialize_PointerTons1__checkReader(soap, (ns1__checkReader *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getMarcResponse:
		soap_serialize_PointerTons1__getMarcResponse(soap, (ns1__getMarcResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getMarc:
		soap_serialize_PointerTons1__getMarc(soap, (ns1__getMarc *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getLendHistResponse:
		soap_serialize_PointerTons1__getLendHistResponse(soap, (ns1__getLendHistResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getLendHist:
		soap_serialize_PointerTons1__getLendHist(soap, (ns1__getLendHist *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__logoutResponse:
		soap_serialize_PointerTons1__logoutResponse(soap, (ns1__logoutResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__logout:
		soap_serialize_PointerTons1__logout(soap, (ns1__logout *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__certLossResponse:
		soap_serialize_PointerTons1__certLossResponse(soap, (ns1__certLossResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__certLoss:
		soap_serialize_PointerTons1__certLoss(soap, (ns1__certLoss *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__exceedFineResponse:
		soap_serialize_PointerTons1__exceedFineResponse(soap, (ns1__exceedFineResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__exceedFine:
		soap_serialize_PointerTons1__exceedFine(soap, (ns1__exceedFine *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getLostPaysResponse:
		soap_serialize_PointerTons1__getLostPaysResponse(soap, (ns1__getLostPaysResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getLostPays:
		soap_serialize_PointerTons1__getLostPays(soap, (ns1__getLostPays *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getAccountsResponse:
		soap_serialize_PointerTons1__getAccountsResponse(soap, (ns1__getAccountsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getAccounts:
		soap_serialize_PointerTons1__getAccounts(soap, (ns1__getAccounts *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getRelegatesResponse:
		soap_serialize_PointerTons1__getRelegatesResponse(soap, (ns1__getRelegatesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getRelegates:
		soap_serialize_PointerTons1__getRelegates(soap, (ns1__getRelegates *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getPregsResponse:
		soap_serialize_PointerTons1__getPregsResponse(soap, (ns1__getPregsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getPregs:
		soap_serialize_PointerTons1__getPregs(soap, (ns1__getPregs *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getRelegateArrivalsResponse:
		soap_serialize_PointerTons1__getRelegateArrivalsResponse(soap, (ns1__getRelegateArrivalsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getRelegateArrivals:
		soap_serialize_PointerTons1__getRelegateArrivals(soap, (ns1__getRelegateArrivals *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getPregArrivalsResponse:
		soap_serialize_PointerTons1__getPregArrivalsResponse(soap, (ns1__getPregArrivalsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getPregArrivals:
		soap_serialize_PointerTons1__getPregArrivals(soap, (ns1__getPregArrivals *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getDebtsResponse:
		soap_serialize_PointerTons1__getDebtsResponse(soap, (ns1__getDebtsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getDebts:
		soap_serialize_PointerTons1__getDebts(soap, (ns1__getDebts *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getViolationsResponse:
		soap_serialize_PointerTons1__getViolationsResponse(soap, (ns1__getViolationsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getViolations:
		soap_serialize_PointerTons1__getViolations(soap, (ns1__getViolations *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getCircsResponse:
		soap_serialize_PointerTons1__getCircsResponse(soap, (ns1__getCircsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getCircs:
		soap_serialize_PointerTons1__getCircs(soap, (ns1__getCircs *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getBookResponse:
		soap_serialize_PointerTons1__getBookResponse(soap, (ns1__getBookResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getBook:
		soap_serialize_PointerTons1__getBook(soap, (ns1__getBook *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getItemsResponse:
		soap_serialize_PointerTons1__getItemsResponse(soap, (ns1__getItemsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getItems:
		soap_serialize_PointerTons1__getItems(soap, (ns1__getItems *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getReaderResponse:
		soap_serialize_PointerTons1__getReaderResponse(soap, (ns1__getReaderResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getReader:
		soap_serialize_PointerTons1__getReader(soap, (ns1__getReader *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SystemException:
		soap_serialize_PointerTons1__SystemException(soap, (ns1__SystemException *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__NoAuthorityException:
		soap_serialize_PointerTons1__NoAuthorityException(soap, (ns1__NoAuthorityException *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__lostPay:
		soap_serialize_PointerTons1__lostPay(soap, (ns1__lostPay *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__preg:
		soap_serialize_PointerTons1__preg(soap, (ns1__preg *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__account:
		soap_serialize_PointerTons1__account(soap, (ns1__account *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__marc:
		soap_serialize_PointerTons1__marc(soap, (ns1__marc *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__relegate:
		soap_serialize_PointerTons1__relegate(soap, (ns1__relegate *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__violation:
		soap_serialize_PointerTons1__violation(soap, (ns1__violation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__debt:
		soap_serialize_PointerTons1__debt(soap, (ns1__debt *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__checkRedrResult:
		soap_serialize_PointerTons1__checkRedrResult(soap, (ns1__checkRedrResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__simpleBean:
		soap_serialize_PointerTons1__simpleBean(soap, (ns1__simpleBean *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__reader:
		soap_serialize_PointerTons1__reader(soap, (ns1__reader *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__circ:
		soap_serialize_PointerTons1__circ(soap, (ns1__circ *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__arrival:
		soap_serialize_PointerTons1__arrival(soap, (ns1__arrival *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__item:
		soap_serialize_PointerTons1__item(soap, (ns1__item *const*)ptr);
		break;
	case SOAP_TYPE_wstring:
		soap_serialize_wstring(soap, (wchar_t*const*)&ptr);
		break;
	case SOAP_TYPE_PointerTons1__book:
		soap_serialize_PointerTons1__book(soap, (ns1__book *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getBook:
		return (void*)soap_instantiate_ns1__getBook(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getBookResponse:
		return (void*)soap_instantiate_ns1__getBookResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__book:
		return (void*)soap_instantiate_ns1__book(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__NoAuthorityException:
		return (void*)soap_instantiate_ns1__NoAuthorityException(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SystemException:
		return (void*)soap_instantiate_ns1__SystemException(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getItems:
		return (void*)soap_instantiate_ns1__getItems(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getItemsResponse:
		return (void*)soap_instantiate_ns1__getItemsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__item:
		return (void*)soap_instantiate_ns1__item(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getRelegateArrivals:
		return (void*)soap_instantiate_ns1__getRelegateArrivals(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getRelegateArrivalsResponse:
		return (void*)soap_instantiate_ns1__getRelegateArrivalsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__arrival:
		return (void*)soap_instantiate_ns1__arrival(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getPregArrivals:
		return (void*)soap_instantiate_ns1__getPregArrivals(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getPregArrivalsResponse:
		return (void*)soap_instantiate_ns1__getPregArrivalsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__logout:
		return (void*)soap_instantiate_ns1__logout(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__logoutResponse:
		return (void*)soap_instantiate_ns1__logoutResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__voltFine:
		return (void*)soap_instantiate_ns1__voltFine(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__voltFineResponse:
		return (void*)soap_instantiate_ns1__voltFineResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__exceedFine:
		return (void*)soap_instantiate_ns1__exceedFine(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__exceedFineResponse:
		return (void*)soap_instantiate_ns1__exceedFineResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getCircs:
		return (void*)soap_instantiate_ns1__getCircs(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getCircsResponse:
		return (void*)soap_instantiate_ns1__getCircsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__circ:
		return (void*)soap_instantiate_ns1__circ(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getReader:
		return (void*)soap_instantiate_ns1__getReader(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getReaderResponse:
		return (void*)soap_instantiate_ns1__getReaderResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__reader:
		return (void*)soap_instantiate_ns1__reader(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDeps:
		return (void*)soap_instantiate_ns1__getDeps(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDepsResponse:
		return (void*)soap_instantiate_ns1__getDepsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__simpleBean:
		return (void*)soap_instantiate_ns1__simpleBean(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__checkReader:
		return (void*)soap_instantiate_ns1__checkReader(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__checkReaderResponse:
		return (void*)soap_instantiate_ns1__checkReaderResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__checkRedrResult:
		return (void*)soap_instantiate_ns1__checkRedrResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDebts:
		return (void*)soap_instantiate_ns1__getDebts(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDebtsResponse:
		return (void*)soap_instantiate_ns1__getDebtsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__debt:
		return (void*)soap_instantiate_ns1__debt(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getViolations1:
		return (void*)soap_instantiate_ns1__getViolations1(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getViolations1Response:
		return (void*)soap_instantiate_ns1__getViolations1Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__violation:
		return (void*)soap_instantiate_ns1__violation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getRelegates:
		return (void*)soap_instantiate_ns1__getRelegates(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getRelegatesResponse:
		return (void*)soap_instantiate_ns1__getRelegatesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__pregOrRelegate:
		return (void*)soap_instantiate_ns1__pregOrRelegate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getViolations:
		return (void*)soap_instantiate_ns1__getViolations(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getViolationsResponse:
		return (void*)soap_instantiate_ns1__getViolationsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__certLoss:
		return (void*)soap_instantiate_ns1__certLoss(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__certLossResponse:
		return (void*)soap_instantiate_ns1__certLossResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getLendHist:
		return (void*)soap_instantiate_ns1__getLendHist(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getLendHistResponse:
		return (void*)soap_instantiate_ns1__getLendHistResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getMarc:
		return (void*)soap_instantiate_ns1__getMarc(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getMarcResponse:
		return (void*)soap_instantiate_ns1__getMarcResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__marc:
		return (void*)soap_instantiate_ns1__marc(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getAccounts:
		return (void*)soap_instantiate_ns1__getAccounts(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getAccountsResponse:
		return (void*)soap_instantiate_ns1__getAccountsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__account:
		return (void*)soap_instantiate_ns1__account(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getPregs:
		return (void*)soap_instantiate_ns1__getPregs(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getPregsResponse:
		return (void*)soap_instantiate_ns1__getPregsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__registerReader:
		return (void*)soap_instantiate_ns1__registerReader(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__registerReaderResponse:
		return (void*)soap_instantiate_ns1__registerReaderResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getAccounts1:
		return (void*)soap_instantiate_ns1__getAccounts1(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getAccounts1Response:
		return (void*)soap_instantiate_ns1__getAccounts1Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getLostPays:
		return (void*)soap_instantiate_ns1__getLostPays(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getLostPaysResponse:
		return (void*)soap_instantiate_ns1__getLostPaysResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__lostPay:
		return (void*)soap_instantiate_ns1__lostPay(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__exceedFine1:
		return (void*)soap_instantiate_ns1__exceedFine1(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__exceedFine1Response:
		return (void*)soap_instantiate_ns1__exceedFine1Response(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getRedrTypes:
		return (void*)soap_instantiate_ns1__getRedrTypes(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getRedrTypesResponse:
		return (void*)soap_instantiate_ns1__getRedrTypesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__relegate:
		return (void*)soap_instantiate_ns1__relegate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__preg:
		return (void*)soap_instantiate_ns1__preg(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE___ns1__getReader:
		return (void*)soap_instantiate___ns1__getReader(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getItems:
		return (void*)soap_instantiate___ns1__getItems(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getBook:
		return (void*)soap_instantiate___ns1__getBook(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getCircs:
		return (void*)soap_instantiate___ns1__getCircs(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getViolations:
		return (void*)soap_instantiate___ns1__getViolations(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getDebts:
		return (void*)soap_instantiate___ns1__getDebts(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getPregArrivals:
		return (void*)soap_instantiate___ns1__getPregArrivals(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getRelegateArrivals:
		return (void*)soap_instantiate___ns1__getRelegateArrivals(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getPregs:
		return (void*)soap_instantiate___ns1__getPregs(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getRelegates:
		return (void*)soap_instantiate___ns1__getRelegates(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getAccounts:
		return (void*)soap_instantiate___ns1__getAccounts(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getLostPays:
		return (void*)soap_instantiate___ns1__getLostPays(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__exceedFine:
		return (void*)soap_instantiate___ns1__exceedFine(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__certLoss:
		return (void*)soap_instantiate___ns1__certLoss(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__logout:
		return (void*)soap_instantiate___ns1__logout(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getLendHist:
		return (void*)soap_instantiate___ns1__getLendHist(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getMarc:
		return (void*)soap_instantiate___ns1__getMarc(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__checkReader:
		return (void*)soap_instantiate___ns1__checkReader(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__voltFine:
		return (void*)soap_instantiate___ns1__voltFine(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getViolations1:
		return (void*)soap_instantiate___ns1__getViolations1(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__exceedFine1:
		return (void*)soap_instantiate___ns1__exceedFine1(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__registerReader:
		return (void*)soap_instantiate___ns1__registerReader(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getRedrTypes:
		return (void*)soap_instantiate___ns1__getRedrTypes(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getDeps:
		return (void*)soap_instantiate___ns1__getDeps(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getAccounts1:
		return (void*)soap_instantiate___ns1__getAccounts1(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__lostPay:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__lostPay(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__preg:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__preg(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__account:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__account(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__relegate:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__relegate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__violation:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__violation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__debt:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__debt(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__simpleBean:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__simpleBean(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__circ:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__circ(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__arrival:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__arrival(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__item:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__item(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getBook:
		if (p->size < 0)
			SOAP_DELETE((ns1__getBook*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getBook*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getBookResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getBookResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getBookResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__book:
		if (p->size < 0)
			SOAP_DELETE((ns1__book*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__book*)p->ptr);
		break;
	case SOAP_TYPE_ns1__NoAuthorityException:
		if (p->size < 0)
			SOAP_DELETE((ns1__NoAuthorityException*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__NoAuthorityException*)p->ptr);
		break;
	case SOAP_TYPE_ns1__SystemException:
		if (p->size < 0)
			SOAP_DELETE((ns1__SystemException*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__SystemException*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getItems:
		if (p->size < 0)
			SOAP_DELETE((ns1__getItems*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getItems*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getItemsResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getItemsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getItemsResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__item:
		if (p->size < 0)
			SOAP_DELETE((ns1__item*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__item*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getRelegateArrivals:
		if (p->size < 0)
			SOAP_DELETE((ns1__getRelegateArrivals*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getRelegateArrivals*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getRelegateArrivalsResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getRelegateArrivalsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getRelegateArrivalsResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__arrival:
		if (p->size < 0)
			SOAP_DELETE((ns1__arrival*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__arrival*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getPregArrivals:
		if (p->size < 0)
			SOAP_DELETE((ns1__getPregArrivals*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getPregArrivals*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getPregArrivalsResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getPregArrivalsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getPregArrivalsResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__logout:
		if (p->size < 0)
			SOAP_DELETE((ns1__logout*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__logout*)p->ptr);
		break;
	case SOAP_TYPE_ns1__logoutResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__logoutResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__logoutResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__voltFine:
		if (p->size < 0)
			SOAP_DELETE((ns1__voltFine*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__voltFine*)p->ptr);
		break;
	case SOAP_TYPE_ns1__voltFineResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__voltFineResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__voltFineResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__exceedFine:
		if (p->size < 0)
			SOAP_DELETE((ns1__exceedFine*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__exceedFine*)p->ptr);
		break;
	case SOAP_TYPE_ns1__exceedFineResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__exceedFineResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__exceedFineResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getCircs:
		if (p->size < 0)
			SOAP_DELETE((ns1__getCircs*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getCircs*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getCircsResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getCircsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getCircsResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__circ:
		if (p->size < 0)
			SOAP_DELETE((ns1__circ*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__circ*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getReader:
		if (p->size < 0)
			SOAP_DELETE((ns1__getReader*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getReader*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getReaderResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getReaderResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getReaderResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__reader:
		if (p->size < 0)
			SOAP_DELETE((ns1__reader*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__reader*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getDeps:
		if (p->size < 0)
			SOAP_DELETE((ns1__getDeps*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getDeps*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getDepsResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getDepsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getDepsResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__simpleBean:
		if (p->size < 0)
			SOAP_DELETE((ns1__simpleBean*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__simpleBean*)p->ptr);
		break;
	case SOAP_TYPE_ns1__checkReader:
		if (p->size < 0)
			SOAP_DELETE((ns1__checkReader*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__checkReader*)p->ptr);
		break;
	case SOAP_TYPE_ns1__checkReaderResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__checkReaderResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__checkReaderResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__checkRedrResult:
		if (p->size < 0)
			SOAP_DELETE((ns1__checkRedrResult*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__checkRedrResult*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getDebts:
		if (p->size < 0)
			SOAP_DELETE((ns1__getDebts*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getDebts*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getDebtsResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getDebtsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getDebtsResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__debt:
		if (p->size < 0)
			SOAP_DELETE((ns1__debt*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__debt*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getViolations1:
		if (p->size < 0)
			SOAP_DELETE((ns1__getViolations1*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getViolations1*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getViolations1Response:
		if (p->size < 0)
			SOAP_DELETE((ns1__getViolations1Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getViolations1Response*)p->ptr);
		break;
	case SOAP_TYPE_ns1__violation:
		if (p->size < 0)
			SOAP_DELETE((ns1__violation*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__violation*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getRelegates:
		if (p->size < 0)
			SOAP_DELETE((ns1__getRelegates*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getRelegates*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getRelegatesResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getRelegatesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getRelegatesResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__pregOrRelegate:
		if (p->size < 0)
			SOAP_DELETE((ns1__pregOrRelegate*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__pregOrRelegate*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getViolations:
		if (p->size < 0)
			SOAP_DELETE((ns1__getViolations*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getViolations*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getViolationsResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getViolationsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getViolationsResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__certLoss:
		if (p->size < 0)
			SOAP_DELETE((ns1__certLoss*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__certLoss*)p->ptr);
		break;
	case SOAP_TYPE_ns1__certLossResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__certLossResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__certLossResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getLendHist:
		if (p->size < 0)
			SOAP_DELETE((ns1__getLendHist*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getLendHist*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getLendHistResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getLendHistResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getLendHistResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getMarc:
		if (p->size < 0)
			SOAP_DELETE((ns1__getMarc*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getMarc*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getMarcResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getMarcResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getMarcResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__marc:
		if (p->size < 0)
			SOAP_DELETE((ns1__marc*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__marc*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getAccounts:
		if (p->size < 0)
			SOAP_DELETE((ns1__getAccounts*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getAccounts*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getAccountsResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getAccountsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getAccountsResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__account:
		if (p->size < 0)
			SOAP_DELETE((ns1__account*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__account*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getPregs:
		if (p->size < 0)
			SOAP_DELETE((ns1__getPregs*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getPregs*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getPregsResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getPregsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getPregsResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__registerReader:
		if (p->size < 0)
			SOAP_DELETE((ns1__registerReader*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__registerReader*)p->ptr);
		break;
	case SOAP_TYPE_ns1__registerReaderResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__registerReaderResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__registerReaderResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getAccounts1:
		if (p->size < 0)
			SOAP_DELETE((ns1__getAccounts1*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getAccounts1*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getAccounts1Response:
		if (p->size < 0)
			SOAP_DELETE((ns1__getAccounts1Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getAccounts1Response*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getLostPays:
		if (p->size < 0)
			SOAP_DELETE((ns1__getLostPays*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getLostPays*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getLostPaysResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getLostPaysResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getLostPaysResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__lostPay:
		if (p->size < 0)
			SOAP_DELETE((ns1__lostPay*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__lostPay*)p->ptr);
		break;
	case SOAP_TYPE_ns1__exceedFine1:
		if (p->size < 0)
			SOAP_DELETE((ns1__exceedFine1*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__exceedFine1*)p->ptr);
		break;
	case SOAP_TYPE_ns1__exceedFine1Response:
		if (p->size < 0)
			SOAP_DELETE((ns1__exceedFine1Response*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__exceedFine1Response*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getRedrTypes:
		if (p->size < 0)
			SOAP_DELETE((ns1__getRedrTypes*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getRedrTypes*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getRedrTypesResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getRedrTypesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getRedrTypesResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__relegate:
		if (p->size < 0)
			SOAP_DELETE((ns1__relegate*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__relegate*)p->ptr);
		break;
	case SOAP_TYPE_ns1__preg:
		if (p->size < 0)
			SOAP_DELETE((ns1__preg*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__preg*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getReader:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getReader*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getReader*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getItems:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getItems*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getItems*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getBook:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getBook*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getBook*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getCircs:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getCircs*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getCircs*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getViolations:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getViolations*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getViolations*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getDebts:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getDebts*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getDebts*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getPregArrivals:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getPregArrivals*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getPregArrivals*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getRelegateArrivals:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getRelegateArrivals*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getRelegateArrivals*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getPregs:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getPregs*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getPregs*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getRelegates:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getRelegates*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getRelegates*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getAccounts:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getAccounts*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getAccounts*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getLostPays:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getLostPays*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getLostPays*)p->ptr);
		break;
	case SOAP_TYPE___ns1__exceedFine:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__exceedFine*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__exceedFine*)p->ptr);
		break;
	case SOAP_TYPE___ns1__certLoss:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__certLoss*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__certLoss*)p->ptr);
		break;
	case SOAP_TYPE___ns1__logout:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__logout*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__logout*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getLendHist:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getLendHist*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getLendHist*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getMarc:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getMarc*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getMarc*)p->ptr);
		break;
	case SOAP_TYPE___ns1__checkReader:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__checkReader*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__checkReader*)p->ptr);
		break;
	case SOAP_TYPE___ns1__voltFine:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__voltFine*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__voltFine*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getViolations1:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getViolations1*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getViolations1*)p->ptr);
		break;
	case SOAP_TYPE___ns1__exceedFine1:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__exceedFine1*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__exceedFine1*)p->ptr);
		break;
	case SOAP_TYPE___ns1__registerReader:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__registerReader*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__registerReader*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getRedrTypes:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getRedrTypes*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getRedrTypes*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getDeps:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getDeps*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getDeps*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getAccounts1:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getAccounts1*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getAccounts1*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__lostPay:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__lostPay * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__lostPay * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__preg:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__preg * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__preg * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__account:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__account * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__account * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__relegate:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__relegate * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__relegate * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__violation:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__violation * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__violation * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__debt:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__debt * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__debt * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__simpleBean:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__simpleBean * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__simpleBean * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__circ:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__circ * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__circ * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__arrival:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__arrival * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__arrival * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__item:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__item * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__item * >*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__lostPay:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__lostPay * >*)p)[len] = *(ns1__lostPay **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__preg:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__preg * >*)p)[len] = *(ns1__preg **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__account:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__account * >*)p)[len] = *(ns1__account **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__relegate:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__relegate * >*)p)[len] = *(ns1__relegate **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__violation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__violation * >*)p)[len] = *(ns1__violation **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__debt:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__debt * >*)p)[len] = *(ns1__debt **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__simpleBean:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__simpleBean * >*)p)[len] = *(ns1__simpleBean **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__circ:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__circ * >*)p)[len] = *(ns1__circ **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__arrival:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__arrival * >*)p)[len] = *(ns1__arrival **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__item:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__item * >*)p)[len] = *(ns1__item **)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_float(struct soap *soap, float *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_float
	*a = SOAP_DEFAULT_float;
#else
	*a = (float)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_float(struct soap *soap, const char *tag, int id, const float *a, const char *type)
{
	return soap_outfloat(soap, tag, id, a, type, SOAP_TYPE_float);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_in_float(struct soap *soap, const char *tag, float *a, const char *type)
{	float *p;
	p = soap_infloat(soap, tag, a, type, SOAP_TYPE_float);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_float(struct soap *soap, const float *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_float);
	if (soap_out_float(soap, tag?tag:"float", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_get_float(struct soap *soap, float *p, const char *tag, const char *type)
{
	if ((p = soap_in_float(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
{	(void)soap; (void)p; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::string[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void ns1__getRedrTypesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__simpleBean(soap, &this->ns1__getRedrTypesResponse::return_);
	/* transient soap skipped */
}

void ns1__getRedrTypesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__simpleBean(soap, &this->ns1__getRedrTypesResponse::return_);
	/* transient soap skipped */
}

int ns1__getRedrTypesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getRedrTypesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getRedrTypesResponse(struct soap *soap, const char *tag, int id, const ns1__getRedrTypesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getRedrTypesResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__simpleBean(soap, "return", -1, &(a->ns1__getRedrTypesResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getRedrTypesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getRedrTypesResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getRedrTypesResponse * SOAP_FMAC4 soap_in_ns1__getRedrTypesResponse(struct soap *soap, const char *tag, ns1__getRedrTypesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getRedrTypesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getRedrTypesResponse, sizeof(ns1__getRedrTypesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getRedrTypesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getRedrTypesResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__simpleBean(soap, "return", &(a->ns1__getRedrTypesResponse::return_), "ns1:simpleBean"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getRedrTypesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getRedrTypesResponse, 0, sizeof(ns1__getRedrTypesResponse), 0, soap_copy_ns1__getRedrTypesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getRedrTypesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getRedrTypesResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getRedrTypesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getRedrTypesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getRedrTypesResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getRedrTypesResponse * SOAP_FMAC4 soap_get_ns1__getRedrTypesResponse(struct soap *soap, ns1__getRedrTypesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getRedrTypesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getRedrTypesResponse * SOAP_FMAC2 soap_instantiate_ns1__getRedrTypesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getRedrTypesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getRedrTypesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getRedrTypesResponse);
		if (size)
			*size = sizeof(ns1__getRedrTypesResponse);
		((ns1__getRedrTypesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getRedrTypesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getRedrTypesResponse);
		for (int i = 0; i < n; i++)
			((ns1__getRedrTypesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getRedrTypesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getRedrTypesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getRedrTypesResponse %p -> %p\n", q, p));
	*(ns1__getRedrTypesResponse*)p = *(ns1__getRedrTypesResponse*)q;
}

void ns1__getRedrTypes::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getRedrTypes::arg0 = NULL;
	this->ns1__getRedrTypes::arg1 = NULL;
	this->ns1__getRedrTypes::arg2 = NULL;
	/* transient soap skipped */
}

void ns1__getRedrTypes::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getRedrTypes::arg0);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getRedrTypes::arg1);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getRedrTypes::arg2);
	/* transient soap skipped */
}

int ns1__getRedrTypes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getRedrTypes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getRedrTypes(struct soap *soap, const char *tag, int id, const ns1__getRedrTypes *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getRedrTypes), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->ns1__getRedrTypes::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg1", -1, &(a->ns1__getRedrTypes::arg1), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg2", -1, &(a->ns1__getRedrTypes::arg2), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getRedrTypes::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getRedrTypes(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getRedrTypes * SOAP_FMAC4 soap_in_ns1__getRedrTypes(struct soap *soap, const char *tag, ns1__getRedrTypes *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getRedrTypes *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getRedrTypes, sizeof(ns1__getRedrTypes), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getRedrTypes)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getRedrTypes *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_arg21 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->ns1__getRedrTypes::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_arg11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg1", &(a->ns1__getRedrTypes::arg1), "xsd:string"))
				{	soap_flag_arg11--;
					continue;
				}
			if (soap_flag_arg21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg2", &(a->ns1__getRedrTypes::arg2), "xsd:string"))
				{	soap_flag_arg21--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getRedrTypes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getRedrTypes, 0, sizeof(ns1__getRedrTypes), 0, soap_copy_ns1__getRedrTypes);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getRedrTypes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getRedrTypes);
	if (this->soap_out(soap, tag?tag:"ns1:getRedrTypes", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getRedrTypes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getRedrTypes(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getRedrTypes * SOAP_FMAC4 soap_get_ns1__getRedrTypes(struct soap *soap, ns1__getRedrTypes *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getRedrTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getRedrTypes * SOAP_FMAC2 soap_instantiate_ns1__getRedrTypes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getRedrTypes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getRedrTypes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getRedrTypes);
		if (size)
			*size = sizeof(ns1__getRedrTypes);
		((ns1__getRedrTypes*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getRedrTypes[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getRedrTypes);
		for (int i = 0; i < n; i++)
			((ns1__getRedrTypes*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getRedrTypes*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getRedrTypes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getRedrTypes %p -> %p\n", q, p));
	*(ns1__getRedrTypes*)p = *(ns1__getRedrTypes*)q;
}

void ns1__exceedFine1Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void ns1__exceedFine1Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__exceedFine1Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__exceedFine1Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__exceedFine1Response(struct soap *soap, const char *tag, int id, const ns1__exceedFine1Response *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__exceedFine1Response), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__exceedFine1Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__exceedFine1Response(soap, tag, this, type);
}

SOAP_FMAC3 ns1__exceedFine1Response * SOAP_FMAC4 soap_in_ns1__exceedFine1Response(struct soap *soap, const char *tag, ns1__exceedFine1Response *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__exceedFine1Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__exceedFine1Response, sizeof(ns1__exceedFine1Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__exceedFine1Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__exceedFine1Response *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__exceedFine1Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__exceedFine1Response, 0, sizeof(ns1__exceedFine1Response), 0, soap_copy_ns1__exceedFine1Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__exceedFine1Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__exceedFine1Response);
	if (this->soap_out(soap, tag?tag:"ns1:exceedFine1Response", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__exceedFine1Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__exceedFine1Response(soap, this, tag, type);
}

SOAP_FMAC3 ns1__exceedFine1Response * SOAP_FMAC4 soap_get_ns1__exceedFine1Response(struct soap *soap, ns1__exceedFine1Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__exceedFine1Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__exceedFine1Response * SOAP_FMAC2 soap_instantiate_ns1__exceedFine1Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__exceedFine1Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__exceedFine1Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__exceedFine1Response);
		if (size)
			*size = sizeof(ns1__exceedFine1Response);
		((ns1__exceedFine1Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__exceedFine1Response[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__exceedFine1Response);
		for (int i = 0; i < n; i++)
			((ns1__exceedFine1Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__exceedFine1Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__exceedFine1Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__exceedFine1Response %p -> %p\n", q, p));
	*(ns1__exceedFine1Response*)p = *(ns1__exceedFine1Response*)q;
}

void ns1__exceedFine1::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__exceedFine1::arg0 = NULL;
	this->ns1__exceedFine1::arg1 = NULL;
	this->ns1__exceedFine1::arg2 = NULL;
	this->ns1__exceedFine1::arg3 = NULL;
	this->ns1__exceedFine1::arg4 = NULL;
	this->ns1__exceedFine1::arg5 = NULL;
	this->ns1__exceedFine1::arg6 = NULL;
	soap_default_float(soap, &this->ns1__exceedFine1::arg7);
	this->ns1__exceedFine1::arg8 = NULL;
	this->ns1__exceedFine1::arg9 = NULL;
	soap_default_int(soap, &this->ns1__exceedFine1::arg10);
	/* transient soap skipped */
}

void ns1__exceedFine1::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__exceedFine1::arg0);
	soap_serialize_PointerTostd__string(soap, &this->ns1__exceedFine1::arg1);
	soap_serialize_PointerTostd__string(soap, &this->ns1__exceedFine1::arg2);
	soap_serialize_PointerTostd__string(soap, &this->ns1__exceedFine1::arg3);
	soap_serialize_PointerTostd__string(soap, &this->ns1__exceedFine1::arg4);
	soap_serialize_PointerTostd__string(soap, &this->ns1__exceedFine1::arg5);
	soap_serialize_PointerTostd__string(soap, &this->ns1__exceedFine1::arg6);
	soap_serialize_PointerTostd__string(soap, &this->ns1__exceedFine1::arg8);
	soap_serialize_PointerTostd__string(soap, &this->ns1__exceedFine1::arg9);
	/* transient soap skipped */
}

int ns1__exceedFine1::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__exceedFine1(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__exceedFine1(struct soap *soap, const char *tag, int id, const ns1__exceedFine1 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__exceedFine1), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->ns1__exceedFine1::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg1", -1, &(a->ns1__exceedFine1::arg1), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg2", -1, &(a->ns1__exceedFine1::arg2), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg3", -1, &(a->ns1__exceedFine1::arg3), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg4", -1, &(a->ns1__exceedFine1::arg4), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg5", -1, &(a->ns1__exceedFine1::arg5), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg6", -1, &(a->ns1__exceedFine1::arg6), ""))
		return soap->error;
	if (soap_out_float(soap, "arg7", -1, &(a->ns1__exceedFine1::arg7), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg8", -1, &(a->ns1__exceedFine1::arg8), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg9", -1, &(a->ns1__exceedFine1::arg9), ""))
		return soap->error;
	if (soap_out_int(soap, "arg10", -1, &(a->ns1__exceedFine1::arg10), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__exceedFine1::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__exceedFine1(soap, tag, this, type);
}

SOAP_FMAC3 ns1__exceedFine1 * SOAP_FMAC4 soap_in_ns1__exceedFine1(struct soap *soap, const char *tag, ns1__exceedFine1 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__exceedFine1 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__exceedFine1, sizeof(ns1__exceedFine1), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__exceedFine1)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__exceedFine1 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_arg21 = 1;
	size_t soap_flag_arg31 = 1;
	size_t soap_flag_arg41 = 1;
	size_t soap_flag_arg51 = 1;
	size_t soap_flag_arg61 = 1;
	size_t soap_flag_arg71 = 1;
	size_t soap_flag_arg81 = 1;
	size_t soap_flag_arg91 = 1;
	size_t soap_flag_arg101 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->ns1__exceedFine1::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_arg11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg1", &(a->ns1__exceedFine1::arg1), "xsd:string"))
				{	soap_flag_arg11--;
					continue;
				}
			if (soap_flag_arg21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg2", &(a->ns1__exceedFine1::arg2), "xsd:string"))
				{	soap_flag_arg21--;
					continue;
				}
			if (soap_flag_arg31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg3", &(a->ns1__exceedFine1::arg3), "xsd:string"))
				{	soap_flag_arg31--;
					continue;
				}
			if (soap_flag_arg41 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg4", &(a->ns1__exceedFine1::arg4), "xsd:string"))
				{	soap_flag_arg41--;
					continue;
				}
			if (soap_flag_arg51 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg5", &(a->ns1__exceedFine1::arg5), "xsd:string"))
				{	soap_flag_arg51--;
					continue;
				}
			if (soap_flag_arg61 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg6", &(a->ns1__exceedFine1::arg6), "xsd:string"))
				{	soap_flag_arg61--;
					continue;
				}
			if (soap_flag_arg71 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "arg7", &(a->ns1__exceedFine1::arg7), "xsd:float"))
				{	soap_flag_arg71--;
					continue;
				}
			if (soap_flag_arg81 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg8", &(a->ns1__exceedFine1::arg8), "xsd:string"))
				{	soap_flag_arg81--;
					continue;
				}
			if (soap_flag_arg91 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg9", &(a->ns1__exceedFine1::arg9), "xsd:string"))
				{	soap_flag_arg91--;
					continue;
				}
			if (soap_flag_arg101 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "arg10", &(a->ns1__exceedFine1::arg10), "xsd:int"))
				{	soap_flag_arg101--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__exceedFine1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__exceedFine1, 0, sizeof(ns1__exceedFine1), 0, soap_copy_ns1__exceedFine1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg71 > 0 || soap_flag_arg101 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__exceedFine1::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__exceedFine1);
	if (this->soap_out(soap, tag?tag:"ns1:exceedFine1", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__exceedFine1::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__exceedFine1(soap, this, tag, type);
}

SOAP_FMAC3 ns1__exceedFine1 * SOAP_FMAC4 soap_get_ns1__exceedFine1(struct soap *soap, ns1__exceedFine1 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__exceedFine1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__exceedFine1 * SOAP_FMAC2 soap_instantiate_ns1__exceedFine1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__exceedFine1(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__exceedFine1, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__exceedFine1);
		if (size)
			*size = sizeof(ns1__exceedFine1);
		((ns1__exceedFine1*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__exceedFine1[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__exceedFine1);
		for (int i = 0; i < n; i++)
			((ns1__exceedFine1*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__exceedFine1*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__exceedFine1(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__exceedFine1 %p -> %p\n", q, p));
	*(ns1__exceedFine1*)p = *(ns1__exceedFine1*)q;
}

void ns1__lostPay::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__lostPay::barCode = NULL;
	this->ns1__lostPay::billNo = NULL;
	soap_default_float(soap, &this->ns1__lostPay::bookAmt);
	this->ns1__lostPay::certId = NULL;
	this->ns1__lostPay::name = NULL;
	this->ns1__lostPay::propNo = NULL;
	this->ns1__lostPay::recoupType = NULL;
	soap_default_float(soap, &this->ns1__lostPay::servFee);
	soap_default_float(soap, &this->ns1__lostPay::techFee);
	this->ns1__lostPay::title = NULL;
	/* transient soap skipped */
}

void ns1__lostPay::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_wstring(soap, &this->ns1__lostPay::barCode);
	soap_serialize_wstring(soap, &this->ns1__lostPay::billNo);
	soap_serialize_wstring(soap, &this->ns1__lostPay::certId);
	soap_serialize_wstring(soap, &this->ns1__lostPay::name);
	soap_serialize_wstring(soap, &this->ns1__lostPay::propNo);
	soap_serialize_wstring(soap, &this->ns1__lostPay::recoupType);
	soap_serialize_wstring(soap, &this->ns1__lostPay::title);
	/* transient soap skipped */
}

int ns1__lostPay::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__lostPay(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__lostPay(struct soap *soap, const char *tag, int id, const ns1__lostPay *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__lostPay), type))
		return soap->error;
	if (soap_out_wstring(soap, "barCode", -1, &(a->ns1__lostPay::barCode), ""))
		return soap->error;
	if (soap_out_wstring(soap, "billNo", -1, &(a->ns1__lostPay::billNo), ""))
		return soap->error;
	if (soap_out_float(soap, "bookAmt", -1, &(a->ns1__lostPay::bookAmt), ""))
		return soap->error;
	if (soap_out_wstring(soap, "certId", -1, &(a->ns1__lostPay::certId), ""))
		return soap->error;
	if (soap_out_wstring(soap, "name", -1, &(a->ns1__lostPay::name), ""))
		return soap->error;
	if (soap_out_wstring(soap, "propNo", -1, &(a->ns1__lostPay::propNo), ""))
		return soap->error;
	if (soap_out_wstring(soap, "recoupType", -1, &(a->ns1__lostPay::recoupType), ""))
		return soap->error;
	if (soap_out_float(soap, "servFee", -1, &(a->ns1__lostPay::servFee), ""))
		return soap->error;
	if (soap_out_float(soap, "techFee", -1, &(a->ns1__lostPay::techFee), ""))
		return soap->error;
	if (soap_out_wstring(soap, "title", -1, &(a->ns1__lostPay::title), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__lostPay::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__lostPay(soap, tag, this, type);
}

SOAP_FMAC3 ns1__lostPay * SOAP_FMAC4 soap_in_ns1__lostPay(struct soap *soap, const char *tag, ns1__lostPay *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__lostPay *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__lostPay, sizeof(ns1__lostPay), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__lostPay)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__lostPay *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_barCode1 = 1;
	size_t soap_flag_billNo1 = 1;
	size_t soap_flag_bookAmt1 = 1;
	size_t soap_flag_certId1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_propNo1 = 1;
	size_t soap_flag_recoupType1 = 1;
	size_t soap_flag_servFee1 = 1;
	size_t soap_flag_techFee1 = 1;
	size_t soap_flag_title1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_barCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "barCode", &(a->ns1__lostPay::barCode), "xsd:string"))
				{	soap_flag_barCode1--;
					continue;
				}
			if (soap_flag_billNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "billNo", &(a->ns1__lostPay::billNo), "xsd:string"))
				{	soap_flag_billNo1--;
					continue;
				}
			if (soap_flag_bookAmt1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "bookAmt", &(a->ns1__lostPay::bookAmt), "xsd:float"))
				{	soap_flag_bookAmt1--;
					continue;
				}
			if (soap_flag_certId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "certId", &(a->ns1__lostPay::certId), "xsd:string"))
				{	soap_flag_certId1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "name", &(a->ns1__lostPay::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_propNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "propNo", &(a->ns1__lostPay::propNo), "xsd:string"))
				{	soap_flag_propNo1--;
					continue;
				}
			if (soap_flag_recoupType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "recoupType", &(a->ns1__lostPay::recoupType), "xsd:string"))
				{	soap_flag_recoupType1--;
					continue;
				}
			if (soap_flag_servFee1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "servFee", &(a->ns1__lostPay::servFee), "xsd:float"))
				{	soap_flag_servFee1--;
					continue;
				}
			if (soap_flag_techFee1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "techFee", &(a->ns1__lostPay::techFee), "xsd:float"))
				{	soap_flag_techFee1--;
					continue;
				}
			if (soap_flag_title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "title", &(a->ns1__lostPay::title), "xsd:string"))
				{	soap_flag_title1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__lostPay *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__lostPay, 0, sizeof(ns1__lostPay), 0, soap_copy_ns1__lostPay);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_bookAmt1 > 0 || soap_flag_servFee1 > 0 || soap_flag_techFee1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__lostPay::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__lostPay);
	if (this->soap_out(soap, tag?tag:"ns1:lostPay", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__lostPay::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__lostPay(soap, this, tag, type);
}

SOAP_FMAC3 ns1__lostPay * SOAP_FMAC4 soap_get_ns1__lostPay(struct soap *soap, ns1__lostPay *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__lostPay(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__lostPay * SOAP_FMAC2 soap_instantiate_ns1__lostPay(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__lostPay(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__lostPay, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__lostPay);
		if (size)
			*size = sizeof(ns1__lostPay);
		((ns1__lostPay*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__lostPay[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__lostPay);
		for (int i = 0; i < n; i++)
			((ns1__lostPay*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__lostPay*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__lostPay(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__lostPay %p -> %p\n", q, p));
	*(ns1__lostPay*)p = *(ns1__lostPay*)q;
}

void ns1__getLostPaysResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__lostPay(soap, &this->ns1__getLostPaysResponse::return_);
	/* transient soap skipped */
}

void ns1__getLostPaysResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__lostPay(soap, &this->ns1__getLostPaysResponse::return_);
	/* transient soap skipped */
}

int ns1__getLostPaysResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getLostPaysResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getLostPaysResponse(struct soap *soap, const char *tag, int id, const ns1__getLostPaysResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getLostPaysResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__lostPay(soap, "return", -1, &(a->ns1__getLostPaysResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getLostPaysResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getLostPaysResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getLostPaysResponse * SOAP_FMAC4 soap_in_ns1__getLostPaysResponse(struct soap *soap, const char *tag, ns1__getLostPaysResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getLostPaysResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getLostPaysResponse, sizeof(ns1__getLostPaysResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getLostPaysResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getLostPaysResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__lostPay(soap, "return", &(a->ns1__getLostPaysResponse::return_), "ns1:lostPay"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getLostPaysResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getLostPaysResponse, 0, sizeof(ns1__getLostPaysResponse), 0, soap_copy_ns1__getLostPaysResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getLostPaysResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getLostPaysResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getLostPaysResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getLostPaysResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getLostPaysResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getLostPaysResponse * SOAP_FMAC4 soap_get_ns1__getLostPaysResponse(struct soap *soap, ns1__getLostPaysResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getLostPaysResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getLostPaysResponse * SOAP_FMAC2 soap_instantiate_ns1__getLostPaysResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getLostPaysResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getLostPaysResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getLostPaysResponse);
		if (size)
			*size = sizeof(ns1__getLostPaysResponse);
		((ns1__getLostPaysResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getLostPaysResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getLostPaysResponse);
		for (int i = 0; i < n; i++)
			((ns1__getLostPaysResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getLostPaysResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getLostPaysResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getLostPaysResponse %p -> %p\n", q, p));
	*(ns1__getLostPaysResponse*)p = *(ns1__getLostPaysResponse*)q;
}

void ns1__getLostPays::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getLostPays::arg0 = NULL;
	this->ns1__getLostPays::arg1 = NULL;
	this->ns1__getLostPays::arg2 = NULL;
	this->ns1__getLostPays::arg3 = NULL;
	/* transient soap skipped */
}

void ns1__getLostPays::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getLostPays::arg0);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getLostPays::arg1);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getLostPays::arg2);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getLostPays::arg3);
	/* transient soap skipped */
}

int ns1__getLostPays::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getLostPays(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getLostPays(struct soap *soap, const char *tag, int id, const ns1__getLostPays *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getLostPays), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->ns1__getLostPays::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg1", -1, &(a->ns1__getLostPays::arg1), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg2", -1, &(a->ns1__getLostPays::arg2), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg3", -1, &(a->ns1__getLostPays::arg3), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getLostPays::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getLostPays(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getLostPays * SOAP_FMAC4 soap_in_ns1__getLostPays(struct soap *soap, const char *tag, ns1__getLostPays *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getLostPays *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getLostPays, sizeof(ns1__getLostPays), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getLostPays)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getLostPays *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_arg21 = 1;
	size_t soap_flag_arg31 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->ns1__getLostPays::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_arg11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg1", &(a->ns1__getLostPays::arg1), "xsd:string"))
				{	soap_flag_arg11--;
					continue;
				}
			if (soap_flag_arg21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg2", &(a->ns1__getLostPays::arg2), "xsd:string"))
				{	soap_flag_arg21--;
					continue;
				}
			if (soap_flag_arg31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg3", &(a->ns1__getLostPays::arg3), "xsd:string"))
				{	soap_flag_arg31--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getLostPays *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getLostPays, 0, sizeof(ns1__getLostPays), 0, soap_copy_ns1__getLostPays);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getLostPays::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getLostPays);
	if (this->soap_out(soap, tag?tag:"ns1:getLostPays", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getLostPays::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getLostPays(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getLostPays * SOAP_FMAC4 soap_get_ns1__getLostPays(struct soap *soap, ns1__getLostPays *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getLostPays(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getLostPays * SOAP_FMAC2 soap_instantiate_ns1__getLostPays(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getLostPays(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getLostPays, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getLostPays);
		if (size)
			*size = sizeof(ns1__getLostPays);
		((ns1__getLostPays*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getLostPays[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getLostPays);
		for (int i = 0; i < n; i++)
			((ns1__getLostPays*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getLostPays*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getLostPays(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getLostPays %p -> %p\n", q, p));
	*(ns1__getLostPays*)p = *(ns1__getLostPays*)q;
}

void ns1__getAccounts1Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__account(soap, &this->ns1__getAccounts1Response::return_);
	/* transient soap skipped */
}

void ns1__getAccounts1Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__account(soap, &this->ns1__getAccounts1Response::return_);
	/* transient soap skipped */
}

int ns1__getAccounts1Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getAccounts1Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getAccounts1Response(struct soap *soap, const char *tag, int id, const ns1__getAccounts1Response *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getAccounts1Response), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__account(soap, "return", -1, &(a->ns1__getAccounts1Response::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getAccounts1Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getAccounts1Response(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getAccounts1Response * SOAP_FMAC4 soap_in_ns1__getAccounts1Response(struct soap *soap, const char *tag, ns1__getAccounts1Response *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getAccounts1Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getAccounts1Response, sizeof(ns1__getAccounts1Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getAccounts1Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getAccounts1Response *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__account(soap, "return", &(a->ns1__getAccounts1Response::return_), "ns1:account"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getAccounts1Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getAccounts1Response, 0, sizeof(ns1__getAccounts1Response), 0, soap_copy_ns1__getAccounts1Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getAccounts1Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getAccounts1Response);
	if (this->soap_out(soap, tag?tag:"ns1:getAccounts1Response", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getAccounts1Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getAccounts1Response(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getAccounts1Response * SOAP_FMAC4 soap_get_ns1__getAccounts1Response(struct soap *soap, ns1__getAccounts1Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getAccounts1Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getAccounts1Response * SOAP_FMAC2 soap_instantiate_ns1__getAccounts1Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getAccounts1Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getAccounts1Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getAccounts1Response);
		if (size)
			*size = sizeof(ns1__getAccounts1Response);
		((ns1__getAccounts1Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getAccounts1Response[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getAccounts1Response);
		for (int i = 0; i < n; i++)
			((ns1__getAccounts1Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getAccounts1Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getAccounts1Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getAccounts1Response %p -> %p\n", q, p));
	*(ns1__getAccounts1Response*)p = *(ns1__getAccounts1Response*)q;
}

void ns1__getAccounts1::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getAccounts1::arg0 = NULL;
	this->ns1__getAccounts1::arg1 = NULL;
	this->ns1__getAccounts1::arg2 = NULL;
	this->ns1__getAccounts1::arg3 = NULL;
	this->ns1__getAccounts1::arg4 = NULL;
	this->ns1__getAccounts1::arg5 = NULL;
	/* transient soap skipped */
}

void ns1__getAccounts1::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getAccounts1::arg0);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getAccounts1::arg1);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getAccounts1::arg2);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getAccounts1::arg3);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getAccounts1::arg4);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getAccounts1::arg5);
	/* transient soap skipped */
}

int ns1__getAccounts1::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getAccounts1(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getAccounts1(struct soap *soap, const char *tag, int id, const ns1__getAccounts1 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getAccounts1), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->ns1__getAccounts1::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg1", -1, &(a->ns1__getAccounts1::arg1), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg2", -1, &(a->ns1__getAccounts1::arg2), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg3", -1, &(a->ns1__getAccounts1::arg3), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg4", -1, &(a->ns1__getAccounts1::arg4), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg5", -1, &(a->ns1__getAccounts1::arg5), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getAccounts1::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getAccounts1(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getAccounts1 * SOAP_FMAC4 soap_in_ns1__getAccounts1(struct soap *soap, const char *tag, ns1__getAccounts1 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getAccounts1 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getAccounts1, sizeof(ns1__getAccounts1), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getAccounts1)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getAccounts1 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_arg21 = 1;
	size_t soap_flag_arg31 = 1;
	size_t soap_flag_arg41 = 1;
	size_t soap_flag_arg51 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->ns1__getAccounts1::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_arg11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg1", &(a->ns1__getAccounts1::arg1), "xsd:string"))
				{	soap_flag_arg11--;
					continue;
				}
			if (soap_flag_arg21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg2", &(a->ns1__getAccounts1::arg2), "xsd:string"))
				{	soap_flag_arg21--;
					continue;
				}
			if (soap_flag_arg31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg3", &(a->ns1__getAccounts1::arg3), "xsd:string"))
				{	soap_flag_arg31--;
					continue;
				}
			if (soap_flag_arg41 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg4", &(a->ns1__getAccounts1::arg4), "xsd:string"))
				{	soap_flag_arg41--;
					continue;
				}
			if (soap_flag_arg51 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg5", &(a->ns1__getAccounts1::arg5), "xsd:string"))
				{	soap_flag_arg51--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getAccounts1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getAccounts1, 0, sizeof(ns1__getAccounts1), 0, soap_copy_ns1__getAccounts1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getAccounts1::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getAccounts1);
	if (this->soap_out(soap, tag?tag:"ns1:getAccounts1", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getAccounts1::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getAccounts1(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getAccounts1 * SOAP_FMAC4 soap_get_ns1__getAccounts1(struct soap *soap, ns1__getAccounts1 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getAccounts1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getAccounts1 * SOAP_FMAC2 soap_instantiate_ns1__getAccounts1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getAccounts1(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getAccounts1, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getAccounts1);
		if (size)
			*size = sizeof(ns1__getAccounts1);
		((ns1__getAccounts1*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getAccounts1[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getAccounts1);
		for (int i = 0; i < n; i++)
			((ns1__getAccounts1*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getAccounts1*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getAccounts1(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getAccounts1 %p -> %p\n", q, p));
	*(ns1__getAccounts1*)p = *(ns1__getAccounts1*)q;
}

void ns1__registerReaderResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void ns1__registerReaderResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__registerReaderResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__registerReaderResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__registerReaderResponse(struct soap *soap, const char *tag, int id, const ns1__registerReaderResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__registerReaderResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__registerReaderResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__registerReaderResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__registerReaderResponse * SOAP_FMAC4 soap_in_ns1__registerReaderResponse(struct soap *soap, const char *tag, ns1__registerReaderResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__registerReaderResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__registerReaderResponse, sizeof(ns1__registerReaderResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__registerReaderResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__registerReaderResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__registerReaderResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__registerReaderResponse, 0, sizeof(ns1__registerReaderResponse), 0, soap_copy_ns1__registerReaderResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__registerReaderResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__registerReaderResponse);
	if (this->soap_out(soap, tag?tag:"ns1:registerReaderResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__registerReaderResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__registerReaderResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__registerReaderResponse * SOAP_FMAC4 soap_get_ns1__registerReaderResponse(struct soap *soap, ns1__registerReaderResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__registerReaderResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__registerReaderResponse * SOAP_FMAC2 soap_instantiate_ns1__registerReaderResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__registerReaderResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__registerReaderResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__registerReaderResponse);
		if (size)
			*size = sizeof(ns1__registerReaderResponse);
		((ns1__registerReaderResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__registerReaderResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__registerReaderResponse);
		for (int i = 0; i < n; i++)
			((ns1__registerReaderResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__registerReaderResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__registerReaderResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__registerReaderResponse %p -> %p\n", q, p));
	*(ns1__registerReaderResponse*)p = *(ns1__registerReaderResponse*)q;
}

void ns1__registerReader::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__registerReader::arg0 = NULL;
	this->ns1__registerReader::arg1 = NULL;
	this->ns1__registerReader::arg2 = NULL;
	this->ns1__registerReader::arg3 = NULL;
	this->ns1__registerReader::arg4 = NULL;
	this->ns1__registerReader::arg5 = NULL;
	this->ns1__registerReader::arg6 = NULL;
	this->ns1__registerReader::arg7 = NULL;
	this->ns1__registerReader::arg8 = NULL;
	this->ns1__registerReader::arg9 = NULL;
	this->ns1__registerReader::arg10 = NULL;
	this->ns1__registerReader::arg11 = NULL;
	this->ns1__registerReader::arg12 = NULL;
	this->ns1__registerReader::arg13 = NULL;
	this->ns1__registerReader::arg14 = NULL;
	this->ns1__registerReader::arg15 = NULL;
	this->ns1__registerReader::arg16 = NULL;
	this->ns1__registerReader::arg17 = NULL;
	this->ns1__registerReader::arg18 = NULL;
	this->ns1__registerReader::arg19 = NULL;
	this->ns1__registerReader::arg20 = NULL;
	this->ns1__registerReader::arg21 = NULL;
	this->ns1__registerReader::arg22 = NULL;
	this->ns1__registerReader::arg23 = NULL;
	this->ns1__registerReader::arg24 = NULL;
	this->ns1__registerReader::arg25 = NULL;
	this->ns1__registerReader::arg26 = NULL;
	this->ns1__registerReader::arg27 = NULL;
	this->ns1__registerReader::arg28 = NULL;
	/* transient soap skipped */
}

void ns1__registerReader::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__registerReader::arg0);
	soap_serialize_PointerTostd__string(soap, &this->ns1__registerReader::arg1);
	soap_serialize_PointerTostd__string(soap, &this->ns1__registerReader::arg2);
	soap_serialize_PointerTostd__string(soap, &this->ns1__registerReader::arg3);
	soap_serialize_PointerTostd__string(soap, &this->ns1__registerReader::arg4);
	soap_serialize_PointerTostd__string(soap, &this->ns1__registerReader::arg5);
	soap_serialize_PointerTostd__string(soap, &this->ns1__registerReader::arg6);
	soap_serialize_PointerTostd__string(soap, &this->ns1__registerReader::arg7);
	soap_serialize_PointerTostd__string(soap, &this->ns1__registerReader::arg8);
	soap_serialize_PointerTostd__string(soap, &this->ns1__registerReader::arg9);
	soap_serialize_PointerTostd__string(soap, &this->ns1__registerReader::arg10);
	soap_serialize_PointerTostd__string(soap, &this->ns1__registerReader::arg11);
	soap_serialize_PointerTostd__string(soap, &this->ns1__registerReader::arg12);
	soap_serialize_PointerTostd__string(soap, &this->ns1__registerReader::arg13);
	soap_serialize_PointerTostd__string(soap, &this->ns1__registerReader::arg14);
	soap_serialize_PointerTostd__string(soap, &this->ns1__registerReader::arg15);
	soap_serialize_PointerTostd__string(soap, &this->ns1__registerReader::arg16);
	soap_serialize_PointerTostd__string(soap, &this->ns1__registerReader::arg17);
	soap_serialize_PointerTostd__string(soap, &this->ns1__registerReader::arg18);
	soap_serialize_PointerTostd__string(soap, &this->ns1__registerReader::arg19);
	soap_serialize_PointerTostd__string(soap, &this->ns1__registerReader::arg20);
	soap_serialize_PointerTostd__string(soap, &this->ns1__registerReader::arg21);
	soap_serialize_PointerTostd__string(soap, &this->ns1__registerReader::arg22);
	soap_serialize_PointerTostd__string(soap, &this->ns1__registerReader::arg23);
	soap_serialize_PointerTostd__string(soap, &this->ns1__registerReader::arg24);
	soap_serialize_PointerTostd__string(soap, &this->ns1__registerReader::arg25);
	soap_serialize_PointerTostd__string(soap, &this->ns1__registerReader::arg26);
	soap_serialize_PointerTostd__string(soap, &this->ns1__registerReader::arg27);
	soap_serialize_PointerTostd__string(soap, &this->ns1__registerReader::arg28);
	/* transient soap skipped */
}

int ns1__registerReader::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__registerReader(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__registerReader(struct soap *soap, const char *tag, int id, const ns1__registerReader *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__registerReader), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->ns1__registerReader::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg1", -1, &(a->ns1__registerReader::arg1), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg2", -1, &(a->ns1__registerReader::arg2), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg3", -1, &(a->ns1__registerReader::arg3), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg4", -1, &(a->ns1__registerReader::arg4), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg5", -1, &(a->ns1__registerReader::arg5), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg6", -1, &(a->ns1__registerReader::arg6), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg7", -1, &(a->ns1__registerReader::arg7), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg8", -1, &(a->ns1__registerReader::arg8), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg9", -1, &(a->ns1__registerReader::arg9), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg10", -1, &(a->ns1__registerReader::arg10), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg11", -1, &(a->ns1__registerReader::arg11), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg12", -1, &(a->ns1__registerReader::arg12), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg13", -1, &(a->ns1__registerReader::arg13), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg14", -1, &(a->ns1__registerReader::arg14), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg15", -1, &(a->ns1__registerReader::arg15), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg16", -1, &(a->ns1__registerReader::arg16), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg17", -1, &(a->ns1__registerReader::arg17), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg18", -1, &(a->ns1__registerReader::arg18), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg19", -1, &(a->ns1__registerReader::arg19), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg20", -1, &(a->ns1__registerReader::arg20), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg21", -1, &(a->ns1__registerReader::arg21), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg22", -1, &(a->ns1__registerReader::arg22), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg23", -1, &(a->ns1__registerReader::arg23), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg24", -1, &(a->ns1__registerReader::arg24), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg25", -1, &(a->ns1__registerReader::arg25), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg26", -1, &(a->ns1__registerReader::arg26), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg27", -1, &(a->ns1__registerReader::arg27), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg28", -1, &(a->ns1__registerReader::arg28), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__registerReader::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__registerReader(soap, tag, this, type);
}

SOAP_FMAC3 ns1__registerReader * SOAP_FMAC4 soap_in_ns1__registerReader(struct soap *soap, const char *tag, ns1__registerReader *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__registerReader *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__registerReader, sizeof(ns1__registerReader), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__registerReader)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__registerReader *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_arg21 = 1;
	size_t soap_flag_arg31 = 1;
	size_t soap_flag_arg41 = 1;
	size_t soap_flag_arg51 = 1;
	size_t soap_flag_arg61 = 1;
	size_t soap_flag_arg71 = 1;
	size_t soap_flag_arg81 = 1;
	size_t soap_flag_arg91 = 1;
	size_t soap_flag_arg101 = 1;
	size_t soap_flag_arg111 = 1;
	size_t soap_flag_arg121 = 1;
	size_t soap_flag_arg131 = 1;
	size_t soap_flag_arg141 = 1;
	size_t soap_flag_arg151 = 1;
	size_t soap_flag_arg161 = 1;
	size_t soap_flag_arg171 = 1;
	size_t soap_flag_arg181 = 1;
	size_t soap_flag_arg191 = 1;
	size_t soap_flag_arg201 = 1;
	size_t soap_flag_arg211 = 1;
	size_t soap_flag_arg221 = 1;
	size_t soap_flag_arg231 = 1;
	size_t soap_flag_arg241 = 1;
	size_t soap_flag_arg251 = 1;
	size_t soap_flag_arg261 = 1;
	size_t soap_flag_arg271 = 1;
	size_t soap_flag_arg281 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->ns1__registerReader::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_arg11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg1", &(a->ns1__registerReader::arg1), "xsd:string"))
				{	soap_flag_arg11--;
					continue;
				}
			if (soap_flag_arg21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg2", &(a->ns1__registerReader::arg2), "xsd:string"))
				{	soap_flag_arg21--;
					continue;
				}
			if (soap_flag_arg31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg3", &(a->ns1__registerReader::arg3), "xsd:string"))
				{	soap_flag_arg31--;
					continue;
				}
			if (soap_flag_arg41 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg4", &(a->ns1__registerReader::arg4), "xsd:string"))
				{	soap_flag_arg41--;
					continue;
				}
			if (soap_flag_arg51 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg5", &(a->ns1__registerReader::arg5), "xsd:string"))
				{	soap_flag_arg51--;
					continue;
				}
			if (soap_flag_arg61 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg6", &(a->ns1__registerReader::arg6), "xsd:string"))
				{	soap_flag_arg61--;
					continue;
				}
			if (soap_flag_arg71 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg7", &(a->ns1__registerReader::arg7), "xsd:string"))
				{	soap_flag_arg71--;
					continue;
				}
			if (soap_flag_arg81 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg8", &(a->ns1__registerReader::arg8), "xsd:string"))
				{	soap_flag_arg81--;
					continue;
				}
			if (soap_flag_arg91 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg9", &(a->ns1__registerReader::arg9), "xsd:string"))
				{	soap_flag_arg91--;
					continue;
				}
			if (soap_flag_arg101 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg10", &(a->ns1__registerReader::arg10), "xsd:string"))
				{	soap_flag_arg101--;
					continue;
				}
			if (soap_flag_arg111 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg11", &(a->ns1__registerReader::arg11), "xsd:string"))
				{	soap_flag_arg111--;
					continue;
				}
			if (soap_flag_arg121 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg12", &(a->ns1__registerReader::arg12), "xsd:string"))
				{	soap_flag_arg121--;
					continue;
				}
			if (soap_flag_arg131 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg13", &(a->ns1__registerReader::arg13), "xsd:string"))
				{	soap_flag_arg131--;
					continue;
				}
			if (soap_flag_arg141 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg14", &(a->ns1__registerReader::arg14), "xsd:string"))
				{	soap_flag_arg141--;
					continue;
				}
			if (soap_flag_arg151 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg15", &(a->ns1__registerReader::arg15), "xsd:string"))
				{	soap_flag_arg151--;
					continue;
				}
			if (soap_flag_arg161 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg16", &(a->ns1__registerReader::arg16), "xsd:string"))
				{	soap_flag_arg161--;
					continue;
				}
			if (soap_flag_arg171 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg17", &(a->ns1__registerReader::arg17), "xsd:string"))
				{	soap_flag_arg171--;
					continue;
				}
			if (soap_flag_arg181 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg18", &(a->ns1__registerReader::arg18), "xsd:string"))
				{	soap_flag_arg181--;
					continue;
				}
			if (soap_flag_arg191 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg19", &(a->ns1__registerReader::arg19), "xsd:string"))
				{	soap_flag_arg191--;
					continue;
				}
			if (soap_flag_arg201 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg20", &(a->ns1__registerReader::arg20), "xsd:string"))
				{	soap_flag_arg201--;
					continue;
				}
			if (soap_flag_arg211 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg21", &(a->ns1__registerReader::arg21), "xsd:string"))
				{	soap_flag_arg211--;
					continue;
				}
			if (soap_flag_arg221 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg22", &(a->ns1__registerReader::arg22), "xsd:string"))
				{	soap_flag_arg221--;
					continue;
				}
			if (soap_flag_arg231 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg23", &(a->ns1__registerReader::arg23), "xsd:string"))
				{	soap_flag_arg231--;
					continue;
				}
			if (soap_flag_arg241 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg24", &(a->ns1__registerReader::arg24), "xsd:string"))
				{	soap_flag_arg241--;
					continue;
				}
			if (soap_flag_arg251 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg25", &(a->ns1__registerReader::arg25), "xsd:string"))
				{	soap_flag_arg251--;
					continue;
				}
			if (soap_flag_arg261 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg26", &(a->ns1__registerReader::arg26), "xsd:string"))
				{	soap_flag_arg261--;
					continue;
				}
			if (soap_flag_arg271 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg27", &(a->ns1__registerReader::arg27), "xsd:string"))
				{	soap_flag_arg271--;
					continue;
				}
			if (soap_flag_arg281 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg28", &(a->ns1__registerReader::arg28), "xsd:string"))
				{	soap_flag_arg281--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__registerReader *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__registerReader, 0, sizeof(ns1__registerReader), 0, soap_copy_ns1__registerReader);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__registerReader::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__registerReader);
	if (this->soap_out(soap, tag?tag:"ns1:registerReader", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__registerReader::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__registerReader(soap, this, tag, type);
}

SOAP_FMAC3 ns1__registerReader * SOAP_FMAC4 soap_get_ns1__registerReader(struct soap *soap, ns1__registerReader *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__registerReader(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__registerReader * SOAP_FMAC2 soap_instantiate_ns1__registerReader(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__registerReader(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__registerReader, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__registerReader);
		if (size)
			*size = sizeof(ns1__registerReader);
		((ns1__registerReader*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__registerReader[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__registerReader);
		for (int i = 0; i < n; i++)
			((ns1__registerReader*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__registerReader*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__registerReader(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__registerReader %p -> %p\n", q, p));
	*(ns1__registerReader*)p = *(ns1__registerReader*)q;
}

void ns1__preg::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__preg::pregDate = NULL;
	this->ns1__preg::pregEndDate = NULL;
	this->ns1__pregOrRelegate::callNo = NULL;
	this->ns1__pregOrRelegate::certId = NULL;
	this->ns1__pregOrRelegate::dealFlag = NULL;
	this->ns1__pregOrRelegate::dealFlagName = NULL;
	this->ns1__pregOrRelegate::location = NULL;
	this->ns1__pregOrRelegate::name = NULL;
	this->ns1__pregOrRelegate::title = NULL;
	/* transient soap skipped */
}

void ns1__preg::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_wstring(soap, &this->ns1__preg::pregDate);
	soap_serialize_wstring(soap, &this->ns1__preg::pregEndDate);
	soap_serialize_wstring(soap, &this->ns1__pregOrRelegate::callNo);
	soap_serialize_wstring(soap, &this->ns1__pregOrRelegate::certId);
	soap_serialize_wstring(soap, &this->ns1__pregOrRelegate::dealFlag);
	soap_serialize_wstring(soap, &this->ns1__pregOrRelegate::dealFlagName);
	soap_serialize_wstring(soap, &this->ns1__pregOrRelegate::location);
	soap_serialize_wstring(soap, &this->ns1__pregOrRelegate::name);
	soap_serialize_wstring(soap, &this->ns1__pregOrRelegate::title);
	/* transient soap skipped */
}

int ns1__preg::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__preg(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__preg(struct soap *soap, const char *tag, int id, const ns1__preg *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__preg), "ns1:preg"))
		return soap->error;
	if (soap_out_wstring(soap, "callNo", -1, &(a->ns1__pregOrRelegate::callNo), ""))
		return soap->error;
	if (soap_out_wstring(soap, "certId", -1, &(a->ns1__pregOrRelegate::certId), ""))
		return soap->error;
	if (soap_out_wstring(soap, "dealFlag", -1, &(a->ns1__pregOrRelegate::dealFlag), ""))
		return soap->error;
	if (soap_out_wstring(soap, "dealFlagName", -1, &(a->ns1__pregOrRelegate::dealFlagName), ""))
		return soap->error;
	if (soap_out_wstring(soap, "location", -1, &(a->ns1__pregOrRelegate::location), ""))
		return soap->error;
	if (soap_out_wstring(soap, "name", -1, &(a->ns1__pregOrRelegate::name), ""))
		return soap->error;
	if (soap_out_wstring(soap, "title", -1, &(a->ns1__pregOrRelegate::title), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_wstring(soap, "pregDate", -1, &(a->ns1__preg::pregDate), ""))
		return soap->error;
	if (soap_out_wstring(soap, "pregEndDate", -1, &(a->ns1__preg::pregEndDate), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__preg::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__preg(soap, tag, this, type);
}

SOAP_FMAC3 ns1__preg * SOAP_FMAC4 soap_in_ns1__preg(struct soap *soap, const char *tag, ns1__preg *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__preg *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__preg, sizeof(ns1__preg), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__preg)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__preg *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_callNo2 = 1;
	size_t soap_flag_certId2 = 1;
	size_t soap_flag_dealFlag2 = 1;
	size_t soap_flag_dealFlagName2 = 1;
	size_t soap_flag_location2 = 1;
	size_t soap_flag_name2 = 1;
	size_t soap_flag_title2 = 1;
	size_t soap_flag_pregDate1 = 1;
	size_t soap_flag_pregEndDate1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_callNo2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "callNo", &(a->ns1__pregOrRelegate::callNo), "xsd:string"))
				{	soap_flag_callNo2--;
					continue;
				}
			if (soap_flag_certId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "certId", &(a->ns1__pregOrRelegate::certId), "xsd:string"))
				{	soap_flag_certId2--;
					continue;
				}
			if (soap_flag_dealFlag2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "dealFlag", &(a->ns1__pregOrRelegate::dealFlag), "xsd:string"))
				{	soap_flag_dealFlag2--;
					continue;
				}
			if (soap_flag_dealFlagName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "dealFlagName", &(a->ns1__pregOrRelegate::dealFlagName), "xsd:string"))
				{	soap_flag_dealFlagName2--;
					continue;
				}
			if (soap_flag_location2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "location", &(a->ns1__pregOrRelegate::location), "xsd:string"))
				{	soap_flag_location2--;
					continue;
				}
			if (soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "name", &(a->ns1__pregOrRelegate::name), "xsd:string"))
				{	soap_flag_name2--;
					continue;
				}
			if (soap_flag_title2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "title", &(a->ns1__pregOrRelegate::title), "xsd:string"))
				{	soap_flag_title2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_pregDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "pregDate", &(a->ns1__preg::pregDate), "xsd:string"))
				{	soap_flag_pregDate1--;
					continue;
				}
			if (soap_flag_pregEndDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "pregEndDate", &(a->ns1__preg::pregEndDate), "xsd:string"))
				{	soap_flag_pregEndDate1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__preg *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__preg, 0, sizeof(ns1__preg), 0, soap_copy_ns1__preg);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__preg::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__preg);
	if (this->soap_out(soap, tag?tag:"ns1:preg", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__preg::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__preg(soap, this, tag, type);
}

SOAP_FMAC3 ns1__preg * SOAP_FMAC4 soap_get_ns1__preg(struct soap *soap, ns1__preg *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__preg(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__preg * SOAP_FMAC2 soap_instantiate_ns1__preg(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__preg(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__preg, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__preg);
		if (size)
			*size = sizeof(ns1__preg);
		((ns1__preg*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__preg[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__preg);
		for (int i = 0; i < n; i++)
			((ns1__preg*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__preg*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__preg(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__preg %p -> %p\n", q, p));
	*(ns1__preg*)p = *(ns1__preg*)q;
}

void ns1__getPregsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__preg(soap, &this->ns1__getPregsResponse::return_);
	/* transient soap skipped */
}

void ns1__getPregsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__preg(soap, &this->ns1__getPregsResponse::return_);
	/* transient soap skipped */
}

int ns1__getPregsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getPregsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getPregsResponse(struct soap *soap, const char *tag, int id, const ns1__getPregsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getPregsResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__preg(soap, "return", -1, &(a->ns1__getPregsResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getPregsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getPregsResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getPregsResponse * SOAP_FMAC4 soap_in_ns1__getPregsResponse(struct soap *soap, const char *tag, ns1__getPregsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getPregsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getPregsResponse, sizeof(ns1__getPregsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getPregsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getPregsResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__preg(soap, "return", &(a->ns1__getPregsResponse::return_), "ns1:preg"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getPregsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getPregsResponse, 0, sizeof(ns1__getPregsResponse), 0, soap_copy_ns1__getPregsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getPregsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getPregsResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getPregsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getPregsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getPregsResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getPregsResponse * SOAP_FMAC4 soap_get_ns1__getPregsResponse(struct soap *soap, ns1__getPregsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getPregsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getPregsResponse * SOAP_FMAC2 soap_instantiate_ns1__getPregsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getPregsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getPregsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getPregsResponse);
		if (size)
			*size = sizeof(ns1__getPregsResponse);
		((ns1__getPregsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getPregsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getPregsResponse);
		for (int i = 0; i < n; i++)
			((ns1__getPregsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getPregsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getPregsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getPregsResponse %p -> %p\n", q, p));
	*(ns1__getPregsResponse*)p = *(ns1__getPregsResponse*)q;
}

void ns1__getPregs::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getPregs::arg0 = NULL;
	this->ns1__getPregs::arg1 = NULL;
	this->ns1__getPregs::arg2 = NULL;
	this->ns1__getPregs::arg3 = NULL;
	/* transient soap skipped */
}

void ns1__getPregs::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getPregs::arg0);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getPregs::arg1);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getPregs::arg2);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getPregs::arg3);
	/* transient soap skipped */
}

int ns1__getPregs::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getPregs(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getPregs(struct soap *soap, const char *tag, int id, const ns1__getPregs *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getPregs), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->ns1__getPregs::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg1", -1, &(a->ns1__getPregs::arg1), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg2", -1, &(a->ns1__getPregs::arg2), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg3", -1, &(a->ns1__getPregs::arg3), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getPregs::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getPregs(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getPregs * SOAP_FMAC4 soap_in_ns1__getPregs(struct soap *soap, const char *tag, ns1__getPregs *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getPregs *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getPregs, sizeof(ns1__getPregs), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getPregs)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getPregs *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_arg21 = 1;
	size_t soap_flag_arg31 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->ns1__getPregs::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_arg11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg1", &(a->ns1__getPregs::arg1), "xsd:string"))
				{	soap_flag_arg11--;
					continue;
				}
			if (soap_flag_arg21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg2", &(a->ns1__getPregs::arg2), "xsd:string"))
				{	soap_flag_arg21--;
					continue;
				}
			if (soap_flag_arg31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg3", &(a->ns1__getPregs::arg3), "xsd:string"))
				{	soap_flag_arg31--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getPregs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getPregs, 0, sizeof(ns1__getPregs), 0, soap_copy_ns1__getPregs);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getPregs::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getPregs);
	if (this->soap_out(soap, tag?tag:"ns1:getPregs", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getPregs::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getPregs(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getPregs * SOAP_FMAC4 soap_get_ns1__getPregs(struct soap *soap, ns1__getPregs *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getPregs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getPregs * SOAP_FMAC2 soap_instantiate_ns1__getPregs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getPregs(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getPregs, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getPregs);
		if (size)
			*size = sizeof(ns1__getPregs);
		((ns1__getPregs*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getPregs[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getPregs);
		for (int i = 0; i < n; i++)
			((ns1__getPregs*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getPregs*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getPregs(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getPregs %p -> %p\n", q, p));
	*(ns1__getPregs*)p = *(ns1__getPregs*)q;
}

void ns1__account::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_float(soap, &this->ns1__account::amount);
	this->ns1__account::billNo = NULL;
	this->ns1__account::certId = NULL;
	this->ns1__account::name = NULL;
	this->ns1__account::paymentFlag = NULL;
	this->ns1__account::paymentFlagName = NULL;
	this->ns1__account::paymentItem = NULL;
	this->ns1__account::paymentItemName = NULL;
	this->ns1__account::paymentTime = NULL;
	this->ns1__account::paymentType = NULL;
	this->ns1__account::paymentTypeName = NULL;
	/* transient soap skipped */
}

void ns1__account::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_wstring(soap, &this->ns1__account::billNo);
	soap_serialize_wstring(soap, &this->ns1__account::certId);
	soap_serialize_wstring(soap, &this->ns1__account::name);
	soap_serialize_wstring(soap, &this->ns1__account::paymentFlag);
	soap_serialize_wstring(soap, &this->ns1__account::paymentFlagName);
	soap_serialize_wstring(soap, &this->ns1__account::paymentItem);
	soap_serialize_wstring(soap, &this->ns1__account::paymentItemName);
	soap_serialize_wstring(soap, &this->ns1__account::paymentTime);
	soap_serialize_wstring(soap, &this->ns1__account::paymentType);
	soap_serialize_wstring(soap, &this->ns1__account::paymentTypeName);
	/* transient soap skipped */
}

int ns1__account::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__account(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__account(struct soap *soap, const char *tag, int id, const ns1__account *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__account), type))
		return soap->error;
	if (soap_out_float(soap, "amount", -1, &(a->ns1__account::amount), ""))
		return soap->error;
	if (soap_out_wstring(soap, "billNo", -1, &(a->ns1__account::billNo), ""))
		return soap->error;
	if (soap_out_wstring(soap, "certId", -1, &(a->ns1__account::certId), ""))
		return soap->error;
	if (soap_out_wstring(soap, "name", -1, &(a->ns1__account::name), ""))
		return soap->error;
	if (soap_out_wstring(soap, "paymentFlag", -1, &(a->ns1__account::paymentFlag), ""))
		return soap->error;
	if (soap_out_wstring(soap, "paymentFlagName", -1, &(a->ns1__account::paymentFlagName), ""))
		return soap->error;
	if (soap_out_wstring(soap, "paymentItem", -1, &(a->ns1__account::paymentItem), ""))
		return soap->error;
	if (soap_out_wstring(soap, "paymentItemName", -1, &(a->ns1__account::paymentItemName), ""))
		return soap->error;
	if (soap_out_wstring(soap, "paymentTime", -1, &(a->ns1__account::paymentTime), ""))
		return soap->error;
	if (soap_out_wstring(soap, "paymentType", -1, &(a->ns1__account::paymentType), ""))
		return soap->error;
	if (soap_out_wstring(soap, "paymentTypeName", -1, &(a->ns1__account::paymentTypeName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__account::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__account(soap, tag, this, type);
}

SOAP_FMAC3 ns1__account * SOAP_FMAC4 soap_in_ns1__account(struct soap *soap, const char *tag, ns1__account *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__account *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__account, sizeof(ns1__account), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__account)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__account *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_billNo1 = 1;
	size_t soap_flag_certId1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_paymentFlag1 = 1;
	size_t soap_flag_paymentFlagName1 = 1;
	size_t soap_flag_paymentItem1 = 1;
	size_t soap_flag_paymentItemName1 = 1;
	size_t soap_flag_paymentTime1 = 1;
	size_t soap_flag_paymentType1 = 1;
	size_t soap_flag_paymentTypeName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_amount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "amount", &(a->ns1__account::amount), "xsd:float"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_billNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "billNo", &(a->ns1__account::billNo), "xsd:string"))
				{	soap_flag_billNo1--;
					continue;
				}
			if (soap_flag_certId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "certId", &(a->ns1__account::certId), "xsd:string"))
				{	soap_flag_certId1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "name", &(a->ns1__account::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_paymentFlag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "paymentFlag", &(a->ns1__account::paymentFlag), "xsd:string"))
				{	soap_flag_paymentFlag1--;
					continue;
				}
			if (soap_flag_paymentFlagName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "paymentFlagName", &(a->ns1__account::paymentFlagName), "xsd:string"))
				{	soap_flag_paymentFlagName1--;
					continue;
				}
			if (soap_flag_paymentItem1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "paymentItem", &(a->ns1__account::paymentItem), "xsd:string"))
				{	soap_flag_paymentItem1--;
					continue;
				}
			if (soap_flag_paymentItemName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "paymentItemName", &(a->ns1__account::paymentItemName), "xsd:string"))
				{	soap_flag_paymentItemName1--;
					continue;
				}
			if (soap_flag_paymentTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "paymentTime", &(a->ns1__account::paymentTime), "xsd:string"))
				{	soap_flag_paymentTime1--;
					continue;
				}
			if (soap_flag_paymentType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "paymentType", &(a->ns1__account::paymentType), "xsd:string"))
				{	soap_flag_paymentType1--;
					continue;
				}
			if (soap_flag_paymentTypeName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "paymentTypeName", &(a->ns1__account::paymentTypeName), "xsd:string"))
				{	soap_flag_paymentTypeName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__account *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__account, 0, sizeof(ns1__account), 0, soap_copy_ns1__account);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_amount1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__account::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__account);
	if (this->soap_out(soap, tag?tag:"ns1:account", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__account::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__account(soap, this, tag, type);
}

SOAP_FMAC3 ns1__account * SOAP_FMAC4 soap_get_ns1__account(struct soap *soap, ns1__account *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__account(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__account * SOAP_FMAC2 soap_instantiate_ns1__account(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__account(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__account, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__account);
		if (size)
			*size = sizeof(ns1__account);
		((ns1__account*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__account[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__account);
		for (int i = 0; i < n; i++)
			((ns1__account*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__account*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__account(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__account %p -> %p\n", q, p));
	*(ns1__account*)p = *(ns1__account*)q;
}

void ns1__getAccountsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__account(soap, &this->ns1__getAccountsResponse::return_);
	/* transient soap skipped */
}

void ns1__getAccountsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__account(soap, &this->ns1__getAccountsResponse::return_);
	/* transient soap skipped */
}

int ns1__getAccountsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getAccountsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getAccountsResponse(struct soap *soap, const char *tag, int id, const ns1__getAccountsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getAccountsResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__account(soap, "return", -1, &(a->ns1__getAccountsResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getAccountsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getAccountsResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getAccountsResponse * SOAP_FMAC4 soap_in_ns1__getAccountsResponse(struct soap *soap, const char *tag, ns1__getAccountsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getAccountsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getAccountsResponse, sizeof(ns1__getAccountsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getAccountsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getAccountsResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__account(soap, "return", &(a->ns1__getAccountsResponse::return_), "ns1:account"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getAccountsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getAccountsResponse, 0, sizeof(ns1__getAccountsResponse), 0, soap_copy_ns1__getAccountsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getAccountsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getAccountsResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getAccountsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getAccountsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getAccountsResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getAccountsResponse * SOAP_FMAC4 soap_get_ns1__getAccountsResponse(struct soap *soap, ns1__getAccountsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getAccountsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getAccountsResponse * SOAP_FMAC2 soap_instantiate_ns1__getAccountsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getAccountsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getAccountsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getAccountsResponse);
		if (size)
			*size = sizeof(ns1__getAccountsResponse);
		((ns1__getAccountsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getAccountsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getAccountsResponse);
		for (int i = 0; i < n; i++)
			((ns1__getAccountsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getAccountsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getAccountsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getAccountsResponse %p -> %p\n", q, p));
	*(ns1__getAccountsResponse*)p = *(ns1__getAccountsResponse*)q;
}

void ns1__getAccounts::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getAccounts::arg0 = NULL;
	this->ns1__getAccounts::arg1 = NULL;
	this->ns1__getAccounts::arg2 = NULL;
	this->ns1__getAccounts::arg3 = NULL;
	/* transient soap skipped */
}

void ns1__getAccounts::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getAccounts::arg0);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getAccounts::arg1);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getAccounts::arg2);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getAccounts::arg3);
	/* transient soap skipped */
}

int ns1__getAccounts::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getAccounts(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getAccounts(struct soap *soap, const char *tag, int id, const ns1__getAccounts *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getAccounts), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->ns1__getAccounts::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg1", -1, &(a->ns1__getAccounts::arg1), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg2", -1, &(a->ns1__getAccounts::arg2), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg3", -1, &(a->ns1__getAccounts::arg3), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getAccounts::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getAccounts(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getAccounts * SOAP_FMAC4 soap_in_ns1__getAccounts(struct soap *soap, const char *tag, ns1__getAccounts *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getAccounts *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getAccounts, sizeof(ns1__getAccounts), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getAccounts)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getAccounts *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_arg21 = 1;
	size_t soap_flag_arg31 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->ns1__getAccounts::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_arg11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg1", &(a->ns1__getAccounts::arg1), "xsd:string"))
				{	soap_flag_arg11--;
					continue;
				}
			if (soap_flag_arg21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg2", &(a->ns1__getAccounts::arg2), "xsd:string"))
				{	soap_flag_arg21--;
					continue;
				}
			if (soap_flag_arg31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg3", &(a->ns1__getAccounts::arg3), "xsd:string"))
				{	soap_flag_arg31--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getAccounts *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getAccounts, 0, sizeof(ns1__getAccounts), 0, soap_copy_ns1__getAccounts);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getAccounts::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getAccounts);
	if (this->soap_out(soap, tag?tag:"ns1:getAccounts", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getAccounts::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getAccounts(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getAccounts * SOAP_FMAC4 soap_get_ns1__getAccounts(struct soap *soap, ns1__getAccounts *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getAccounts(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getAccounts * SOAP_FMAC2 soap_instantiate_ns1__getAccounts(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getAccounts(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getAccounts, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getAccounts);
		if (size)
			*size = sizeof(ns1__getAccounts);
		((ns1__getAccounts*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getAccounts[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getAccounts);
		for (int i = 0; i < n; i++)
			((ns1__getAccounts*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getAccounts*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getAccounts(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getAccounts %p -> %p\n", q, p));
	*(ns1__getAccounts*)p = *(ns1__getAccounts*)q;
}

void ns1__marc::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__marc::author = NULL;
	this->ns1__marc::callNo = NULL;
	this->ns1__marc::isbn = NULL;
	this->ns1__marc::marcRecNo = NULL;
	this->ns1__marc::pubYear = NULL;
	this->ns1__marc::publisher = NULL;
	this->ns1__marc::title = NULL;
	/* transient soap skipped */
}

void ns1__marc::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_wstring(soap, &this->ns1__marc::author);
	soap_serialize_wstring(soap, &this->ns1__marc::callNo);
	soap_serialize_wstring(soap, &this->ns1__marc::isbn);
	soap_serialize_wstring(soap, &this->ns1__marc::marcRecNo);
	soap_serialize_wstring(soap, &this->ns1__marc::pubYear);
	soap_serialize_wstring(soap, &this->ns1__marc::publisher);
	soap_serialize_wstring(soap, &this->ns1__marc::title);
	/* transient soap skipped */
}

int ns1__marc::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__marc(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__marc(struct soap *soap, const char *tag, int id, const ns1__marc *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__marc), type))
		return soap->error;
	if (soap_out_wstring(soap, "author", -1, &(a->ns1__marc::author), ""))
		return soap->error;
	if (soap_out_wstring(soap, "callNo", -1, &(a->ns1__marc::callNo), ""))
		return soap->error;
	if (soap_out_wstring(soap, "isbn", -1, &(a->ns1__marc::isbn), ""))
		return soap->error;
	if (soap_out_wstring(soap, "marcRecNo", -1, &(a->ns1__marc::marcRecNo), ""))
		return soap->error;
	if (soap_out_wstring(soap, "pubYear", -1, &(a->ns1__marc::pubYear), ""))
		return soap->error;
	if (soap_out_wstring(soap, "publisher", -1, &(a->ns1__marc::publisher), ""))
		return soap->error;
	if (soap_out_wstring(soap, "title", -1, &(a->ns1__marc::title), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__marc::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__marc(soap, tag, this, type);
}

SOAP_FMAC3 ns1__marc * SOAP_FMAC4 soap_in_ns1__marc(struct soap *soap, const char *tag, ns1__marc *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__marc *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__marc, sizeof(ns1__marc), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__marc)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__marc *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_author1 = 1;
	size_t soap_flag_callNo1 = 1;
	size_t soap_flag_isbn1 = 1;
	size_t soap_flag_marcRecNo1 = 1;
	size_t soap_flag_pubYear1 = 1;
	size_t soap_flag_publisher1 = 1;
	size_t soap_flag_title1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_author1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "author", &(a->ns1__marc::author), "xsd:string"))
				{	soap_flag_author1--;
					continue;
				}
			if (soap_flag_callNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "callNo", &(a->ns1__marc::callNo), "xsd:string"))
				{	soap_flag_callNo1--;
					continue;
				}
			if (soap_flag_isbn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "isbn", &(a->ns1__marc::isbn), "xsd:string"))
				{	soap_flag_isbn1--;
					continue;
				}
			if (soap_flag_marcRecNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "marcRecNo", &(a->ns1__marc::marcRecNo), "xsd:string"))
				{	soap_flag_marcRecNo1--;
					continue;
				}
			if (soap_flag_pubYear1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "pubYear", &(a->ns1__marc::pubYear), "xsd:string"))
				{	soap_flag_pubYear1--;
					continue;
				}
			if (soap_flag_publisher1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "publisher", &(a->ns1__marc::publisher), "xsd:string"))
				{	soap_flag_publisher1--;
					continue;
				}
			if (soap_flag_title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "title", &(a->ns1__marc::title), "xsd:string"))
				{	soap_flag_title1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__marc *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__marc, 0, sizeof(ns1__marc), 0, soap_copy_ns1__marc);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__marc::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__marc);
	if (this->soap_out(soap, tag?tag:"ns1:marc", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__marc::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__marc(soap, this, tag, type);
}

SOAP_FMAC3 ns1__marc * SOAP_FMAC4 soap_get_ns1__marc(struct soap *soap, ns1__marc *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__marc(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__marc * SOAP_FMAC2 soap_instantiate_ns1__marc(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__marc(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__marc, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__marc);
		if (size)
			*size = sizeof(ns1__marc);
		((ns1__marc*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__marc[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__marc);
		for (int i = 0; i < n; i++)
			((ns1__marc*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__marc*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__marc(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__marc %p -> %p\n", q, p));
	*(ns1__marc*)p = *(ns1__marc*)q;
}

void ns1__getMarcResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getMarcResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__getMarcResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__marc(soap, &this->ns1__getMarcResponse::return_);
	/* transient soap skipped */
}

int ns1__getMarcResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getMarcResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getMarcResponse(struct soap *soap, const char *tag, int id, const ns1__getMarcResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getMarcResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__marc(soap, "return", -1, &(a->ns1__getMarcResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getMarcResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getMarcResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getMarcResponse * SOAP_FMAC4 soap_in_ns1__getMarcResponse(struct soap *soap, const char *tag, ns1__getMarcResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getMarcResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getMarcResponse, sizeof(ns1__getMarcResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getMarcResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getMarcResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__marc(soap, "return", &(a->ns1__getMarcResponse::return_), "ns1:marc"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getMarcResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getMarcResponse, 0, sizeof(ns1__getMarcResponse), 0, soap_copy_ns1__getMarcResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getMarcResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getMarcResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getMarcResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getMarcResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getMarcResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getMarcResponse * SOAP_FMAC4 soap_get_ns1__getMarcResponse(struct soap *soap, ns1__getMarcResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getMarcResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getMarcResponse * SOAP_FMAC2 soap_instantiate_ns1__getMarcResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getMarcResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getMarcResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getMarcResponse);
		if (size)
			*size = sizeof(ns1__getMarcResponse);
		((ns1__getMarcResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getMarcResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getMarcResponse);
		for (int i = 0; i < n; i++)
			((ns1__getMarcResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getMarcResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getMarcResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getMarcResponse %p -> %p\n", q, p));
	*(ns1__getMarcResponse*)p = *(ns1__getMarcResponse*)q;
}

void ns1__getMarc::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getMarc::arg0 = NULL;
	this->ns1__getMarc::arg1 = NULL;
	this->ns1__getMarc::arg2 = NULL;
	this->ns1__getMarc::arg3 = NULL;
	/* transient soap skipped */
}

void ns1__getMarc::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getMarc::arg0);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getMarc::arg1);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getMarc::arg2);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getMarc::arg3);
	/* transient soap skipped */
}

int ns1__getMarc::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getMarc(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getMarc(struct soap *soap, const char *tag, int id, const ns1__getMarc *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getMarc), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->ns1__getMarc::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg1", -1, &(a->ns1__getMarc::arg1), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg2", -1, &(a->ns1__getMarc::arg2), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg3", -1, &(a->ns1__getMarc::arg3), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getMarc::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getMarc(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getMarc * SOAP_FMAC4 soap_in_ns1__getMarc(struct soap *soap, const char *tag, ns1__getMarc *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getMarc *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getMarc, sizeof(ns1__getMarc), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getMarc)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getMarc *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_arg21 = 1;
	size_t soap_flag_arg31 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->ns1__getMarc::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_arg11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg1", &(a->ns1__getMarc::arg1), "xsd:string"))
				{	soap_flag_arg11--;
					continue;
				}
			if (soap_flag_arg21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg2", &(a->ns1__getMarc::arg2), "xsd:string"))
				{	soap_flag_arg21--;
					continue;
				}
			if (soap_flag_arg31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg3", &(a->ns1__getMarc::arg3), "xsd:string"))
				{	soap_flag_arg31--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getMarc *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getMarc, 0, sizeof(ns1__getMarc), 0, soap_copy_ns1__getMarc);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getMarc::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getMarc);
	if (this->soap_out(soap, tag?tag:"ns1:getMarc", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getMarc::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getMarc(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getMarc * SOAP_FMAC4 soap_get_ns1__getMarc(struct soap *soap, ns1__getMarc *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getMarc(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getMarc * SOAP_FMAC2 soap_instantiate_ns1__getMarc(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getMarc(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getMarc, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getMarc);
		if (size)
			*size = sizeof(ns1__getMarc);
		((ns1__getMarc*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getMarc[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getMarc);
		for (int i = 0; i < n; i++)
			((ns1__getMarc*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getMarc*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getMarc(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getMarc %p -> %p\n", q, p));
	*(ns1__getMarc*)p = *(ns1__getMarc*)q;
}

void ns1__getLendHistResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__circ(soap, &this->ns1__getLendHistResponse::return_);
	/* transient soap skipped */
}

void ns1__getLendHistResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__circ(soap, &this->ns1__getLendHistResponse::return_);
	/* transient soap skipped */
}

int ns1__getLendHistResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getLendHistResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getLendHistResponse(struct soap *soap, const char *tag, int id, const ns1__getLendHistResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getLendHistResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__circ(soap, "return", -1, &(a->ns1__getLendHistResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getLendHistResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getLendHistResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getLendHistResponse * SOAP_FMAC4 soap_in_ns1__getLendHistResponse(struct soap *soap, const char *tag, ns1__getLendHistResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getLendHistResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getLendHistResponse, sizeof(ns1__getLendHistResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getLendHistResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getLendHistResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__circ(soap, "return", &(a->ns1__getLendHistResponse::return_), "ns1:circ"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getLendHistResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getLendHistResponse, 0, sizeof(ns1__getLendHistResponse), 0, soap_copy_ns1__getLendHistResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getLendHistResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getLendHistResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getLendHistResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getLendHistResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getLendHistResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getLendHistResponse * SOAP_FMAC4 soap_get_ns1__getLendHistResponse(struct soap *soap, ns1__getLendHistResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getLendHistResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getLendHistResponse * SOAP_FMAC2 soap_instantiate_ns1__getLendHistResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getLendHistResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getLendHistResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getLendHistResponse);
		if (size)
			*size = sizeof(ns1__getLendHistResponse);
		((ns1__getLendHistResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getLendHistResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getLendHistResponse);
		for (int i = 0; i < n; i++)
			((ns1__getLendHistResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getLendHistResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getLendHistResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getLendHistResponse %p -> %p\n", q, p));
	*(ns1__getLendHistResponse*)p = *(ns1__getLendHistResponse*)q;
}

void ns1__getLendHist::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getLendHist::arg0 = NULL;
	this->ns1__getLendHist::arg1 = NULL;
	this->ns1__getLendHist::arg2 = NULL;
	this->ns1__getLendHist::arg3 = NULL;
	/* transient soap skipped */
}

void ns1__getLendHist::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getLendHist::arg0);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getLendHist::arg1);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getLendHist::arg2);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getLendHist::arg3);
	/* transient soap skipped */
}

int ns1__getLendHist::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getLendHist(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getLendHist(struct soap *soap, const char *tag, int id, const ns1__getLendHist *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getLendHist), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->ns1__getLendHist::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg1", -1, &(a->ns1__getLendHist::arg1), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg2", -1, &(a->ns1__getLendHist::arg2), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg3", -1, &(a->ns1__getLendHist::arg3), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getLendHist::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getLendHist(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getLendHist * SOAP_FMAC4 soap_in_ns1__getLendHist(struct soap *soap, const char *tag, ns1__getLendHist *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getLendHist *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getLendHist, sizeof(ns1__getLendHist), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getLendHist)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getLendHist *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_arg21 = 1;
	size_t soap_flag_arg31 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->ns1__getLendHist::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_arg11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg1", &(a->ns1__getLendHist::arg1), "xsd:string"))
				{	soap_flag_arg11--;
					continue;
				}
			if (soap_flag_arg21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg2", &(a->ns1__getLendHist::arg2), "xsd:string"))
				{	soap_flag_arg21--;
					continue;
				}
			if (soap_flag_arg31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg3", &(a->ns1__getLendHist::arg3), "xsd:string"))
				{	soap_flag_arg31--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getLendHist *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getLendHist, 0, sizeof(ns1__getLendHist), 0, soap_copy_ns1__getLendHist);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getLendHist::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getLendHist);
	if (this->soap_out(soap, tag?tag:"ns1:getLendHist", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getLendHist::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getLendHist(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getLendHist * SOAP_FMAC4 soap_get_ns1__getLendHist(struct soap *soap, ns1__getLendHist *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getLendHist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getLendHist * SOAP_FMAC2 soap_instantiate_ns1__getLendHist(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getLendHist(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getLendHist, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getLendHist);
		if (size)
			*size = sizeof(ns1__getLendHist);
		((ns1__getLendHist*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getLendHist[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getLendHist);
		for (int i = 0; i < n; i++)
			((ns1__getLendHist*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getLendHist*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getLendHist(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getLendHist %p -> %p\n", q, p));
	*(ns1__getLendHist*)p = *(ns1__getLendHist*)q;
}

void ns1__certLossResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void ns1__certLossResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__certLossResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__certLossResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__certLossResponse(struct soap *soap, const char *tag, int id, const ns1__certLossResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__certLossResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__certLossResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__certLossResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__certLossResponse * SOAP_FMAC4 soap_in_ns1__certLossResponse(struct soap *soap, const char *tag, ns1__certLossResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__certLossResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__certLossResponse, sizeof(ns1__certLossResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__certLossResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__certLossResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__certLossResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__certLossResponse, 0, sizeof(ns1__certLossResponse), 0, soap_copy_ns1__certLossResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__certLossResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__certLossResponse);
	if (this->soap_out(soap, tag?tag:"ns1:certLossResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__certLossResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__certLossResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__certLossResponse * SOAP_FMAC4 soap_get_ns1__certLossResponse(struct soap *soap, ns1__certLossResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__certLossResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__certLossResponse * SOAP_FMAC2 soap_instantiate_ns1__certLossResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__certLossResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__certLossResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__certLossResponse);
		if (size)
			*size = sizeof(ns1__certLossResponse);
		((ns1__certLossResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__certLossResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__certLossResponse);
		for (int i = 0; i < n; i++)
			((ns1__certLossResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__certLossResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__certLossResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__certLossResponse %p -> %p\n", q, p));
	*(ns1__certLossResponse*)p = *(ns1__certLossResponse*)q;
}

void ns1__certLoss::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__certLoss::arg0 = NULL;
	this->ns1__certLoss::arg1 = NULL;
	this->ns1__certLoss::arg2 = NULL;
	this->ns1__certLoss::arg3 = NULL;
	soap_default_int(soap, &this->ns1__certLoss::arg4);
	this->ns1__certLoss::arg5 = NULL;
	/* transient soap skipped */
}

void ns1__certLoss::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__certLoss::arg0);
	soap_serialize_PointerTostd__string(soap, &this->ns1__certLoss::arg1);
	soap_serialize_PointerTostd__string(soap, &this->ns1__certLoss::arg2);
	soap_serialize_PointerTostd__string(soap, &this->ns1__certLoss::arg3);
	soap_serialize_PointerTostd__string(soap, &this->ns1__certLoss::arg5);
	/* transient soap skipped */
}

int ns1__certLoss::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__certLoss(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__certLoss(struct soap *soap, const char *tag, int id, const ns1__certLoss *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__certLoss), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->ns1__certLoss::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg1", -1, &(a->ns1__certLoss::arg1), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg2", -1, &(a->ns1__certLoss::arg2), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg3", -1, &(a->ns1__certLoss::arg3), ""))
		return soap->error;
	if (soap_out_int(soap, "arg4", -1, &(a->ns1__certLoss::arg4), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg5", -1, &(a->ns1__certLoss::arg5), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__certLoss::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__certLoss(soap, tag, this, type);
}

SOAP_FMAC3 ns1__certLoss * SOAP_FMAC4 soap_in_ns1__certLoss(struct soap *soap, const char *tag, ns1__certLoss *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__certLoss *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__certLoss, sizeof(ns1__certLoss), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__certLoss)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__certLoss *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_arg21 = 1;
	size_t soap_flag_arg31 = 1;
	size_t soap_flag_arg41 = 1;
	size_t soap_flag_arg51 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->ns1__certLoss::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_arg11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg1", &(a->ns1__certLoss::arg1), "xsd:string"))
				{	soap_flag_arg11--;
					continue;
				}
			if (soap_flag_arg21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg2", &(a->ns1__certLoss::arg2), "xsd:string"))
				{	soap_flag_arg21--;
					continue;
				}
			if (soap_flag_arg31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg3", &(a->ns1__certLoss::arg3), "xsd:string"))
				{	soap_flag_arg31--;
					continue;
				}
			if (soap_flag_arg41 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "arg4", &(a->ns1__certLoss::arg4), "xsd:int"))
				{	soap_flag_arg41--;
					continue;
				}
			if (soap_flag_arg51 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg5", &(a->ns1__certLoss::arg5), "xsd:string"))
				{	soap_flag_arg51--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__certLoss *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__certLoss, 0, sizeof(ns1__certLoss), 0, soap_copy_ns1__certLoss);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg41 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__certLoss::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__certLoss);
	if (this->soap_out(soap, tag?tag:"ns1:certLoss", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__certLoss::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__certLoss(soap, this, tag, type);
}

SOAP_FMAC3 ns1__certLoss * SOAP_FMAC4 soap_get_ns1__certLoss(struct soap *soap, ns1__certLoss *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__certLoss(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__certLoss * SOAP_FMAC2 soap_instantiate_ns1__certLoss(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__certLoss(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__certLoss, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__certLoss);
		if (size)
			*size = sizeof(ns1__certLoss);
		((ns1__certLoss*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__certLoss[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__certLoss);
		for (int i = 0; i < n; i++)
			((ns1__certLoss*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__certLoss*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__certLoss(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__certLoss %p -> %p\n", q, p));
	*(ns1__certLoss*)p = *(ns1__certLoss*)q;
}

void ns1__getViolationsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__violation(soap, &this->ns1__getViolationsResponse::return_);
	/* transient soap skipped */
}

void ns1__getViolationsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__violation(soap, &this->ns1__getViolationsResponse::return_);
	/* transient soap skipped */
}

int ns1__getViolationsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getViolationsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getViolationsResponse(struct soap *soap, const char *tag, int id, const ns1__getViolationsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getViolationsResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__violation(soap, "return", -1, &(a->ns1__getViolationsResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getViolationsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getViolationsResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getViolationsResponse * SOAP_FMAC4 soap_in_ns1__getViolationsResponse(struct soap *soap, const char *tag, ns1__getViolationsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getViolationsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getViolationsResponse, sizeof(ns1__getViolationsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getViolationsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getViolationsResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__violation(soap, "return", &(a->ns1__getViolationsResponse::return_), "ns1:violation"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getViolationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getViolationsResponse, 0, sizeof(ns1__getViolationsResponse), 0, soap_copy_ns1__getViolationsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getViolationsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getViolationsResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getViolationsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getViolationsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getViolationsResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getViolationsResponse * SOAP_FMAC4 soap_get_ns1__getViolationsResponse(struct soap *soap, ns1__getViolationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getViolationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getViolationsResponse * SOAP_FMAC2 soap_instantiate_ns1__getViolationsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getViolationsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getViolationsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getViolationsResponse);
		if (size)
			*size = sizeof(ns1__getViolationsResponse);
		((ns1__getViolationsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getViolationsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getViolationsResponse);
		for (int i = 0; i < n; i++)
			((ns1__getViolationsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getViolationsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getViolationsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getViolationsResponse %p -> %p\n", q, p));
	*(ns1__getViolationsResponse*)p = *(ns1__getViolationsResponse*)q;
}

void ns1__getViolations::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getViolations::arg0 = NULL;
	this->ns1__getViolations::arg1 = NULL;
	this->ns1__getViolations::arg2 = NULL;
	this->ns1__getViolations::arg3 = NULL;
	/* transient soap skipped */
}

void ns1__getViolations::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getViolations::arg0);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getViolations::arg1);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getViolations::arg2);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getViolations::arg3);
	/* transient soap skipped */
}

int ns1__getViolations::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getViolations(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getViolations(struct soap *soap, const char *tag, int id, const ns1__getViolations *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getViolations), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->ns1__getViolations::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg1", -1, &(a->ns1__getViolations::arg1), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg2", -1, &(a->ns1__getViolations::arg2), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg3", -1, &(a->ns1__getViolations::arg3), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getViolations::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getViolations(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getViolations * SOAP_FMAC4 soap_in_ns1__getViolations(struct soap *soap, const char *tag, ns1__getViolations *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getViolations *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getViolations, sizeof(ns1__getViolations), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getViolations)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getViolations *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_arg21 = 1;
	size_t soap_flag_arg31 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->ns1__getViolations::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_arg11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg1", &(a->ns1__getViolations::arg1), "xsd:string"))
				{	soap_flag_arg11--;
					continue;
				}
			if (soap_flag_arg21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg2", &(a->ns1__getViolations::arg2), "xsd:string"))
				{	soap_flag_arg21--;
					continue;
				}
			if (soap_flag_arg31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg3", &(a->ns1__getViolations::arg3), "xsd:string"))
				{	soap_flag_arg31--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getViolations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getViolations, 0, sizeof(ns1__getViolations), 0, soap_copy_ns1__getViolations);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getViolations::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getViolations);
	if (this->soap_out(soap, tag?tag:"ns1:getViolations", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getViolations::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getViolations(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getViolations * SOAP_FMAC4 soap_get_ns1__getViolations(struct soap *soap, ns1__getViolations *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getViolations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getViolations * SOAP_FMAC2 soap_instantiate_ns1__getViolations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getViolations(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getViolations, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getViolations);
		if (size)
			*size = sizeof(ns1__getViolations);
		((ns1__getViolations*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getViolations[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getViolations);
		for (int i = 0; i < n; i++)
			((ns1__getViolations*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getViolations*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getViolations(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getViolations %p -> %p\n", q, p));
	*(ns1__getViolations*)p = *(ns1__getViolations*)q;
}

void ns1__pregOrRelegate::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__pregOrRelegate::callNo = NULL;
	this->ns1__pregOrRelegate::certId = NULL;
	this->ns1__pregOrRelegate::dealFlag = NULL;
	this->ns1__pregOrRelegate::dealFlagName = NULL;
	this->ns1__pregOrRelegate::location = NULL;
	this->ns1__pregOrRelegate::name = NULL;
	this->ns1__pregOrRelegate::title = NULL;
	/* transient soap skipped */
}

void ns1__pregOrRelegate::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_wstring(soap, &this->ns1__pregOrRelegate::callNo);
	soap_serialize_wstring(soap, &this->ns1__pregOrRelegate::certId);
	soap_serialize_wstring(soap, &this->ns1__pregOrRelegate::dealFlag);
	soap_serialize_wstring(soap, &this->ns1__pregOrRelegate::dealFlagName);
	soap_serialize_wstring(soap, &this->ns1__pregOrRelegate::location);
	soap_serialize_wstring(soap, &this->ns1__pregOrRelegate::name);
	soap_serialize_wstring(soap, &this->ns1__pregOrRelegate::title);
	/* transient soap skipped */
}

int ns1__pregOrRelegate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__pregOrRelegate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__pregOrRelegate(struct soap *soap, const char *tag, int id, const ns1__pregOrRelegate *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__pregOrRelegate), type))
		return soap->error;
	if (soap_out_wstring(soap, "callNo", -1, &(a->ns1__pregOrRelegate::callNo), ""))
		return soap->error;
	if (soap_out_wstring(soap, "certId", -1, &(a->ns1__pregOrRelegate::certId), ""))
		return soap->error;
	if (soap_out_wstring(soap, "dealFlag", -1, &(a->ns1__pregOrRelegate::dealFlag), ""))
		return soap->error;
	if (soap_out_wstring(soap, "dealFlagName", -1, &(a->ns1__pregOrRelegate::dealFlagName), ""))
		return soap->error;
	if (soap_out_wstring(soap, "location", -1, &(a->ns1__pregOrRelegate::location), ""))
		return soap->error;
	if (soap_out_wstring(soap, "name", -1, &(a->ns1__pregOrRelegate::name), ""))
		return soap->error;
	if (soap_out_wstring(soap, "title", -1, &(a->ns1__pregOrRelegate::title), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__pregOrRelegate::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__pregOrRelegate(soap, tag, this, type);
}

SOAP_FMAC3 ns1__pregOrRelegate * SOAP_FMAC4 soap_in_ns1__pregOrRelegate(struct soap *soap, const char *tag, ns1__pregOrRelegate *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__pregOrRelegate *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__pregOrRelegate, sizeof(ns1__pregOrRelegate), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__pregOrRelegate)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__pregOrRelegate *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_callNo1 = 1;
	size_t soap_flag_certId1 = 1;
	size_t soap_flag_dealFlag1 = 1;
	size_t soap_flag_dealFlagName1 = 1;
	size_t soap_flag_location1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_title1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_callNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "callNo", &(a->ns1__pregOrRelegate::callNo), "xsd:string"))
				{	soap_flag_callNo1--;
					continue;
				}
			if (soap_flag_certId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "certId", &(a->ns1__pregOrRelegate::certId), "xsd:string"))
				{	soap_flag_certId1--;
					continue;
				}
			if (soap_flag_dealFlag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "dealFlag", &(a->ns1__pregOrRelegate::dealFlag), "xsd:string"))
				{	soap_flag_dealFlag1--;
					continue;
				}
			if (soap_flag_dealFlagName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "dealFlagName", &(a->ns1__pregOrRelegate::dealFlagName), "xsd:string"))
				{	soap_flag_dealFlagName1--;
					continue;
				}
			if (soap_flag_location1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "location", &(a->ns1__pregOrRelegate::location), "xsd:string"))
				{	soap_flag_location1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "name", &(a->ns1__pregOrRelegate::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "title", &(a->ns1__pregOrRelegate::title), "xsd:string"))
				{	soap_flag_title1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__pregOrRelegate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__pregOrRelegate, 0, sizeof(ns1__pregOrRelegate), 0, soap_copy_ns1__pregOrRelegate);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__pregOrRelegate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__pregOrRelegate);
	if (this->soap_out(soap, tag?tag:"ns1:pregOrRelegate", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__pregOrRelegate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__pregOrRelegate(soap, this, tag, type);
}

SOAP_FMAC3 ns1__pregOrRelegate * SOAP_FMAC4 soap_get_ns1__pregOrRelegate(struct soap *soap, ns1__pregOrRelegate *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__pregOrRelegate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__pregOrRelegate * SOAP_FMAC2 soap_instantiate_ns1__pregOrRelegate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__pregOrRelegate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__pregOrRelegate, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns1:relegate"))
	{	cp->type = SOAP_TYPE_ns1__relegate;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__relegate);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__relegate);
			((ns1__relegate*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__relegate[n]);
			if (size)
				*size = n * sizeof(ns1__relegate);
			for (int i = 0; i < n; i++)
				((ns1__relegate*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__relegate*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:preg"))
	{	cp->type = SOAP_TYPE_ns1__preg;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__preg);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__preg);
			((ns1__preg*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__preg[n]);
			if (size)
				*size = n * sizeof(ns1__preg);
			for (int i = 0; i < n; i++)
				((ns1__preg*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__preg*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__pregOrRelegate);
		if (size)
			*size = sizeof(ns1__pregOrRelegate);
		((ns1__pregOrRelegate*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__pregOrRelegate[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__pregOrRelegate);
		for (int i = 0; i < n; i++)
			((ns1__pregOrRelegate*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__pregOrRelegate*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__pregOrRelegate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__pregOrRelegate %p -> %p\n", q, p));
	*(ns1__pregOrRelegate*)p = *(ns1__pregOrRelegate*)q;
}

void ns1__relegate::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__relegate::relegateDate = NULL;
	this->ns1__relegate::relegateEndDate = NULL;
	this->ns1__pregOrRelegate::callNo = NULL;
	this->ns1__pregOrRelegate::certId = NULL;
	this->ns1__pregOrRelegate::dealFlag = NULL;
	this->ns1__pregOrRelegate::dealFlagName = NULL;
	this->ns1__pregOrRelegate::location = NULL;
	this->ns1__pregOrRelegate::name = NULL;
	this->ns1__pregOrRelegate::title = NULL;
	/* transient soap skipped */
}

void ns1__relegate::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_wstring(soap, &this->ns1__relegate::relegateDate);
	soap_serialize_wstring(soap, &this->ns1__relegate::relegateEndDate);
	soap_serialize_wstring(soap, &this->ns1__pregOrRelegate::callNo);
	soap_serialize_wstring(soap, &this->ns1__pregOrRelegate::certId);
	soap_serialize_wstring(soap, &this->ns1__pregOrRelegate::dealFlag);
	soap_serialize_wstring(soap, &this->ns1__pregOrRelegate::dealFlagName);
	soap_serialize_wstring(soap, &this->ns1__pregOrRelegate::location);
	soap_serialize_wstring(soap, &this->ns1__pregOrRelegate::name);
	soap_serialize_wstring(soap, &this->ns1__pregOrRelegate::title);
	/* transient soap skipped */
}

int ns1__relegate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__relegate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__relegate(struct soap *soap, const char *tag, int id, const ns1__relegate *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__relegate), "ns1:relegate"))
		return soap->error;
	if (soap_out_wstring(soap, "callNo", -1, &(a->ns1__pregOrRelegate::callNo), ""))
		return soap->error;
	if (soap_out_wstring(soap, "certId", -1, &(a->ns1__pregOrRelegate::certId), ""))
		return soap->error;
	if (soap_out_wstring(soap, "dealFlag", -1, &(a->ns1__pregOrRelegate::dealFlag), ""))
		return soap->error;
	if (soap_out_wstring(soap, "dealFlagName", -1, &(a->ns1__pregOrRelegate::dealFlagName), ""))
		return soap->error;
	if (soap_out_wstring(soap, "location", -1, &(a->ns1__pregOrRelegate::location), ""))
		return soap->error;
	if (soap_out_wstring(soap, "name", -1, &(a->ns1__pregOrRelegate::name), ""))
		return soap->error;
	if (soap_out_wstring(soap, "title", -1, &(a->ns1__pregOrRelegate::title), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_wstring(soap, "relegateDate", -1, &(a->ns1__relegate::relegateDate), ""))
		return soap->error;
	if (soap_out_wstring(soap, "relegateEndDate", -1, &(a->ns1__relegate::relegateEndDate), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__relegate::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__relegate(soap, tag, this, type);
}

SOAP_FMAC3 ns1__relegate * SOAP_FMAC4 soap_in_ns1__relegate(struct soap *soap, const char *tag, ns1__relegate *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__relegate *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__relegate, sizeof(ns1__relegate), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__relegate)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__relegate *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_callNo2 = 1;
	size_t soap_flag_certId2 = 1;
	size_t soap_flag_dealFlag2 = 1;
	size_t soap_flag_dealFlagName2 = 1;
	size_t soap_flag_location2 = 1;
	size_t soap_flag_name2 = 1;
	size_t soap_flag_title2 = 1;
	size_t soap_flag_relegateDate1 = 1;
	size_t soap_flag_relegateEndDate1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_callNo2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "callNo", &(a->ns1__pregOrRelegate::callNo), "xsd:string"))
				{	soap_flag_callNo2--;
					continue;
				}
			if (soap_flag_certId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "certId", &(a->ns1__pregOrRelegate::certId), "xsd:string"))
				{	soap_flag_certId2--;
					continue;
				}
			if (soap_flag_dealFlag2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "dealFlag", &(a->ns1__pregOrRelegate::dealFlag), "xsd:string"))
				{	soap_flag_dealFlag2--;
					continue;
				}
			if (soap_flag_dealFlagName2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "dealFlagName", &(a->ns1__pregOrRelegate::dealFlagName), "xsd:string"))
				{	soap_flag_dealFlagName2--;
					continue;
				}
			if (soap_flag_location2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "location", &(a->ns1__pregOrRelegate::location), "xsd:string"))
				{	soap_flag_location2--;
					continue;
				}
			if (soap_flag_name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "name", &(a->ns1__pregOrRelegate::name), "xsd:string"))
				{	soap_flag_name2--;
					continue;
				}
			if (soap_flag_title2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "title", &(a->ns1__pregOrRelegate::title), "xsd:string"))
				{	soap_flag_title2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_relegateDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "relegateDate", &(a->ns1__relegate::relegateDate), "xsd:string"))
				{	soap_flag_relegateDate1--;
					continue;
				}
			if (soap_flag_relegateEndDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "relegateEndDate", &(a->ns1__relegate::relegateEndDate), "xsd:string"))
				{	soap_flag_relegateEndDate1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__relegate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__relegate, 0, sizeof(ns1__relegate), 0, soap_copy_ns1__relegate);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__relegate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__relegate);
	if (this->soap_out(soap, tag?tag:"ns1:relegate", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__relegate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__relegate(soap, this, tag, type);
}

SOAP_FMAC3 ns1__relegate * SOAP_FMAC4 soap_get_ns1__relegate(struct soap *soap, ns1__relegate *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__relegate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__relegate * SOAP_FMAC2 soap_instantiate_ns1__relegate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__relegate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__relegate, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__relegate);
		if (size)
			*size = sizeof(ns1__relegate);
		((ns1__relegate*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__relegate[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__relegate);
		for (int i = 0; i < n; i++)
			((ns1__relegate*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__relegate*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__relegate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__relegate %p -> %p\n", q, p));
	*(ns1__relegate*)p = *(ns1__relegate*)q;
}

void ns1__getRelegatesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__relegate(soap, &this->ns1__getRelegatesResponse::return_);
	/* transient soap skipped */
}

void ns1__getRelegatesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__relegate(soap, &this->ns1__getRelegatesResponse::return_);
	/* transient soap skipped */
}

int ns1__getRelegatesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getRelegatesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getRelegatesResponse(struct soap *soap, const char *tag, int id, const ns1__getRelegatesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getRelegatesResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__relegate(soap, "return", -1, &(a->ns1__getRelegatesResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getRelegatesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getRelegatesResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getRelegatesResponse * SOAP_FMAC4 soap_in_ns1__getRelegatesResponse(struct soap *soap, const char *tag, ns1__getRelegatesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getRelegatesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getRelegatesResponse, sizeof(ns1__getRelegatesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getRelegatesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getRelegatesResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__relegate(soap, "return", &(a->ns1__getRelegatesResponse::return_), "ns1:relegate"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getRelegatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getRelegatesResponse, 0, sizeof(ns1__getRelegatesResponse), 0, soap_copy_ns1__getRelegatesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getRelegatesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getRelegatesResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getRelegatesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getRelegatesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getRelegatesResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getRelegatesResponse * SOAP_FMAC4 soap_get_ns1__getRelegatesResponse(struct soap *soap, ns1__getRelegatesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getRelegatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getRelegatesResponse * SOAP_FMAC2 soap_instantiate_ns1__getRelegatesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getRelegatesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getRelegatesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getRelegatesResponse);
		if (size)
			*size = sizeof(ns1__getRelegatesResponse);
		((ns1__getRelegatesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getRelegatesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getRelegatesResponse);
		for (int i = 0; i < n; i++)
			((ns1__getRelegatesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getRelegatesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getRelegatesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getRelegatesResponse %p -> %p\n", q, p));
	*(ns1__getRelegatesResponse*)p = *(ns1__getRelegatesResponse*)q;
}

void ns1__getRelegates::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getRelegates::arg0 = NULL;
	this->ns1__getRelegates::arg1 = NULL;
	this->ns1__getRelegates::arg2 = NULL;
	this->ns1__getRelegates::arg3 = NULL;
	/* transient soap skipped */
}

void ns1__getRelegates::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getRelegates::arg0);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getRelegates::arg1);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getRelegates::arg2);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getRelegates::arg3);
	/* transient soap skipped */
}

int ns1__getRelegates::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getRelegates(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getRelegates(struct soap *soap, const char *tag, int id, const ns1__getRelegates *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getRelegates), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->ns1__getRelegates::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg1", -1, &(a->ns1__getRelegates::arg1), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg2", -1, &(a->ns1__getRelegates::arg2), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg3", -1, &(a->ns1__getRelegates::arg3), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getRelegates::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getRelegates(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getRelegates * SOAP_FMAC4 soap_in_ns1__getRelegates(struct soap *soap, const char *tag, ns1__getRelegates *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getRelegates *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getRelegates, sizeof(ns1__getRelegates), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getRelegates)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getRelegates *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_arg21 = 1;
	size_t soap_flag_arg31 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->ns1__getRelegates::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_arg11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg1", &(a->ns1__getRelegates::arg1), "xsd:string"))
				{	soap_flag_arg11--;
					continue;
				}
			if (soap_flag_arg21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg2", &(a->ns1__getRelegates::arg2), "xsd:string"))
				{	soap_flag_arg21--;
					continue;
				}
			if (soap_flag_arg31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg3", &(a->ns1__getRelegates::arg3), "xsd:string"))
				{	soap_flag_arg31--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getRelegates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getRelegates, 0, sizeof(ns1__getRelegates), 0, soap_copy_ns1__getRelegates);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getRelegates::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getRelegates);
	if (this->soap_out(soap, tag?tag:"ns1:getRelegates", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getRelegates::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getRelegates(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getRelegates * SOAP_FMAC4 soap_get_ns1__getRelegates(struct soap *soap, ns1__getRelegates *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getRelegates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getRelegates * SOAP_FMAC2 soap_instantiate_ns1__getRelegates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getRelegates(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getRelegates, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getRelegates);
		if (size)
			*size = sizeof(ns1__getRelegates);
		((ns1__getRelegates*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getRelegates[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getRelegates);
		for (int i = 0; i < n; i++)
			((ns1__getRelegates*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getRelegates*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getRelegates(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getRelegates %p -> %p\n", q, p));
	*(ns1__getRelegates*)p = *(ns1__getRelegates*)q;
}

void ns1__violation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__violation::certId = NULL;
	this->ns1__violation::dealFlag = NULL;
	this->ns1__violation::dealFlagName = NULL;
	soap_default_float(soap, &this->ns1__violation::fineAmount);
	this->ns1__violation::frozEndDate = NULL;
	this->ns1__violation::name = NULL;
	this->ns1__violation::pulishDate = NULL;
	this->ns1__violation::voltName = NULL;
	/* transient soap skipped */
}

void ns1__violation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_wstring(soap, &this->ns1__violation::certId);
	soap_serialize_wstring(soap, &this->ns1__violation::dealFlag);
	soap_serialize_wstring(soap, &this->ns1__violation::dealFlagName);
	soap_serialize_wstring(soap, &this->ns1__violation::frozEndDate);
	soap_serialize_wstring(soap, &this->ns1__violation::name);
	soap_serialize_wstring(soap, &this->ns1__violation::pulishDate);
	soap_serialize_wstring(soap, &this->ns1__violation::voltName);
	/* transient soap skipped */
}

int ns1__violation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__violation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__violation(struct soap *soap, const char *tag, int id, const ns1__violation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__violation), type))
		return soap->error;
	if (soap_out_wstring(soap, "certId", -1, &(a->ns1__violation::certId), ""))
		return soap->error;
	if (soap_out_wstring(soap, "dealFlag", -1, &(a->ns1__violation::dealFlag), ""))
		return soap->error;
	if (soap_out_wstring(soap, "dealFlagName", -1, &(a->ns1__violation::dealFlagName), ""))
		return soap->error;
	if (soap_out_float(soap, "fineAmount", -1, &(a->ns1__violation::fineAmount), ""))
		return soap->error;
	if (soap_out_wstring(soap, "frozEndDate", -1, &(a->ns1__violation::frozEndDate), ""))
		return soap->error;
	if (soap_out_wstring(soap, "name", -1, &(a->ns1__violation::name), ""))
		return soap->error;
	if (soap_out_wstring(soap, "pulishDate", -1, &(a->ns1__violation::pulishDate), ""))
		return soap->error;
	if (soap_out_wstring(soap, "voltName", -1, &(a->ns1__violation::voltName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__violation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__violation(soap, tag, this, type);
}

SOAP_FMAC3 ns1__violation * SOAP_FMAC4 soap_in_ns1__violation(struct soap *soap, const char *tag, ns1__violation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__violation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__violation, sizeof(ns1__violation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__violation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__violation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_certId1 = 1;
	size_t soap_flag_dealFlag1 = 1;
	size_t soap_flag_dealFlagName1 = 1;
	size_t soap_flag_fineAmount1 = 1;
	size_t soap_flag_frozEndDate1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_pulishDate1 = 1;
	size_t soap_flag_voltName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_certId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "certId", &(a->ns1__violation::certId), "xsd:string"))
				{	soap_flag_certId1--;
					continue;
				}
			if (soap_flag_dealFlag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "dealFlag", &(a->ns1__violation::dealFlag), "xsd:string"))
				{	soap_flag_dealFlag1--;
					continue;
				}
			if (soap_flag_dealFlagName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "dealFlagName", &(a->ns1__violation::dealFlagName), "xsd:string"))
				{	soap_flag_dealFlagName1--;
					continue;
				}
			if (soap_flag_fineAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "fineAmount", &(a->ns1__violation::fineAmount), "xsd:float"))
				{	soap_flag_fineAmount1--;
					continue;
				}
			if (soap_flag_frozEndDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "frozEndDate", &(a->ns1__violation::frozEndDate), "xsd:string"))
				{	soap_flag_frozEndDate1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "name", &(a->ns1__violation::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_pulishDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "pulishDate", &(a->ns1__violation::pulishDate), "xsd:string"))
				{	soap_flag_pulishDate1--;
					continue;
				}
			if (soap_flag_voltName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "voltName", &(a->ns1__violation::voltName), "xsd:string"))
				{	soap_flag_voltName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__violation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__violation, 0, sizeof(ns1__violation), 0, soap_copy_ns1__violation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fineAmount1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__violation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__violation);
	if (this->soap_out(soap, tag?tag:"ns1:violation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__violation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__violation(soap, this, tag, type);
}

SOAP_FMAC3 ns1__violation * SOAP_FMAC4 soap_get_ns1__violation(struct soap *soap, ns1__violation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__violation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__violation * SOAP_FMAC2 soap_instantiate_ns1__violation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__violation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__violation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__violation);
		if (size)
			*size = sizeof(ns1__violation);
		((ns1__violation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__violation[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__violation);
		for (int i = 0; i < n; i++)
			((ns1__violation*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__violation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__violation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__violation %p -> %p\n", q, p));
	*(ns1__violation*)p = *(ns1__violation*)q;
}

void ns1__getViolations1Response::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__violation(soap, &this->ns1__getViolations1Response::return_);
	/* transient soap skipped */
}

void ns1__getViolations1Response::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__violation(soap, &this->ns1__getViolations1Response::return_);
	/* transient soap skipped */
}

int ns1__getViolations1Response::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getViolations1Response(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getViolations1Response(struct soap *soap, const char *tag, int id, const ns1__getViolations1Response *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getViolations1Response), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__violation(soap, "return", -1, &(a->ns1__getViolations1Response::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getViolations1Response::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getViolations1Response(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getViolations1Response * SOAP_FMAC4 soap_in_ns1__getViolations1Response(struct soap *soap, const char *tag, ns1__getViolations1Response *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getViolations1Response *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getViolations1Response, sizeof(ns1__getViolations1Response), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getViolations1Response)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getViolations1Response *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__violation(soap, "return", &(a->ns1__getViolations1Response::return_), "ns1:violation"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getViolations1Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getViolations1Response, 0, sizeof(ns1__getViolations1Response), 0, soap_copy_ns1__getViolations1Response);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getViolations1Response::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getViolations1Response);
	if (this->soap_out(soap, tag?tag:"ns1:getViolations1Response", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getViolations1Response::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getViolations1Response(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getViolations1Response * SOAP_FMAC4 soap_get_ns1__getViolations1Response(struct soap *soap, ns1__getViolations1Response *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getViolations1Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getViolations1Response * SOAP_FMAC2 soap_instantiate_ns1__getViolations1Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getViolations1Response(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getViolations1Response, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getViolations1Response);
		if (size)
			*size = sizeof(ns1__getViolations1Response);
		((ns1__getViolations1Response*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getViolations1Response[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getViolations1Response);
		for (int i = 0; i < n; i++)
			((ns1__getViolations1Response*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getViolations1Response*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getViolations1Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getViolations1Response %p -> %p\n", q, p));
	*(ns1__getViolations1Response*)p = *(ns1__getViolations1Response*)q;
}

void ns1__getViolations1::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getViolations1::arg0 = NULL;
	this->ns1__getViolations1::arg1 = NULL;
	this->ns1__getViolations1::arg2 = NULL;
	this->ns1__getViolations1::arg3 = NULL;
	this->ns1__getViolations1::arg4 = NULL;
	/* transient soap skipped */
}

void ns1__getViolations1::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getViolations1::arg0);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getViolations1::arg1);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getViolations1::arg2);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getViolations1::arg3);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getViolations1::arg4);
	/* transient soap skipped */
}

int ns1__getViolations1::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getViolations1(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getViolations1(struct soap *soap, const char *tag, int id, const ns1__getViolations1 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getViolations1), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->ns1__getViolations1::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg1", -1, &(a->ns1__getViolations1::arg1), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg2", -1, &(a->ns1__getViolations1::arg2), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg3", -1, &(a->ns1__getViolations1::arg3), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg4", -1, &(a->ns1__getViolations1::arg4), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getViolations1::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getViolations1(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getViolations1 * SOAP_FMAC4 soap_in_ns1__getViolations1(struct soap *soap, const char *tag, ns1__getViolations1 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getViolations1 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getViolations1, sizeof(ns1__getViolations1), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getViolations1)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getViolations1 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_arg21 = 1;
	size_t soap_flag_arg31 = 1;
	size_t soap_flag_arg41 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->ns1__getViolations1::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_arg11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg1", &(a->ns1__getViolations1::arg1), "xsd:string"))
				{	soap_flag_arg11--;
					continue;
				}
			if (soap_flag_arg21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg2", &(a->ns1__getViolations1::arg2), "xsd:string"))
				{	soap_flag_arg21--;
					continue;
				}
			if (soap_flag_arg31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg3", &(a->ns1__getViolations1::arg3), "xsd:string"))
				{	soap_flag_arg31--;
					continue;
				}
			if (soap_flag_arg41 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg4", &(a->ns1__getViolations1::arg4), "xsd:string"))
				{	soap_flag_arg41--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getViolations1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getViolations1, 0, sizeof(ns1__getViolations1), 0, soap_copy_ns1__getViolations1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getViolations1::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getViolations1);
	if (this->soap_out(soap, tag?tag:"ns1:getViolations1", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getViolations1::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getViolations1(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getViolations1 * SOAP_FMAC4 soap_get_ns1__getViolations1(struct soap *soap, ns1__getViolations1 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getViolations1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getViolations1 * SOAP_FMAC2 soap_instantiate_ns1__getViolations1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getViolations1(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getViolations1, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getViolations1);
		if (size)
			*size = sizeof(ns1__getViolations1);
		((ns1__getViolations1*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getViolations1[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getViolations1);
		for (int i = 0; i < n; i++)
			((ns1__getViolations1*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getViolations1*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getViolations1(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getViolations1 %p -> %p\n", q, p));
	*(ns1__getViolations1*)p = *(ns1__getViolations1*)q;
}

void ns1__debt::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__debt::certId = NULL;
	this->ns1__debt::debtDealFlag = NULL;
	this->ns1__debt::debtDealFlagName = NULL;
	soap_default_float(soap, &this->ns1__debt::dueFineAmount);
	soap_default_float(soap, &this->ns1__debt::fineAmount);
	this->ns1__debt::lendDate = NULL;
	this->ns1__debt::locationF = NULL;
	this->ns1__debt::name = NULL;
	this->ns1__debt::propNo = NULL;
	this->ns1__debt::retDate = NULL;
	/* transient soap skipped */
}

void ns1__debt::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_wstring(soap, &this->ns1__debt::certId);
	soap_serialize_wstring(soap, &this->ns1__debt::debtDealFlag);
	soap_serialize_wstring(soap, &this->ns1__debt::debtDealFlagName);
	soap_serialize_wstring(soap, &this->ns1__debt::lendDate);
	soap_serialize_wstring(soap, &this->ns1__debt::locationF);
	soap_serialize_wstring(soap, &this->ns1__debt::name);
	soap_serialize_wstring(soap, &this->ns1__debt::propNo);
	soap_serialize_wstring(soap, &this->ns1__debt::retDate);
	/* transient soap skipped */
}

int ns1__debt::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__debt(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__debt(struct soap *soap, const char *tag, int id, const ns1__debt *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__debt), type))
		return soap->error;
	if (soap_out_wstring(soap, "certId", -1, &(a->ns1__debt::certId), ""))
		return soap->error;
	if (soap_out_wstring(soap, "debtDealFlag", -1, &(a->ns1__debt::debtDealFlag), ""))
		return soap->error;
	if (soap_out_wstring(soap, "debtDealFlagName", -1, &(a->ns1__debt::debtDealFlagName), ""))
		return soap->error;
	if (soap_out_float(soap, "dueFineAmount", -1, &(a->ns1__debt::dueFineAmount), ""))
		return soap->error;
	if (soap_out_float(soap, "fineAmount", -1, &(a->ns1__debt::fineAmount), ""))
		return soap->error;
	if (soap_out_wstring(soap, "lendDate", -1, &(a->ns1__debt::lendDate), ""))
		return soap->error;
	if (soap_out_wstring(soap, "locationF", -1, &(a->ns1__debt::locationF), ""))
		return soap->error;
	if (soap_out_wstring(soap, "name", -1, &(a->ns1__debt::name), ""))
		return soap->error;
	if (soap_out_wstring(soap, "propNo", -1, &(a->ns1__debt::propNo), ""))
		return soap->error;
	if (soap_out_wstring(soap, "retDate", -1, &(a->ns1__debt::retDate), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__debt::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__debt(soap, tag, this, type);
}

SOAP_FMAC3 ns1__debt * SOAP_FMAC4 soap_in_ns1__debt(struct soap *soap, const char *tag, ns1__debt *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__debt *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__debt, sizeof(ns1__debt), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__debt)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__debt *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_certId1 = 1;
	size_t soap_flag_debtDealFlag1 = 1;
	size_t soap_flag_debtDealFlagName1 = 1;
	size_t soap_flag_dueFineAmount1 = 1;
	size_t soap_flag_fineAmount1 = 1;
	size_t soap_flag_lendDate1 = 1;
	size_t soap_flag_locationF1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_propNo1 = 1;
	size_t soap_flag_retDate1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_certId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "certId", &(a->ns1__debt::certId), "xsd:string"))
				{	soap_flag_certId1--;
					continue;
				}
			if (soap_flag_debtDealFlag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "debtDealFlag", &(a->ns1__debt::debtDealFlag), "xsd:string"))
				{	soap_flag_debtDealFlag1--;
					continue;
				}
			if (soap_flag_debtDealFlagName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "debtDealFlagName", &(a->ns1__debt::debtDealFlagName), "xsd:string"))
				{	soap_flag_debtDealFlagName1--;
					continue;
				}
			if (soap_flag_dueFineAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "dueFineAmount", &(a->ns1__debt::dueFineAmount), "xsd:float"))
				{	soap_flag_dueFineAmount1--;
					continue;
				}
			if (soap_flag_fineAmount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "fineAmount", &(a->ns1__debt::fineAmount), "xsd:float"))
				{	soap_flag_fineAmount1--;
					continue;
				}
			if (soap_flag_lendDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "lendDate", &(a->ns1__debt::lendDate), "xsd:string"))
				{	soap_flag_lendDate1--;
					continue;
				}
			if (soap_flag_locationF1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "locationF", &(a->ns1__debt::locationF), "xsd:string"))
				{	soap_flag_locationF1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "name", &(a->ns1__debt::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_propNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "propNo", &(a->ns1__debt::propNo), "xsd:string"))
				{	soap_flag_propNo1--;
					continue;
				}
			if (soap_flag_retDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "retDate", &(a->ns1__debt::retDate), "xsd:string"))
				{	soap_flag_retDate1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__debt *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__debt, 0, sizeof(ns1__debt), 0, soap_copy_ns1__debt);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_dueFineAmount1 > 0 || soap_flag_fineAmount1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__debt::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__debt);
	if (this->soap_out(soap, tag?tag:"ns1:debt", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__debt::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__debt(soap, this, tag, type);
}

SOAP_FMAC3 ns1__debt * SOAP_FMAC4 soap_get_ns1__debt(struct soap *soap, ns1__debt *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__debt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__debt * SOAP_FMAC2 soap_instantiate_ns1__debt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__debt(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__debt, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__debt);
		if (size)
			*size = sizeof(ns1__debt);
		((ns1__debt*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__debt[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__debt);
		for (int i = 0; i < n; i++)
			((ns1__debt*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__debt*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__debt(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__debt %p -> %p\n", q, p));
	*(ns1__debt*)p = *(ns1__debt*)q;
}

void ns1__getDebtsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__debt(soap, &this->ns1__getDebtsResponse::return_);
	/* transient soap skipped */
}

void ns1__getDebtsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__debt(soap, &this->ns1__getDebtsResponse::return_);
	/* transient soap skipped */
}

int ns1__getDebtsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getDebtsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDebtsResponse(struct soap *soap, const char *tag, int id, const ns1__getDebtsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDebtsResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__debt(soap, "return", -1, &(a->ns1__getDebtsResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getDebtsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getDebtsResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getDebtsResponse * SOAP_FMAC4 soap_in_ns1__getDebtsResponse(struct soap *soap, const char *tag, ns1__getDebtsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getDebtsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDebtsResponse, sizeof(ns1__getDebtsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getDebtsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getDebtsResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__debt(soap, "return", &(a->ns1__getDebtsResponse::return_), "ns1:debt"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getDebtsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDebtsResponse, 0, sizeof(ns1__getDebtsResponse), 0, soap_copy_ns1__getDebtsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getDebtsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getDebtsResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getDebtsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getDebtsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getDebtsResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getDebtsResponse * SOAP_FMAC4 soap_get_ns1__getDebtsResponse(struct soap *soap, ns1__getDebtsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDebtsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getDebtsResponse * SOAP_FMAC2 soap_instantiate_ns1__getDebtsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDebtsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDebtsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getDebtsResponse);
		if (size)
			*size = sizeof(ns1__getDebtsResponse);
		((ns1__getDebtsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getDebtsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getDebtsResponse);
		for (int i = 0; i < n; i++)
			((ns1__getDebtsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getDebtsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDebtsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getDebtsResponse %p -> %p\n", q, p));
	*(ns1__getDebtsResponse*)p = *(ns1__getDebtsResponse*)q;
}

void ns1__getDebts::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getDebts::arg0 = NULL;
	this->ns1__getDebts::arg1 = NULL;
	this->ns1__getDebts::arg2 = NULL;
	this->ns1__getDebts::arg3 = NULL;
	/* transient soap skipped */
}

void ns1__getDebts::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getDebts::arg0);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getDebts::arg1);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getDebts::arg2);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getDebts::arg3);
	/* transient soap skipped */
}

int ns1__getDebts::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getDebts(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDebts(struct soap *soap, const char *tag, int id, const ns1__getDebts *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDebts), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->ns1__getDebts::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg1", -1, &(a->ns1__getDebts::arg1), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg2", -1, &(a->ns1__getDebts::arg2), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg3", -1, &(a->ns1__getDebts::arg3), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getDebts::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getDebts(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getDebts * SOAP_FMAC4 soap_in_ns1__getDebts(struct soap *soap, const char *tag, ns1__getDebts *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getDebts *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDebts, sizeof(ns1__getDebts), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getDebts)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getDebts *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_arg21 = 1;
	size_t soap_flag_arg31 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->ns1__getDebts::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_arg11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg1", &(a->ns1__getDebts::arg1), "xsd:string"))
				{	soap_flag_arg11--;
					continue;
				}
			if (soap_flag_arg21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg2", &(a->ns1__getDebts::arg2), "xsd:string"))
				{	soap_flag_arg21--;
					continue;
				}
			if (soap_flag_arg31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg3", &(a->ns1__getDebts::arg3), "xsd:string"))
				{	soap_flag_arg31--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getDebts *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDebts, 0, sizeof(ns1__getDebts), 0, soap_copy_ns1__getDebts);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getDebts::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getDebts);
	if (this->soap_out(soap, tag?tag:"ns1:getDebts", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getDebts::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getDebts(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getDebts * SOAP_FMAC4 soap_get_ns1__getDebts(struct soap *soap, ns1__getDebts *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDebts(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getDebts * SOAP_FMAC2 soap_instantiate_ns1__getDebts(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDebts(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDebts, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getDebts);
		if (size)
			*size = sizeof(ns1__getDebts);
		((ns1__getDebts*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getDebts[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getDebts);
		for (int i = 0; i < n; i++)
			((ns1__getDebts*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getDebts*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDebts(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getDebts %p -> %p\n", q, p));
	*(ns1__getDebts*)p = *(ns1__getDebts*)q;
}

void ns1__checkRedrResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__checkRedrResult::code);
	this->ns1__checkRedrResult::reader = NULL;
	/* transient soap skipped */
}

void ns1__checkRedrResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__reader(soap, &this->ns1__checkRedrResult::reader);
	/* transient soap skipped */
}

int ns1__checkRedrResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__checkRedrResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__checkRedrResult(struct soap *soap, const char *tag, int id, const ns1__checkRedrResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__checkRedrResult), type))
		return soap->error;
	if (soap_out_int(soap, "code", -1, &(a->ns1__checkRedrResult::code), ""))
		return soap->error;
	if (soap_out_PointerTons1__reader(soap, "reader", -1, &(a->ns1__checkRedrResult::reader), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__checkRedrResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__checkRedrResult(soap, tag, this, type);
}

SOAP_FMAC3 ns1__checkRedrResult * SOAP_FMAC4 soap_in_ns1__checkRedrResult(struct soap *soap, const char *tag, ns1__checkRedrResult *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__checkRedrResult *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__checkRedrResult, sizeof(ns1__checkRedrResult), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__checkRedrResult)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__checkRedrResult *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_code1 = 1;
	size_t soap_flag_reader1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_code1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "code", &(a->ns1__checkRedrResult::code), "xsd:int"))
				{	soap_flag_code1--;
					continue;
				}
			if (soap_flag_reader1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__reader(soap, "reader", &(a->ns1__checkRedrResult::reader), "ns1:reader"))
				{	soap_flag_reader1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__checkRedrResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__checkRedrResult, 0, sizeof(ns1__checkRedrResult), 0, soap_copy_ns1__checkRedrResult);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_code1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__checkRedrResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__checkRedrResult);
	if (this->soap_out(soap, tag?tag:"ns1:checkRedrResult", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__checkRedrResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__checkRedrResult(soap, this, tag, type);
}

SOAP_FMAC3 ns1__checkRedrResult * SOAP_FMAC4 soap_get_ns1__checkRedrResult(struct soap *soap, ns1__checkRedrResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__checkRedrResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__checkRedrResult * SOAP_FMAC2 soap_instantiate_ns1__checkRedrResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__checkRedrResult(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__checkRedrResult, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__checkRedrResult);
		if (size)
			*size = sizeof(ns1__checkRedrResult);
		((ns1__checkRedrResult*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__checkRedrResult[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__checkRedrResult);
		for (int i = 0; i < n; i++)
			((ns1__checkRedrResult*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__checkRedrResult*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__checkRedrResult(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__checkRedrResult %p -> %p\n", q, p));
	*(ns1__checkRedrResult*)p = *(ns1__checkRedrResult*)q;
}

void ns1__checkReaderResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__checkReaderResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__checkReaderResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__checkRedrResult(soap, &this->ns1__checkReaderResponse::return_);
	/* transient soap skipped */
}

int ns1__checkReaderResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__checkReaderResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__checkReaderResponse(struct soap *soap, const char *tag, int id, const ns1__checkReaderResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__checkReaderResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__checkRedrResult(soap, "return", -1, &(a->ns1__checkReaderResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__checkReaderResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__checkReaderResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__checkReaderResponse * SOAP_FMAC4 soap_in_ns1__checkReaderResponse(struct soap *soap, const char *tag, ns1__checkReaderResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__checkReaderResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__checkReaderResponse, sizeof(ns1__checkReaderResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__checkReaderResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__checkReaderResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__checkRedrResult(soap, "return", &(a->ns1__checkReaderResponse::return_), "ns1:checkRedrResult"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__checkReaderResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__checkReaderResponse, 0, sizeof(ns1__checkReaderResponse), 0, soap_copy_ns1__checkReaderResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__checkReaderResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__checkReaderResponse);
	if (this->soap_out(soap, tag?tag:"ns1:checkReaderResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__checkReaderResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__checkReaderResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__checkReaderResponse * SOAP_FMAC4 soap_get_ns1__checkReaderResponse(struct soap *soap, ns1__checkReaderResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__checkReaderResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__checkReaderResponse * SOAP_FMAC2 soap_instantiate_ns1__checkReaderResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__checkReaderResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__checkReaderResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__checkReaderResponse);
		if (size)
			*size = sizeof(ns1__checkReaderResponse);
		((ns1__checkReaderResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__checkReaderResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__checkReaderResponse);
		for (int i = 0; i < n; i++)
			((ns1__checkReaderResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__checkReaderResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__checkReaderResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__checkReaderResponse %p -> %p\n", q, p));
	*(ns1__checkReaderResponse*)p = *(ns1__checkReaderResponse*)q;
}

void ns1__checkReader::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__checkReader::arg0 = NULL;
	this->ns1__checkReader::arg1 = NULL;
	this->ns1__checkReader::arg2 = NULL;
	soap_default_int(soap, &this->ns1__checkReader::arg3);
	this->ns1__checkReader::arg4 = NULL;
	this->ns1__checkReader::arg5 = NULL;
	/* transient soap skipped */
}

void ns1__checkReader::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__checkReader::arg0);
	soap_serialize_PointerTostd__string(soap, &this->ns1__checkReader::arg1);
	soap_serialize_PointerTostd__string(soap, &this->ns1__checkReader::arg2);
	soap_serialize_PointerTostd__string(soap, &this->ns1__checkReader::arg4);
	soap_serialize_PointerTostd__string(soap, &this->ns1__checkReader::arg5);
	/* transient soap skipped */
}

int ns1__checkReader::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__checkReader(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__checkReader(struct soap *soap, const char *tag, int id, const ns1__checkReader *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__checkReader), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->ns1__checkReader::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg1", -1, &(a->ns1__checkReader::arg1), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg2", -1, &(a->ns1__checkReader::arg2), ""))
		return soap->error;
	if (soap_out_int(soap, "arg3", -1, &(a->ns1__checkReader::arg3), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg4", -1, &(a->ns1__checkReader::arg4), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg5", -1, &(a->ns1__checkReader::arg5), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__checkReader::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__checkReader(soap, tag, this, type);
}

SOAP_FMAC3 ns1__checkReader * SOAP_FMAC4 soap_in_ns1__checkReader(struct soap *soap, const char *tag, ns1__checkReader *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__checkReader *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__checkReader, sizeof(ns1__checkReader), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__checkReader)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__checkReader *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_arg21 = 1;
	size_t soap_flag_arg31 = 1;
	size_t soap_flag_arg41 = 1;
	size_t soap_flag_arg51 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->ns1__checkReader::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_arg11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg1", &(a->ns1__checkReader::arg1), "xsd:string"))
				{	soap_flag_arg11--;
					continue;
				}
			if (soap_flag_arg21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg2", &(a->ns1__checkReader::arg2), "xsd:string"))
				{	soap_flag_arg21--;
					continue;
				}
			if (soap_flag_arg31 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "arg3", &(a->ns1__checkReader::arg3), "xsd:int"))
				{	soap_flag_arg31--;
					continue;
				}
			if (soap_flag_arg41 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg4", &(a->ns1__checkReader::arg4), "xsd:string"))
				{	soap_flag_arg41--;
					continue;
				}
			if (soap_flag_arg51 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg5", &(a->ns1__checkReader::arg5), "xsd:string"))
				{	soap_flag_arg51--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__checkReader *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__checkReader, 0, sizeof(ns1__checkReader), 0, soap_copy_ns1__checkReader);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg31 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__checkReader::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__checkReader);
	if (this->soap_out(soap, tag?tag:"ns1:checkReader", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__checkReader::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__checkReader(soap, this, tag, type);
}

SOAP_FMAC3 ns1__checkReader * SOAP_FMAC4 soap_get_ns1__checkReader(struct soap *soap, ns1__checkReader *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__checkReader(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__checkReader * SOAP_FMAC2 soap_instantiate_ns1__checkReader(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__checkReader(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__checkReader, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__checkReader);
		if (size)
			*size = sizeof(ns1__checkReader);
		((ns1__checkReader*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__checkReader[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__checkReader);
		for (int i = 0; i < n; i++)
			((ns1__checkReader*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__checkReader*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__checkReader(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__checkReader %p -> %p\n", q, p));
	*(ns1__checkReader*)p = *(ns1__checkReader*)q;
}

void ns1__simpleBean::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__simpleBean::code = NULL;
	this->ns1__simpleBean::name = NULL;
	/* transient soap skipped */
}

void ns1__simpleBean::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_wstring(soap, &this->ns1__simpleBean::code);
	soap_serialize_wstring(soap, &this->ns1__simpleBean::name);
	/* transient soap skipped */
}

int ns1__simpleBean::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__simpleBean(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__simpleBean(struct soap *soap, const char *tag, int id, const ns1__simpleBean *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__simpleBean), type))
		return soap->error;
	if (soap_out_wstring(soap, "code", -1, &(a->ns1__simpleBean::code), ""))
		return soap->error;
	if (soap_out_wstring(soap, "name", -1, &(a->ns1__simpleBean::name), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__simpleBean::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__simpleBean(soap, tag, this, type);
}

SOAP_FMAC3 ns1__simpleBean * SOAP_FMAC4 soap_in_ns1__simpleBean(struct soap *soap, const char *tag, ns1__simpleBean *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__simpleBean *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__simpleBean, sizeof(ns1__simpleBean), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__simpleBean)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__simpleBean *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_code1 = 1;
	size_t soap_flag_name1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "code", &(a->ns1__simpleBean::code), "xsd:string"))
				{	soap_flag_code1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "name", &(a->ns1__simpleBean::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__simpleBean *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__simpleBean, 0, sizeof(ns1__simpleBean), 0, soap_copy_ns1__simpleBean);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__simpleBean::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__simpleBean);
	if (this->soap_out(soap, tag?tag:"ns1:simpleBean", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__simpleBean::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__simpleBean(soap, this, tag, type);
}

SOAP_FMAC3 ns1__simpleBean * SOAP_FMAC4 soap_get_ns1__simpleBean(struct soap *soap, ns1__simpleBean *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__simpleBean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__simpleBean * SOAP_FMAC2 soap_instantiate_ns1__simpleBean(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__simpleBean(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__simpleBean, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__simpleBean);
		if (size)
			*size = sizeof(ns1__simpleBean);
		((ns1__simpleBean*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__simpleBean[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__simpleBean);
		for (int i = 0; i < n; i++)
			((ns1__simpleBean*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__simpleBean*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__simpleBean(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__simpleBean %p -> %p\n", q, p));
	*(ns1__simpleBean*)p = *(ns1__simpleBean*)q;
}

void ns1__getDepsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__simpleBean(soap, &this->ns1__getDepsResponse::return_);
	/* transient soap skipped */
}

void ns1__getDepsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__simpleBean(soap, &this->ns1__getDepsResponse::return_);
	/* transient soap skipped */
}

int ns1__getDepsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getDepsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDepsResponse(struct soap *soap, const char *tag, int id, const ns1__getDepsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDepsResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__simpleBean(soap, "return", -1, &(a->ns1__getDepsResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getDepsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getDepsResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getDepsResponse * SOAP_FMAC4 soap_in_ns1__getDepsResponse(struct soap *soap, const char *tag, ns1__getDepsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getDepsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDepsResponse, sizeof(ns1__getDepsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getDepsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getDepsResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__simpleBean(soap, "return", &(a->ns1__getDepsResponse::return_), "ns1:simpleBean"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getDepsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDepsResponse, 0, sizeof(ns1__getDepsResponse), 0, soap_copy_ns1__getDepsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getDepsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getDepsResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getDepsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getDepsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getDepsResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getDepsResponse * SOAP_FMAC4 soap_get_ns1__getDepsResponse(struct soap *soap, ns1__getDepsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDepsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getDepsResponse * SOAP_FMAC2 soap_instantiate_ns1__getDepsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDepsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDepsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getDepsResponse);
		if (size)
			*size = sizeof(ns1__getDepsResponse);
		((ns1__getDepsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getDepsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getDepsResponse);
		for (int i = 0; i < n; i++)
			((ns1__getDepsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getDepsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDepsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getDepsResponse %p -> %p\n", q, p));
	*(ns1__getDepsResponse*)p = *(ns1__getDepsResponse*)q;
}

void ns1__getDeps::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getDeps::arg0 = NULL;
	this->ns1__getDeps::arg1 = NULL;
	this->ns1__getDeps::arg2 = NULL;
	/* transient soap skipped */
}

void ns1__getDeps::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getDeps::arg0);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getDeps::arg1);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getDeps::arg2);
	/* transient soap skipped */
}

int ns1__getDeps::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getDeps(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDeps(struct soap *soap, const char *tag, int id, const ns1__getDeps *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDeps), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->ns1__getDeps::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg1", -1, &(a->ns1__getDeps::arg1), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg2", -1, &(a->ns1__getDeps::arg2), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getDeps::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getDeps(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getDeps * SOAP_FMAC4 soap_in_ns1__getDeps(struct soap *soap, const char *tag, ns1__getDeps *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getDeps *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDeps, sizeof(ns1__getDeps), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getDeps)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getDeps *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_arg21 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->ns1__getDeps::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_arg11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg1", &(a->ns1__getDeps::arg1), "xsd:string"))
				{	soap_flag_arg11--;
					continue;
				}
			if (soap_flag_arg21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg2", &(a->ns1__getDeps::arg2), "xsd:string"))
				{	soap_flag_arg21--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getDeps *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDeps, 0, sizeof(ns1__getDeps), 0, soap_copy_ns1__getDeps);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getDeps::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getDeps);
	if (this->soap_out(soap, tag?tag:"ns1:getDeps", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getDeps::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getDeps(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getDeps * SOAP_FMAC4 soap_get_ns1__getDeps(struct soap *soap, ns1__getDeps *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDeps(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getDeps * SOAP_FMAC2 soap_instantiate_ns1__getDeps(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDeps(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDeps, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getDeps);
		if (size)
			*size = sizeof(ns1__getDeps);
		((ns1__getDeps*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getDeps[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getDeps);
		for (int i = 0; i < n; i++)
			((ns1__getDeps*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getDeps*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDeps(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getDeps %p -> %p\n", q, p));
	*(ns1__getDeps*)p = *(ns1__getDeps*)q;
}

void ns1__reader::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__reader::beginDate = NULL;
	this->ns1__reader::certFlag = NULL;
	this->ns1__reader::certFlagName = NULL;
	this->ns1__reader::certId = NULL;
	soap_default_float(soap, &this->ns1__reader::debt);
	this->ns1__reader::dept = NULL;
	this->ns1__reader::email = NULL;
	this->ns1__reader::endDate = NULL;
	this->ns1__reader::grade = NULL;
	this->ns1__reader::idCard = NULL;
	soap_default_int(soap, &this->ns1__reader::lendQuantity);
	this->ns1__reader::limitFlag = NULL;
	this->ns1__reader::limitFlagName = NULL;
	soap_default_int(soap, &this->ns1__reader::maxLendQuantity);
	this->ns1__reader::name = NULL;
	this->ns1__reader::readerCertId = NULL;
	this->ns1__reader::readerDept = NULL;
	this->ns1__reader::readerType = NULL;
	this->ns1__reader::registerDay = NULL;
	this->ns1__reader::sex = NULL;
	soap_default_int(soap, &this->ns1__reader::voltFlag);
	this->ns1__reader::voltFlagName = NULL;
	/* transient soap skipped */
}

void ns1__reader::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_wstring(soap, &this->ns1__reader::beginDate);
	soap_serialize_wstring(soap, &this->ns1__reader::certFlag);
	soap_serialize_wstring(soap, &this->ns1__reader::certFlagName);
	soap_serialize_wstring(soap, &this->ns1__reader::certId);
	soap_serialize_wstring(soap, &this->ns1__reader::dept);
	soap_serialize_wstring(soap, &this->ns1__reader::email);
	soap_serialize_wstring(soap, &this->ns1__reader::endDate);
	soap_serialize_wstring(soap, &this->ns1__reader::grade);
	soap_serialize_wstring(soap, &this->ns1__reader::idCard);
	soap_serialize_wstring(soap, &this->ns1__reader::limitFlag);
	soap_serialize_wstring(soap, &this->ns1__reader::limitFlagName);
	soap_serialize_wstring(soap, &this->ns1__reader::name);
	soap_serialize_wstring(soap, &this->ns1__reader::readerCertId);
	soap_serialize_wstring(soap, &this->ns1__reader::readerDept);
	soap_serialize_wstring(soap, &this->ns1__reader::readerType);
	soap_serialize_wstring(soap, &this->ns1__reader::registerDay);
	soap_serialize_wstring(soap, &this->ns1__reader::sex);
	soap_serialize_wstring(soap, &this->ns1__reader::voltFlagName);
	/* transient soap skipped */
}

int ns1__reader::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__reader(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__reader(struct soap *soap, const char *tag, int id, const ns1__reader *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__reader), type))
		return soap->error;
	if (soap_out_wstring(soap, "beginDate", -1, &(a->ns1__reader::beginDate), ""))
		return soap->error;
	if (soap_out_wstring(soap, "certFlag", -1, &(a->ns1__reader::certFlag), ""))
		return soap->error;
	if (soap_out_wstring(soap, "certFlagName", -1, &(a->ns1__reader::certFlagName), ""))
		return soap->error;
	if (soap_out_wstring(soap, "certId", -1, &(a->ns1__reader::certId), ""))
		return soap->error;
	if (soap_out_float(soap, "debt", -1, &(a->ns1__reader::debt), ""))
		return soap->error;
	if (soap_out_wstring(soap, "dept", -1, &(a->ns1__reader::dept), ""))
		return soap->error;
	if (soap_out_wstring(soap, "email", -1, &(a->ns1__reader::email), ""))
		return soap->error;
	if (soap_out_wstring(soap, "endDate", -1, &(a->ns1__reader::endDate), ""))
		return soap->error;
	if (soap_out_wstring(soap, "grade", -1, &(a->ns1__reader::grade), ""))
		return soap->error;
	if (soap_out_wstring(soap, "idCard", -1, &(a->ns1__reader::idCard), ""))
		return soap->error;
	if (soap_out_int(soap, "lendQuantity", -1, &(a->ns1__reader::lendQuantity), ""))
		return soap->error;
	if (soap_out_wstring(soap, "limitFlag", -1, &(a->ns1__reader::limitFlag), ""))
		return soap->error;
	if (soap_out_wstring(soap, "limitFlagName", -1, &(a->ns1__reader::limitFlagName), ""))
		return soap->error;
	if (soap_out_int(soap, "maxLendQuantity", -1, &(a->ns1__reader::maxLendQuantity), ""))
		return soap->error;
	if (soap_out_wstring(soap, "name", -1, &(a->ns1__reader::name), ""))
		return soap->error;
	if (soap_out_wstring(soap, "readerCertId", -1, &(a->ns1__reader::readerCertId), ""))
		return soap->error;
	if (soap_out_wstring(soap, "readerDept", -1, &(a->ns1__reader::readerDept), ""))
		return soap->error;
	if (soap_out_wstring(soap, "readerType", -1, &(a->ns1__reader::readerType), ""))
		return soap->error;
	if (soap_out_wstring(soap, "registerDay", -1, &(a->ns1__reader::registerDay), ""))
		return soap->error;
	if (soap_out_wstring(soap, "sex", -1, &(a->ns1__reader::sex), ""))
		return soap->error;
	if (soap_out_int(soap, "voltFlag", -1, &(a->ns1__reader::voltFlag), ""))
		return soap->error;
	if (soap_out_wstring(soap, "voltFlagName", -1, &(a->ns1__reader::voltFlagName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__reader::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__reader(soap, tag, this, type);
}

SOAP_FMAC3 ns1__reader * SOAP_FMAC4 soap_in_ns1__reader(struct soap *soap, const char *tag, ns1__reader *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__reader *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__reader, sizeof(ns1__reader), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__reader)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__reader *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_beginDate1 = 1;
	size_t soap_flag_certFlag1 = 1;
	size_t soap_flag_certFlagName1 = 1;
	size_t soap_flag_certId1 = 1;
	size_t soap_flag_debt1 = 1;
	size_t soap_flag_dept1 = 1;
	size_t soap_flag_email1 = 1;
	size_t soap_flag_endDate1 = 1;
	size_t soap_flag_grade1 = 1;
	size_t soap_flag_idCard1 = 1;
	size_t soap_flag_lendQuantity1 = 1;
	size_t soap_flag_limitFlag1 = 1;
	size_t soap_flag_limitFlagName1 = 1;
	size_t soap_flag_maxLendQuantity1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_readerCertId1 = 1;
	size_t soap_flag_readerDept1 = 1;
	size_t soap_flag_readerType1 = 1;
	size_t soap_flag_registerDay1 = 1;
	size_t soap_flag_sex1 = 1;
	size_t soap_flag_voltFlag1 = 1;
	size_t soap_flag_voltFlagName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_beginDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "beginDate", &(a->ns1__reader::beginDate), "xsd:string"))
				{	soap_flag_beginDate1--;
					continue;
				}
			if (soap_flag_certFlag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "certFlag", &(a->ns1__reader::certFlag), "xsd:string"))
				{	soap_flag_certFlag1--;
					continue;
				}
			if (soap_flag_certFlagName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "certFlagName", &(a->ns1__reader::certFlagName), "xsd:string"))
				{	soap_flag_certFlagName1--;
					continue;
				}
			if (soap_flag_certId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "certId", &(a->ns1__reader::certId), "xsd:string"))
				{	soap_flag_certId1--;
					continue;
				}
			if (soap_flag_debt1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "debt", &(a->ns1__reader::debt), "xsd:float"))
				{	soap_flag_debt1--;
					continue;
				}
			if (soap_flag_dept1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "dept", &(a->ns1__reader::dept), "xsd:string"))
				{	soap_flag_dept1--;
					continue;
				}
			if (soap_flag_email1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "email", &(a->ns1__reader::email), "xsd:string"))
				{	soap_flag_email1--;
					continue;
				}
			if (soap_flag_endDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "endDate", &(a->ns1__reader::endDate), "xsd:string"))
				{	soap_flag_endDate1--;
					continue;
				}
			if (soap_flag_grade1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "grade", &(a->ns1__reader::grade), "xsd:string"))
				{	soap_flag_grade1--;
					continue;
				}
			if (soap_flag_idCard1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "idCard", &(a->ns1__reader::idCard), "xsd:string"))
				{	soap_flag_idCard1--;
					continue;
				}
			if (soap_flag_lendQuantity1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "lendQuantity", &(a->ns1__reader::lendQuantity), "xsd:int"))
				{	soap_flag_lendQuantity1--;
					continue;
				}
			if (soap_flag_limitFlag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "limitFlag", &(a->ns1__reader::limitFlag), "xsd:string"))
				{	soap_flag_limitFlag1--;
					continue;
				}
			if (soap_flag_limitFlagName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "limitFlagName", &(a->ns1__reader::limitFlagName), "xsd:string"))
				{	soap_flag_limitFlagName1--;
					continue;
				}
			if (soap_flag_maxLendQuantity1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "maxLendQuantity", &(a->ns1__reader::maxLendQuantity), "xsd:int"))
				{	soap_flag_maxLendQuantity1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "name", &(a->ns1__reader::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_readerCertId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "readerCertId", &(a->ns1__reader::readerCertId), "xsd:string"))
				{	soap_flag_readerCertId1--;
					continue;
				}
			if (soap_flag_readerDept1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "readerDept", &(a->ns1__reader::readerDept), "xsd:string"))
				{	soap_flag_readerDept1--;
					continue;
				}
			if (soap_flag_readerType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "readerType", &(a->ns1__reader::readerType), "xsd:string"))
				{	soap_flag_readerType1--;
					continue;
				}
			if (soap_flag_registerDay1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "registerDay", &(a->ns1__reader::registerDay), "xsd:string"))
				{	soap_flag_registerDay1--;
					continue;
				}
			if (soap_flag_sex1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "sex", &(a->ns1__reader::sex), "xsd:string"))
				{	soap_flag_sex1--;
					continue;
				}
			if (soap_flag_voltFlag1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "voltFlag", &(a->ns1__reader::voltFlag), "xsd:int"))
				{	soap_flag_voltFlag1--;
					continue;
				}
			if (soap_flag_voltFlagName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "voltFlagName", &(a->ns1__reader::voltFlagName), "xsd:string"))
				{	soap_flag_voltFlagName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__reader *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__reader, 0, sizeof(ns1__reader), 0, soap_copy_ns1__reader);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_debt1 > 0 || soap_flag_lendQuantity1 > 0 || soap_flag_maxLendQuantity1 > 0 || soap_flag_voltFlag1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__reader::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__reader);
	if (this->soap_out(soap, tag?tag:"ns1:reader", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__reader::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__reader(soap, this, tag, type);
}

SOAP_FMAC3 ns1__reader * SOAP_FMAC4 soap_get_ns1__reader(struct soap *soap, ns1__reader *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__reader(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__reader * SOAP_FMAC2 soap_instantiate_ns1__reader(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__reader(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__reader, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__reader);
		if (size)
			*size = sizeof(ns1__reader);
		((ns1__reader*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__reader[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__reader);
		for (int i = 0; i < n; i++)
			((ns1__reader*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__reader*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__reader(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__reader %p -> %p\n", q, p));
	*(ns1__reader*)p = *(ns1__reader*)q;
}

void ns1__getReaderResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getReaderResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__getReaderResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__reader(soap, &this->ns1__getReaderResponse::return_);
	/* transient soap skipped */
}

int ns1__getReaderResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getReaderResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getReaderResponse(struct soap *soap, const char *tag, int id, const ns1__getReaderResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getReaderResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__reader(soap, "return", -1, &(a->ns1__getReaderResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getReaderResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getReaderResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getReaderResponse * SOAP_FMAC4 soap_in_ns1__getReaderResponse(struct soap *soap, const char *tag, ns1__getReaderResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getReaderResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getReaderResponse, sizeof(ns1__getReaderResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getReaderResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getReaderResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__reader(soap, "return", &(a->ns1__getReaderResponse::return_), "ns1:reader"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getReaderResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getReaderResponse, 0, sizeof(ns1__getReaderResponse), 0, soap_copy_ns1__getReaderResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getReaderResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getReaderResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getReaderResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getReaderResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getReaderResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getReaderResponse * SOAP_FMAC4 soap_get_ns1__getReaderResponse(struct soap *soap, ns1__getReaderResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getReaderResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getReaderResponse * SOAP_FMAC2 soap_instantiate_ns1__getReaderResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getReaderResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getReaderResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getReaderResponse);
		if (size)
			*size = sizeof(ns1__getReaderResponse);
		((ns1__getReaderResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getReaderResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getReaderResponse);
		for (int i = 0; i < n; i++)
			((ns1__getReaderResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getReaderResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getReaderResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getReaderResponse %p -> %p\n", q, p));
	*(ns1__getReaderResponse*)p = *(ns1__getReaderResponse*)q;
}

void ns1__getReader::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getReader::arg0 = NULL;
	this->ns1__getReader::arg1 = NULL;
	this->ns1__getReader::arg2 = NULL;
	soap_default_int(soap, &this->ns1__getReader::arg3);
	this->ns1__getReader::arg4 = NULL;
	/* transient soap skipped */
}

void ns1__getReader::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getReader::arg0);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getReader::arg1);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getReader::arg2);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getReader::arg4);
	/* transient soap skipped */
}

int ns1__getReader::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getReader(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getReader(struct soap *soap, const char *tag, int id, const ns1__getReader *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getReader), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->ns1__getReader::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg1", -1, &(a->ns1__getReader::arg1), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg2", -1, &(a->ns1__getReader::arg2), ""))
		return soap->error;
	if (soap_out_int(soap, "arg3", -1, &(a->ns1__getReader::arg3), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg4", -1, &(a->ns1__getReader::arg4), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getReader::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getReader(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getReader * SOAP_FMAC4 soap_in_ns1__getReader(struct soap *soap, const char *tag, ns1__getReader *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getReader *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getReader, sizeof(ns1__getReader), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getReader)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getReader *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_arg21 = 1;
	size_t soap_flag_arg31 = 1;
	size_t soap_flag_arg41 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->ns1__getReader::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_arg11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg1", &(a->ns1__getReader::arg1), "xsd:string"))
				{	soap_flag_arg11--;
					continue;
				}
			if (soap_flag_arg21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg2", &(a->ns1__getReader::arg2), "xsd:string"))
				{	soap_flag_arg21--;
					continue;
				}
			if (soap_flag_arg31 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "arg3", &(a->ns1__getReader::arg3), "xsd:int"))
				{	soap_flag_arg31--;
					continue;
				}
			if (soap_flag_arg41 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg4", &(a->ns1__getReader::arg4), "xsd:string"))
				{	soap_flag_arg41--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getReader *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getReader, 0, sizeof(ns1__getReader), 0, soap_copy_ns1__getReader);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg31 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__getReader::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getReader);
	if (this->soap_out(soap, tag?tag:"ns1:getReader", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getReader::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getReader(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getReader * SOAP_FMAC4 soap_get_ns1__getReader(struct soap *soap, ns1__getReader *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getReader(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getReader * SOAP_FMAC2 soap_instantiate_ns1__getReader(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getReader(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getReader, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getReader);
		if (size)
			*size = sizeof(ns1__getReader);
		((ns1__getReader*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getReader[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getReader);
		for (int i = 0; i < n; i++)
			((ns1__getReader*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getReader*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getReader(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getReader %p -> %p\n", q, p));
	*(ns1__getReader*)p = *(ns1__getReader*)q;
}

void ns1__circ::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__circ::attachment = NULL;
	this->ns1__circ::author = NULL;
	this->ns1__circ::barcode = NULL;
	this->ns1__circ::certId = NULL;
	this->ns1__circ::dueDay = NULL;
	this->ns1__circ::lendDate = NULL;
	this->ns1__circ::location = NULL;
	this->ns1__circ::marcRecNo = NULL;
	this->ns1__circ::name = NULL;
	soap_default_float(soap, &this->ns1__circ::price);
	this->ns1__circ::propNo = NULL;
	soap_default_int(soap, &this->ns1__circ::renewTimes);
	this->ns1__circ::title = NULL;
	/* transient soap skipped */
}

void ns1__circ::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_wstring(soap, &this->ns1__circ::attachment);
	soap_serialize_wstring(soap, &this->ns1__circ::author);
	soap_serialize_wstring(soap, &this->ns1__circ::barcode);
	soap_serialize_wstring(soap, &this->ns1__circ::certId);
	soap_serialize_wstring(soap, &this->ns1__circ::dueDay);
	soap_serialize_wstring(soap, &this->ns1__circ::lendDate);
	soap_serialize_wstring(soap, &this->ns1__circ::location);
	soap_serialize_wstring(soap, &this->ns1__circ::marcRecNo);
	soap_serialize_wstring(soap, &this->ns1__circ::name);
	soap_serialize_wstring(soap, &this->ns1__circ::propNo);
	soap_serialize_wstring(soap, &this->ns1__circ::title);
	/* transient soap skipped */
}

int ns1__circ::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__circ(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__circ(struct soap *soap, const char *tag, int id, const ns1__circ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__circ), type))
		return soap->error;
	if (soap_out_wstring(soap, "attachment", -1, &(a->ns1__circ::attachment), ""))
		return soap->error;
	if (soap_out_wstring(soap, "author", -1, &(a->ns1__circ::author), ""))
		return soap->error;
	if (soap_out_wstring(soap, "barcode", -1, &(a->ns1__circ::barcode), ""))
		return soap->error;
	if (soap_out_wstring(soap, "certId", -1, &(a->ns1__circ::certId), ""))
		return soap->error;
	if (soap_out_wstring(soap, "dueDay", -1, &(a->ns1__circ::dueDay), ""))
		return soap->error;
	if (soap_out_wstring(soap, "lendDate", -1, &(a->ns1__circ::lendDate), ""))
		return soap->error;
	if (soap_out_wstring(soap, "location", -1, &(a->ns1__circ::location), ""))
		return soap->error;
	if (soap_out_wstring(soap, "marcRecNo", -1, &(a->ns1__circ::marcRecNo), ""))
		return soap->error;
	if (soap_out_wstring(soap, "name", -1, &(a->ns1__circ::name), ""))
		return soap->error;
	if (soap_out_float(soap, "price", -1, &(a->ns1__circ::price), ""))
		return soap->error;
	if (soap_out_wstring(soap, "propNo", -1, &(a->ns1__circ::propNo), ""))
		return soap->error;
	if (soap_out_int(soap, "renewTimes", -1, &(a->ns1__circ::renewTimes), ""))
		return soap->error;
	if (soap_out_wstring(soap, "title", -1, &(a->ns1__circ::title), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__circ::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__circ(soap, tag, this, type);
}

SOAP_FMAC3 ns1__circ * SOAP_FMAC4 soap_in_ns1__circ(struct soap *soap, const char *tag, ns1__circ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__circ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__circ, sizeof(ns1__circ), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__circ)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__circ *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_attachment1 = 1;
	size_t soap_flag_author1 = 1;
	size_t soap_flag_barcode1 = 1;
	size_t soap_flag_certId1 = 1;
	size_t soap_flag_dueDay1 = 1;
	size_t soap_flag_lendDate1 = 1;
	size_t soap_flag_location1 = 1;
	size_t soap_flag_marcRecNo1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_price1 = 1;
	size_t soap_flag_propNo1 = 1;
	size_t soap_flag_renewTimes1 = 1;
	size_t soap_flag_title1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_attachment1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "attachment", &(a->ns1__circ::attachment), "xsd:string"))
				{	soap_flag_attachment1--;
					continue;
				}
			if (soap_flag_author1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "author", &(a->ns1__circ::author), "xsd:string"))
				{	soap_flag_author1--;
					continue;
				}
			if (soap_flag_barcode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "barcode", &(a->ns1__circ::barcode), "xsd:string"))
				{	soap_flag_barcode1--;
					continue;
				}
			if (soap_flag_certId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "certId", &(a->ns1__circ::certId), "xsd:string"))
				{	soap_flag_certId1--;
					continue;
				}
			if (soap_flag_dueDay1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "dueDay", &(a->ns1__circ::dueDay), "xsd:string"))
				{	soap_flag_dueDay1--;
					continue;
				}
			if (soap_flag_lendDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "lendDate", &(a->ns1__circ::lendDate), "xsd:string"))
				{	soap_flag_lendDate1--;
					continue;
				}
			if (soap_flag_location1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "location", &(a->ns1__circ::location), "xsd:string"))
				{	soap_flag_location1--;
					continue;
				}
			if (soap_flag_marcRecNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "marcRecNo", &(a->ns1__circ::marcRecNo), "xsd:string"))
				{	soap_flag_marcRecNo1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "name", &(a->ns1__circ::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_price1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "price", &(a->ns1__circ::price), "xsd:float"))
				{	soap_flag_price1--;
					continue;
				}
			if (soap_flag_propNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "propNo", &(a->ns1__circ::propNo), "xsd:string"))
				{	soap_flag_propNo1--;
					continue;
				}
			if (soap_flag_renewTimes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "renewTimes", &(a->ns1__circ::renewTimes), "xsd:int"))
				{	soap_flag_renewTimes1--;
					continue;
				}
			if (soap_flag_title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "title", &(a->ns1__circ::title), "xsd:string"))
				{	soap_flag_title1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__circ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__circ, 0, sizeof(ns1__circ), 0, soap_copy_ns1__circ);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_price1 > 0 || soap_flag_renewTimes1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__circ::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__circ);
	if (this->soap_out(soap, tag?tag:"ns1:circ", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__circ::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__circ(soap, this, tag, type);
}

SOAP_FMAC3 ns1__circ * SOAP_FMAC4 soap_get_ns1__circ(struct soap *soap, ns1__circ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__circ(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__circ * SOAP_FMAC2 soap_instantiate_ns1__circ(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__circ(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__circ, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__circ);
		if (size)
			*size = sizeof(ns1__circ);
		((ns1__circ*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__circ[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__circ);
		for (int i = 0; i < n; i++)
			((ns1__circ*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__circ*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__circ(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__circ %p -> %p\n", q, p));
	*(ns1__circ*)p = *(ns1__circ*)q;
}

void ns1__getCircsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__circ(soap, &this->ns1__getCircsResponse::return_);
	/* transient soap skipped */
}

void ns1__getCircsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__circ(soap, &this->ns1__getCircsResponse::return_);
	/* transient soap skipped */
}

int ns1__getCircsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getCircsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getCircsResponse(struct soap *soap, const char *tag, int id, const ns1__getCircsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getCircsResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__circ(soap, "return", -1, &(a->ns1__getCircsResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getCircsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getCircsResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getCircsResponse * SOAP_FMAC4 soap_in_ns1__getCircsResponse(struct soap *soap, const char *tag, ns1__getCircsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getCircsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getCircsResponse, sizeof(ns1__getCircsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getCircsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getCircsResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__circ(soap, "return", &(a->ns1__getCircsResponse::return_), "ns1:circ"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getCircsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getCircsResponse, 0, sizeof(ns1__getCircsResponse), 0, soap_copy_ns1__getCircsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getCircsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getCircsResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getCircsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getCircsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getCircsResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getCircsResponse * SOAP_FMAC4 soap_get_ns1__getCircsResponse(struct soap *soap, ns1__getCircsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getCircsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getCircsResponse * SOAP_FMAC2 soap_instantiate_ns1__getCircsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getCircsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getCircsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getCircsResponse);
		if (size)
			*size = sizeof(ns1__getCircsResponse);
		((ns1__getCircsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getCircsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getCircsResponse);
		for (int i = 0; i < n; i++)
			((ns1__getCircsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getCircsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getCircsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getCircsResponse %p -> %p\n", q, p));
	*(ns1__getCircsResponse*)p = *(ns1__getCircsResponse*)q;
}

void ns1__getCircs::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getCircs::arg0 = NULL;
	this->ns1__getCircs::arg1 = NULL;
	this->ns1__getCircs::arg2 = NULL;
	this->ns1__getCircs::arg3 = NULL;
	/* transient soap skipped */
}

void ns1__getCircs::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getCircs::arg0);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getCircs::arg1);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getCircs::arg2);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getCircs::arg3);
	/* transient soap skipped */
}

int ns1__getCircs::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getCircs(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getCircs(struct soap *soap, const char *tag, int id, const ns1__getCircs *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getCircs), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->ns1__getCircs::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg1", -1, &(a->ns1__getCircs::arg1), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg2", -1, &(a->ns1__getCircs::arg2), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg3", -1, &(a->ns1__getCircs::arg3), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getCircs::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getCircs(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getCircs * SOAP_FMAC4 soap_in_ns1__getCircs(struct soap *soap, const char *tag, ns1__getCircs *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getCircs *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getCircs, sizeof(ns1__getCircs), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getCircs)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getCircs *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_arg21 = 1;
	size_t soap_flag_arg31 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->ns1__getCircs::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_arg11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg1", &(a->ns1__getCircs::arg1), "xsd:string"))
				{	soap_flag_arg11--;
					continue;
				}
			if (soap_flag_arg21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg2", &(a->ns1__getCircs::arg2), "xsd:string"))
				{	soap_flag_arg21--;
					continue;
				}
			if (soap_flag_arg31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg3", &(a->ns1__getCircs::arg3), "xsd:string"))
				{	soap_flag_arg31--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getCircs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getCircs, 0, sizeof(ns1__getCircs), 0, soap_copy_ns1__getCircs);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getCircs::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getCircs);
	if (this->soap_out(soap, tag?tag:"ns1:getCircs", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getCircs::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getCircs(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getCircs * SOAP_FMAC4 soap_get_ns1__getCircs(struct soap *soap, ns1__getCircs *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getCircs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getCircs * SOAP_FMAC2 soap_instantiate_ns1__getCircs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getCircs(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getCircs, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getCircs);
		if (size)
			*size = sizeof(ns1__getCircs);
		((ns1__getCircs*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getCircs[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getCircs);
		for (int i = 0; i < n; i++)
			((ns1__getCircs*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getCircs*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getCircs(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getCircs %p -> %p\n", q, p));
	*(ns1__getCircs*)p = *(ns1__getCircs*)q;
}

void ns1__exceedFineResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void ns1__exceedFineResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__exceedFineResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__exceedFineResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__exceedFineResponse(struct soap *soap, const char *tag, int id, const ns1__exceedFineResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__exceedFineResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__exceedFineResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__exceedFineResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__exceedFineResponse * SOAP_FMAC4 soap_in_ns1__exceedFineResponse(struct soap *soap, const char *tag, ns1__exceedFineResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__exceedFineResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__exceedFineResponse, sizeof(ns1__exceedFineResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__exceedFineResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__exceedFineResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__exceedFineResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__exceedFineResponse, 0, sizeof(ns1__exceedFineResponse), 0, soap_copy_ns1__exceedFineResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__exceedFineResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__exceedFineResponse);
	if (this->soap_out(soap, tag?tag:"ns1:exceedFineResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__exceedFineResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__exceedFineResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__exceedFineResponse * SOAP_FMAC4 soap_get_ns1__exceedFineResponse(struct soap *soap, ns1__exceedFineResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__exceedFineResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__exceedFineResponse * SOAP_FMAC2 soap_instantiate_ns1__exceedFineResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__exceedFineResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__exceedFineResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__exceedFineResponse);
		if (size)
			*size = sizeof(ns1__exceedFineResponse);
		((ns1__exceedFineResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__exceedFineResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__exceedFineResponse);
		for (int i = 0; i < n; i++)
			((ns1__exceedFineResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__exceedFineResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__exceedFineResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__exceedFineResponse %p -> %p\n", q, p));
	*(ns1__exceedFineResponse*)p = *(ns1__exceedFineResponse*)q;
}

void ns1__exceedFine::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__exceedFine::arg0 = NULL;
	this->ns1__exceedFine::arg1 = NULL;
	this->ns1__exceedFine::arg2 = NULL;
	this->ns1__exceedFine::arg3 = NULL;
	this->ns1__exceedFine::arg4 = NULL;
	this->ns1__exceedFine::arg5 = NULL;
	this->ns1__exceedFine::arg6 = NULL;
	this->ns1__exceedFine::arg7 = NULL;
	this->ns1__exceedFine::arg8 = NULL;
	this->ns1__exceedFine::arg9 = NULL;
	/* transient soap skipped */
}

void ns1__exceedFine::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__exceedFine::arg0);
	soap_serialize_PointerTostd__string(soap, &this->ns1__exceedFine::arg1);
	soap_serialize_PointerTostd__string(soap, &this->ns1__exceedFine::arg2);
	soap_serialize_PointerTostd__string(soap, &this->ns1__exceedFine::arg3);
	soap_serialize_PointerTostd__string(soap, &this->ns1__exceedFine::arg4);
	soap_serialize_PointerTostd__string(soap, &this->ns1__exceedFine::arg5);
	soap_serialize_PointerTostd__string(soap, &this->ns1__exceedFine::arg6);
	soap_serialize_PointerTostd__string(soap, &this->ns1__exceedFine::arg7);
	soap_serialize_PointerTostd__string(soap, &this->ns1__exceedFine::arg8);
	soap_serialize_PointerTostd__string(soap, &this->ns1__exceedFine::arg9);
	/* transient soap skipped */
}

int ns1__exceedFine::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__exceedFine(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__exceedFine(struct soap *soap, const char *tag, int id, const ns1__exceedFine *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__exceedFine), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->ns1__exceedFine::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg1", -1, &(a->ns1__exceedFine::arg1), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg2", -1, &(a->ns1__exceedFine::arg2), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg3", -1, &(a->ns1__exceedFine::arg3), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg4", -1, &(a->ns1__exceedFine::arg4), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg5", -1, &(a->ns1__exceedFine::arg5), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg6", -1, &(a->ns1__exceedFine::arg6), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg7", -1, &(a->ns1__exceedFine::arg7), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg8", -1, &(a->ns1__exceedFine::arg8), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg9", -1, &(a->ns1__exceedFine::arg9), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__exceedFine::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__exceedFine(soap, tag, this, type);
}

SOAP_FMAC3 ns1__exceedFine * SOAP_FMAC4 soap_in_ns1__exceedFine(struct soap *soap, const char *tag, ns1__exceedFine *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__exceedFine *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__exceedFine, sizeof(ns1__exceedFine), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__exceedFine)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__exceedFine *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_arg21 = 1;
	size_t soap_flag_arg31 = 1;
	size_t soap_flag_arg41 = 1;
	size_t soap_flag_arg51 = 1;
	size_t soap_flag_arg61 = 1;
	size_t soap_flag_arg71 = 1;
	size_t soap_flag_arg81 = 1;
	size_t soap_flag_arg91 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->ns1__exceedFine::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_arg11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg1", &(a->ns1__exceedFine::arg1), "xsd:string"))
				{	soap_flag_arg11--;
					continue;
				}
			if (soap_flag_arg21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg2", &(a->ns1__exceedFine::arg2), "xsd:string"))
				{	soap_flag_arg21--;
					continue;
				}
			if (soap_flag_arg31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg3", &(a->ns1__exceedFine::arg3), "xsd:string"))
				{	soap_flag_arg31--;
					continue;
				}
			if (soap_flag_arg41 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg4", &(a->ns1__exceedFine::arg4), "xsd:string"))
				{	soap_flag_arg41--;
					continue;
				}
			if (soap_flag_arg51 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg5", &(a->ns1__exceedFine::arg5), "xsd:string"))
				{	soap_flag_arg51--;
					continue;
				}
			if (soap_flag_arg61 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg6", &(a->ns1__exceedFine::arg6), "xsd:string"))
				{	soap_flag_arg61--;
					continue;
				}
			if (soap_flag_arg71 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg7", &(a->ns1__exceedFine::arg7), "xsd:string"))
				{	soap_flag_arg71--;
					continue;
				}
			if (soap_flag_arg81 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg8", &(a->ns1__exceedFine::arg8), "xsd:string"))
				{	soap_flag_arg81--;
					continue;
				}
			if (soap_flag_arg91 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg9", &(a->ns1__exceedFine::arg9), "xsd:string"))
				{	soap_flag_arg91--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__exceedFine *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__exceedFine, 0, sizeof(ns1__exceedFine), 0, soap_copy_ns1__exceedFine);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__exceedFine::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__exceedFine);
	if (this->soap_out(soap, tag?tag:"ns1:exceedFine", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__exceedFine::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__exceedFine(soap, this, tag, type);
}

SOAP_FMAC3 ns1__exceedFine * SOAP_FMAC4 soap_get_ns1__exceedFine(struct soap *soap, ns1__exceedFine *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__exceedFine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__exceedFine * SOAP_FMAC2 soap_instantiate_ns1__exceedFine(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__exceedFine(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__exceedFine, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__exceedFine);
		if (size)
			*size = sizeof(ns1__exceedFine);
		((ns1__exceedFine*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__exceedFine[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__exceedFine);
		for (int i = 0; i < n; i++)
			((ns1__exceedFine*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__exceedFine*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__exceedFine(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__exceedFine %p -> %p\n", q, p));
	*(ns1__exceedFine*)p = *(ns1__exceedFine*)q;
}

void ns1__voltFineResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void ns1__voltFineResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__voltFineResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__voltFineResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__voltFineResponse(struct soap *soap, const char *tag, int id, const ns1__voltFineResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__voltFineResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__voltFineResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__voltFineResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__voltFineResponse * SOAP_FMAC4 soap_in_ns1__voltFineResponse(struct soap *soap, const char *tag, ns1__voltFineResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__voltFineResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__voltFineResponse, sizeof(ns1__voltFineResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__voltFineResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__voltFineResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__voltFineResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__voltFineResponse, 0, sizeof(ns1__voltFineResponse), 0, soap_copy_ns1__voltFineResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__voltFineResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__voltFineResponse);
	if (this->soap_out(soap, tag?tag:"ns1:voltFineResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__voltFineResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__voltFineResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__voltFineResponse * SOAP_FMAC4 soap_get_ns1__voltFineResponse(struct soap *soap, ns1__voltFineResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__voltFineResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__voltFineResponse * SOAP_FMAC2 soap_instantiate_ns1__voltFineResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__voltFineResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__voltFineResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__voltFineResponse);
		if (size)
			*size = sizeof(ns1__voltFineResponse);
		((ns1__voltFineResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__voltFineResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__voltFineResponse);
		for (int i = 0; i < n; i++)
			((ns1__voltFineResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__voltFineResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__voltFineResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__voltFineResponse %p -> %p\n", q, p));
	*(ns1__voltFineResponse*)p = *(ns1__voltFineResponse*)q;
}

void ns1__voltFine::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__voltFine::arg0 = NULL;
	this->ns1__voltFine::arg1 = NULL;
	this->ns1__voltFine::arg2 = NULL;
	this->ns1__voltFine::arg3 = NULL;
	this->ns1__voltFine::arg4 = NULL;
	soap_default_float(soap, &this->ns1__voltFine::arg5);
	this->ns1__voltFine::arg6 = NULL;
	this->ns1__voltFine::arg7 = NULL;
	this->ns1__voltFine::arg8 = NULL;
	soap_default_int(soap, &this->ns1__voltFine::arg9);
	this->ns1__voltFine::arg10 = NULL;
	/* transient soap skipped */
}

void ns1__voltFine::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__voltFine::arg0);
	soap_serialize_PointerTostd__string(soap, &this->ns1__voltFine::arg1);
	soap_serialize_PointerTostd__string(soap, &this->ns1__voltFine::arg2);
	soap_serialize_PointerTostd__string(soap, &this->ns1__voltFine::arg3);
	soap_serialize_PointerTostd__string(soap, &this->ns1__voltFine::arg4);
	soap_serialize_PointerTostd__string(soap, &this->ns1__voltFine::arg6);
	soap_serialize_PointerTostd__string(soap, &this->ns1__voltFine::arg7);
	soap_serialize_PointerTostd__string(soap, &this->ns1__voltFine::arg8);
	soap_serialize_PointerTostd__string(soap, &this->ns1__voltFine::arg10);
	/* transient soap skipped */
}

int ns1__voltFine::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__voltFine(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__voltFine(struct soap *soap, const char *tag, int id, const ns1__voltFine *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__voltFine), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->ns1__voltFine::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg1", -1, &(a->ns1__voltFine::arg1), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg2", -1, &(a->ns1__voltFine::arg2), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg3", -1, &(a->ns1__voltFine::arg3), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg4", -1, &(a->ns1__voltFine::arg4), ""))
		return soap->error;
	if (soap_out_float(soap, "arg5", -1, &(a->ns1__voltFine::arg5), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg6", -1, &(a->ns1__voltFine::arg6), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg7", -1, &(a->ns1__voltFine::arg7), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg8", -1, &(a->ns1__voltFine::arg8), ""))
		return soap->error;
	if (soap_out_int(soap, "arg9", -1, &(a->ns1__voltFine::arg9), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg10", -1, &(a->ns1__voltFine::arg10), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__voltFine::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__voltFine(soap, tag, this, type);
}

SOAP_FMAC3 ns1__voltFine * SOAP_FMAC4 soap_in_ns1__voltFine(struct soap *soap, const char *tag, ns1__voltFine *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__voltFine *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__voltFine, sizeof(ns1__voltFine), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__voltFine)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__voltFine *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_arg21 = 1;
	size_t soap_flag_arg31 = 1;
	size_t soap_flag_arg41 = 1;
	size_t soap_flag_arg51 = 1;
	size_t soap_flag_arg61 = 1;
	size_t soap_flag_arg71 = 1;
	size_t soap_flag_arg81 = 1;
	size_t soap_flag_arg91 = 1;
	size_t soap_flag_arg101 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->ns1__voltFine::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_arg11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg1", &(a->ns1__voltFine::arg1), "xsd:string"))
				{	soap_flag_arg11--;
					continue;
				}
			if (soap_flag_arg21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg2", &(a->ns1__voltFine::arg2), "xsd:string"))
				{	soap_flag_arg21--;
					continue;
				}
			if (soap_flag_arg31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg3", &(a->ns1__voltFine::arg3), "xsd:string"))
				{	soap_flag_arg31--;
					continue;
				}
			if (soap_flag_arg41 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg4", &(a->ns1__voltFine::arg4), "xsd:string"))
				{	soap_flag_arg41--;
					continue;
				}
			if (soap_flag_arg51 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "arg5", &(a->ns1__voltFine::arg5), "xsd:float"))
				{	soap_flag_arg51--;
					continue;
				}
			if (soap_flag_arg61 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg6", &(a->ns1__voltFine::arg6), "xsd:string"))
				{	soap_flag_arg61--;
					continue;
				}
			if (soap_flag_arg71 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg7", &(a->ns1__voltFine::arg7), "xsd:string"))
				{	soap_flag_arg71--;
					continue;
				}
			if (soap_flag_arg81 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg8", &(a->ns1__voltFine::arg8), "xsd:string"))
				{	soap_flag_arg81--;
					continue;
				}
			if (soap_flag_arg91 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "arg9", &(a->ns1__voltFine::arg9), "xsd:int"))
				{	soap_flag_arg91--;
					continue;
				}
			if (soap_flag_arg101 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg10", &(a->ns1__voltFine::arg10), "xsd:string"))
				{	soap_flag_arg101--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__voltFine *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__voltFine, 0, sizeof(ns1__voltFine), 0, soap_copy_ns1__voltFine);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg51 > 0 || soap_flag_arg91 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__voltFine::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__voltFine);
	if (this->soap_out(soap, tag?tag:"ns1:voltFine", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__voltFine::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__voltFine(soap, this, tag, type);
}

SOAP_FMAC3 ns1__voltFine * SOAP_FMAC4 soap_get_ns1__voltFine(struct soap *soap, ns1__voltFine *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__voltFine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__voltFine * SOAP_FMAC2 soap_instantiate_ns1__voltFine(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__voltFine(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__voltFine, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__voltFine);
		if (size)
			*size = sizeof(ns1__voltFine);
		((ns1__voltFine*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__voltFine[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__voltFine);
		for (int i = 0; i < n; i++)
			((ns1__voltFine*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__voltFine*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__voltFine(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__voltFine %p -> %p\n", q, p));
	*(ns1__voltFine*)p = *(ns1__voltFine*)q;
}

void ns1__logoutResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__logoutResponse::return_);
	/* transient soap skipped */
}

void ns1__logoutResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__logoutResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__logoutResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__logoutResponse(struct soap *soap, const char *tag, int id, const ns1__logoutResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__logoutResponse), type))
		return soap->error;
	if (soap_out_int(soap, "return", -1, &(a->ns1__logoutResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__logoutResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__logoutResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__logoutResponse * SOAP_FMAC4 soap_in_ns1__logoutResponse(struct soap *soap, const char *tag, ns1__logoutResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__logoutResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__logoutResponse, sizeof(ns1__logoutResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__logoutResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__logoutResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "return", &(a->ns1__logoutResponse::return_), "xsd:int"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__logoutResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__logoutResponse, 0, sizeof(ns1__logoutResponse), 0, soap_copy_ns1__logoutResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__logoutResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__logoutResponse);
	if (this->soap_out(soap, tag?tag:"ns1:logoutResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__logoutResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__logoutResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__logoutResponse * SOAP_FMAC4 soap_get_ns1__logoutResponse(struct soap *soap, ns1__logoutResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__logoutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__logoutResponse * SOAP_FMAC2 soap_instantiate_ns1__logoutResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__logoutResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__logoutResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__logoutResponse);
		if (size)
			*size = sizeof(ns1__logoutResponse);
		((ns1__logoutResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__logoutResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__logoutResponse);
		for (int i = 0; i < n; i++)
			((ns1__logoutResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__logoutResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__logoutResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__logoutResponse %p -> %p\n", q, p));
	*(ns1__logoutResponse*)p = *(ns1__logoutResponse*)q;
}

void ns1__logout::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__logout::arg0 = NULL;
	this->ns1__logout::arg1 = NULL;
	this->ns1__logout::arg2 = NULL;
	soap_default_int(soap, &this->ns1__logout::arg3);
	this->ns1__logout::arg4 = NULL;
	soap_default_int(soap, &this->ns1__logout::arg5);
	soap_default_int(soap, &this->ns1__logout::arg6);
	/* transient soap skipped */
}

void ns1__logout::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__logout::arg0);
	soap_serialize_PointerTostd__string(soap, &this->ns1__logout::arg1);
	soap_serialize_PointerTostd__string(soap, &this->ns1__logout::arg2);
	soap_serialize_PointerTostd__string(soap, &this->ns1__logout::arg4);
	/* transient soap skipped */
}

int ns1__logout::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__logout(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__logout(struct soap *soap, const char *tag, int id, const ns1__logout *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__logout), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->ns1__logout::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg1", -1, &(a->ns1__logout::arg1), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg2", -1, &(a->ns1__logout::arg2), ""))
		return soap->error;
	if (soap_out_int(soap, "arg3", -1, &(a->ns1__logout::arg3), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg4", -1, &(a->ns1__logout::arg4), ""))
		return soap->error;
	if (soap_out_int(soap, "arg5", -1, &(a->ns1__logout::arg5), ""))
		return soap->error;
	if (soap_out_int(soap, "arg6", -1, &(a->ns1__logout::arg6), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__logout::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__logout(soap, tag, this, type);
}

SOAP_FMAC3 ns1__logout * SOAP_FMAC4 soap_in_ns1__logout(struct soap *soap, const char *tag, ns1__logout *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__logout *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__logout, sizeof(ns1__logout), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__logout)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__logout *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_arg21 = 1;
	size_t soap_flag_arg31 = 1;
	size_t soap_flag_arg41 = 1;
	size_t soap_flag_arg51 = 1;
	size_t soap_flag_arg61 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->ns1__logout::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_arg11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg1", &(a->ns1__logout::arg1), "xsd:string"))
				{	soap_flag_arg11--;
					continue;
				}
			if (soap_flag_arg21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg2", &(a->ns1__logout::arg2), "xsd:string"))
				{	soap_flag_arg21--;
					continue;
				}
			if (soap_flag_arg31 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "arg3", &(a->ns1__logout::arg3), "xsd:int"))
				{	soap_flag_arg31--;
					continue;
				}
			if (soap_flag_arg41 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg4", &(a->ns1__logout::arg4), "xsd:string"))
				{	soap_flag_arg41--;
					continue;
				}
			if (soap_flag_arg51 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "arg5", &(a->ns1__logout::arg5), "xsd:int"))
				{	soap_flag_arg51--;
					continue;
				}
			if (soap_flag_arg61 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "arg6", &(a->ns1__logout::arg6), "xsd:int"))
				{	soap_flag_arg61--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__logout *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__logout, 0, sizeof(ns1__logout), 0, soap_copy_ns1__logout);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg31 > 0 || soap_flag_arg51 > 0 || soap_flag_arg61 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__logout::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__logout);
	if (this->soap_out(soap, tag?tag:"ns1:logout", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__logout::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__logout(soap, this, tag, type);
}

SOAP_FMAC3 ns1__logout * SOAP_FMAC4 soap_get_ns1__logout(struct soap *soap, ns1__logout *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__logout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__logout * SOAP_FMAC2 soap_instantiate_ns1__logout(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__logout(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__logout, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__logout);
		if (size)
			*size = sizeof(ns1__logout);
		((ns1__logout*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__logout[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__logout);
		for (int i = 0; i < n; i++)
			((ns1__logout*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__logout*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__logout(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__logout %p -> %p\n", q, p));
	*(ns1__logout*)p = *(ns1__logout*)q;
}

void ns1__getPregArrivalsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__arrival(soap, &this->ns1__getPregArrivalsResponse::return_);
	/* transient soap skipped */
}

void ns1__getPregArrivalsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__arrival(soap, &this->ns1__getPregArrivalsResponse::return_);
	/* transient soap skipped */
}

int ns1__getPregArrivalsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getPregArrivalsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getPregArrivalsResponse(struct soap *soap, const char *tag, int id, const ns1__getPregArrivalsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getPregArrivalsResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__arrival(soap, "return", -1, &(a->ns1__getPregArrivalsResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getPregArrivalsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getPregArrivalsResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getPregArrivalsResponse * SOAP_FMAC4 soap_in_ns1__getPregArrivalsResponse(struct soap *soap, const char *tag, ns1__getPregArrivalsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getPregArrivalsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getPregArrivalsResponse, sizeof(ns1__getPregArrivalsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getPregArrivalsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getPregArrivalsResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__arrival(soap, "return", &(a->ns1__getPregArrivalsResponse::return_), "ns1:arrival"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getPregArrivalsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getPregArrivalsResponse, 0, sizeof(ns1__getPregArrivalsResponse), 0, soap_copy_ns1__getPregArrivalsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getPregArrivalsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getPregArrivalsResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getPregArrivalsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getPregArrivalsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getPregArrivalsResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getPregArrivalsResponse * SOAP_FMAC4 soap_get_ns1__getPregArrivalsResponse(struct soap *soap, ns1__getPregArrivalsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getPregArrivalsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getPregArrivalsResponse * SOAP_FMAC2 soap_instantiate_ns1__getPregArrivalsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getPregArrivalsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getPregArrivalsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getPregArrivalsResponse);
		if (size)
			*size = sizeof(ns1__getPregArrivalsResponse);
		((ns1__getPregArrivalsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getPregArrivalsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getPregArrivalsResponse);
		for (int i = 0; i < n; i++)
			((ns1__getPregArrivalsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getPregArrivalsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getPregArrivalsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getPregArrivalsResponse %p -> %p\n", q, p));
	*(ns1__getPregArrivalsResponse*)p = *(ns1__getPregArrivalsResponse*)q;
}

void ns1__getPregArrivals::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getPregArrivals::arg0 = NULL;
	this->ns1__getPregArrivals::arg1 = NULL;
	this->ns1__getPregArrivals::arg2 = NULL;
	this->ns1__getPregArrivals::arg3 = NULL;
	/* transient soap skipped */
}

void ns1__getPregArrivals::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getPregArrivals::arg0);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getPregArrivals::arg1);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getPregArrivals::arg2);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getPregArrivals::arg3);
	/* transient soap skipped */
}

int ns1__getPregArrivals::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getPregArrivals(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getPregArrivals(struct soap *soap, const char *tag, int id, const ns1__getPregArrivals *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getPregArrivals), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->ns1__getPregArrivals::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg1", -1, &(a->ns1__getPregArrivals::arg1), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg2", -1, &(a->ns1__getPregArrivals::arg2), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg3", -1, &(a->ns1__getPregArrivals::arg3), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getPregArrivals::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getPregArrivals(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getPregArrivals * SOAP_FMAC4 soap_in_ns1__getPregArrivals(struct soap *soap, const char *tag, ns1__getPregArrivals *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getPregArrivals *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getPregArrivals, sizeof(ns1__getPregArrivals), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getPregArrivals)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getPregArrivals *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_arg21 = 1;
	size_t soap_flag_arg31 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->ns1__getPregArrivals::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_arg11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg1", &(a->ns1__getPregArrivals::arg1), "xsd:string"))
				{	soap_flag_arg11--;
					continue;
				}
			if (soap_flag_arg21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg2", &(a->ns1__getPregArrivals::arg2), "xsd:string"))
				{	soap_flag_arg21--;
					continue;
				}
			if (soap_flag_arg31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg3", &(a->ns1__getPregArrivals::arg3), "xsd:string"))
				{	soap_flag_arg31--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getPregArrivals *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getPregArrivals, 0, sizeof(ns1__getPregArrivals), 0, soap_copy_ns1__getPregArrivals);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getPregArrivals::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getPregArrivals);
	if (this->soap_out(soap, tag?tag:"ns1:getPregArrivals", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getPregArrivals::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getPregArrivals(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getPregArrivals * SOAP_FMAC4 soap_get_ns1__getPregArrivals(struct soap *soap, ns1__getPregArrivals *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getPregArrivals(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getPregArrivals * SOAP_FMAC2 soap_instantiate_ns1__getPregArrivals(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getPregArrivals(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getPregArrivals, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getPregArrivals);
		if (size)
			*size = sizeof(ns1__getPregArrivals);
		((ns1__getPregArrivals*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getPregArrivals[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getPregArrivals);
		for (int i = 0; i < n; i++)
			((ns1__getPregArrivals*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getPregArrivals*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getPregArrivals(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getPregArrivals %p -> %p\n", q, p));
	*(ns1__getPregArrivals*)p = *(ns1__getPregArrivals*)q;
}

void ns1__arrival::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__arrival::arrivalDate = NULL;
	this->ns1__arrival::author = NULL;
	this->ns1__arrival::barcode = NULL;
	this->ns1__arrival::callNo = NULL;
	this->ns1__arrival::certId = NULL;
	this->ns1__arrival::keepEndDate = NULL;
	this->ns1__arrival::marcRecNo = NULL;
	this->ns1__arrival::name = NULL;
	this->ns1__arrival::propNo = NULL;
	this->ns1__arrival::takeLocation = NULL;
	this->ns1__arrival::title = NULL;
	/* transient soap skipped */
}

void ns1__arrival::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_wstring(soap, &this->ns1__arrival::arrivalDate);
	soap_serialize_wstring(soap, &this->ns1__arrival::author);
	soap_serialize_wstring(soap, &this->ns1__arrival::barcode);
	soap_serialize_wstring(soap, &this->ns1__arrival::callNo);
	soap_serialize_wstring(soap, &this->ns1__arrival::certId);
	soap_serialize_wstring(soap, &this->ns1__arrival::keepEndDate);
	soap_serialize_wstring(soap, &this->ns1__arrival::marcRecNo);
	soap_serialize_wstring(soap, &this->ns1__arrival::name);
	soap_serialize_wstring(soap, &this->ns1__arrival::propNo);
	soap_serialize_wstring(soap, &this->ns1__arrival::takeLocation);
	soap_serialize_wstring(soap, &this->ns1__arrival::title);
	/* transient soap skipped */
}

int ns1__arrival::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__arrival(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__arrival(struct soap *soap, const char *tag, int id, const ns1__arrival *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__arrival), type))
		return soap->error;
	if (soap_out_wstring(soap, "arrivalDate", -1, &(a->ns1__arrival::arrivalDate), ""))
		return soap->error;
	if (soap_out_wstring(soap, "author", -1, &(a->ns1__arrival::author), ""))
		return soap->error;
	if (soap_out_wstring(soap, "barcode", -1, &(a->ns1__arrival::barcode), ""))
		return soap->error;
	if (soap_out_wstring(soap, "callNo", -1, &(a->ns1__arrival::callNo), ""))
		return soap->error;
	if (soap_out_wstring(soap, "certId", -1, &(a->ns1__arrival::certId), ""))
		return soap->error;
	if (soap_out_wstring(soap, "keepEndDate", -1, &(a->ns1__arrival::keepEndDate), ""))
		return soap->error;
	if (soap_out_wstring(soap, "marcRecNo", -1, &(a->ns1__arrival::marcRecNo), ""))
		return soap->error;
	if (soap_out_wstring(soap, "name", -1, &(a->ns1__arrival::name), ""))
		return soap->error;
	if (soap_out_wstring(soap, "propNo", -1, &(a->ns1__arrival::propNo), ""))
		return soap->error;
	if (soap_out_wstring(soap, "takeLocation", -1, &(a->ns1__arrival::takeLocation), ""))
		return soap->error;
	if (soap_out_wstring(soap, "title", -1, &(a->ns1__arrival::title), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__arrival::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__arrival(soap, tag, this, type);
}

SOAP_FMAC3 ns1__arrival * SOAP_FMAC4 soap_in_ns1__arrival(struct soap *soap, const char *tag, ns1__arrival *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__arrival *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__arrival, sizeof(ns1__arrival), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__arrival)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__arrival *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arrivalDate1 = 1;
	size_t soap_flag_author1 = 1;
	size_t soap_flag_barcode1 = 1;
	size_t soap_flag_callNo1 = 1;
	size_t soap_flag_certId1 = 1;
	size_t soap_flag_keepEndDate1 = 1;
	size_t soap_flag_marcRecNo1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_propNo1 = 1;
	size_t soap_flag_takeLocation1 = 1;
	size_t soap_flag_title1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arrivalDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "arrivalDate", &(a->ns1__arrival::arrivalDate), "xsd:string"))
				{	soap_flag_arrivalDate1--;
					continue;
				}
			if (soap_flag_author1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "author", &(a->ns1__arrival::author), "xsd:string"))
				{	soap_flag_author1--;
					continue;
				}
			if (soap_flag_barcode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "barcode", &(a->ns1__arrival::barcode), "xsd:string"))
				{	soap_flag_barcode1--;
					continue;
				}
			if (soap_flag_callNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "callNo", &(a->ns1__arrival::callNo), "xsd:string"))
				{	soap_flag_callNo1--;
					continue;
				}
			if (soap_flag_certId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "certId", &(a->ns1__arrival::certId), "xsd:string"))
				{	soap_flag_certId1--;
					continue;
				}
			if (soap_flag_keepEndDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "keepEndDate", &(a->ns1__arrival::keepEndDate), "xsd:string"))
				{	soap_flag_keepEndDate1--;
					continue;
				}
			if (soap_flag_marcRecNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "marcRecNo", &(a->ns1__arrival::marcRecNo), "xsd:string"))
				{	soap_flag_marcRecNo1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "name", &(a->ns1__arrival::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_propNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "propNo", &(a->ns1__arrival::propNo), "xsd:string"))
				{	soap_flag_propNo1--;
					continue;
				}
			if (soap_flag_takeLocation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "takeLocation", &(a->ns1__arrival::takeLocation), "xsd:string"))
				{	soap_flag_takeLocation1--;
					continue;
				}
			if (soap_flag_title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "title", &(a->ns1__arrival::title), "xsd:string"))
				{	soap_flag_title1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__arrival *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__arrival, 0, sizeof(ns1__arrival), 0, soap_copy_ns1__arrival);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__arrival::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__arrival);
	if (this->soap_out(soap, tag?tag:"ns1:arrival", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__arrival::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__arrival(soap, this, tag, type);
}

SOAP_FMAC3 ns1__arrival * SOAP_FMAC4 soap_get_ns1__arrival(struct soap *soap, ns1__arrival *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__arrival(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__arrival * SOAP_FMAC2 soap_instantiate_ns1__arrival(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__arrival(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__arrival, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__arrival);
		if (size)
			*size = sizeof(ns1__arrival);
		((ns1__arrival*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__arrival[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__arrival);
		for (int i = 0; i < n; i++)
			((ns1__arrival*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__arrival*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__arrival(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__arrival %p -> %p\n", q, p));
	*(ns1__arrival*)p = *(ns1__arrival*)q;
}

void ns1__getRelegateArrivalsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__arrival(soap, &this->ns1__getRelegateArrivalsResponse::return_);
	/* transient soap skipped */
}

void ns1__getRelegateArrivalsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__arrival(soap, &this->ns1__getRelegateArrivalsResponse::return_);
	/* transient soap skipped */
}

int ns1__getRelegateArrivalsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getRelegateArrivalsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getRelegateArrivalsResponse(struct soap *soap, const char *tag, int id, const ns1__getRelegateArrivalsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getRelegateArrivalsResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__arrival(soap, "return", -1, &(a->ns1__getRelegateArrivalsResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getRelegateArrivalsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getRelegateArrivalsResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getRelegateArrivalsResponse * SOAP_FMAC4 soap_in_ns1__getRelegateArrivalsResponse(struct soap *soap, const char *tag, ns1__getRelegateArrivalsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getRelegateArrivalsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getRelegateArrivalsResponse, sizeof(ns1__getRelegateArrivalsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getRelegateArrivalsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getRelegateArrivalsResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__arrival(soap, "return", &(a->ns1__getRelegateArrivalsResponse::return_), "ns1:arrival"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getRelegateArrivalsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getRelegateArrivalsResponse, 0, sizeof(ns1__getRelegateArrivalsResponse), 0, soap_copy_ns1__getRelegateArrivalsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getRelegateArrivalsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getRelegateArrivalsResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getRelegateArrivalsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getRelegateArrivalsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getRelegateArrivalsResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getRelegateArrivalsResponse * SOAP_FMAC4 soap_get_ns1__getRelegateArrivalsResponse(struct soap *soap, ns1__getRelegateArrivalsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getRelegateArrivalsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getRelegateArrivalsResponse * SOAP_FMAC2 soap_instantiate_ns1__getRelegateArrivalsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getRelegateArrivalsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getRelegateArrivalsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getRelegateArrivalsResponse);
		if (size)
			*size = sizeof(ns1__getRelegateArrivalsResponse);
		((ns1__getRelegateArrivalsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getRelegateArrivalsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getRelegateArrivalsResponse);
		for (int i = 0; i < n; i++)
			((ns1__getRelegateArrivalsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getRelegateArrivalsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getRelegateArrivalsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getRelegateArrivalsResponse %p -> %p\n", q, p));
	*(ns1__getRelegateArrivalsResponse*)p = *(ns1__getRelegateArrivalsResponse*)q;
}

void ns1__getRelegateArrivals::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getRelegateArrivals::arg0 = NULL;
	this->ns1__getRelegateArrivals::arg1 = NULL;
	this->ns1__getRelegateArrivals::arg2 = NULL;
	this->ns1__getRelegateArrivals::arg3 = NULL;
	/* transient soap skipped */
}

void ns1__getRelegateArrivals::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getRelegateArrivals::arg0);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getRelegateArrivals::arg1);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getRelegateArrivals::arg2);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getRelegateArrivals::arg3);
	/* transient soap skipped */
}

int ns1__getRelegateArrivals::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getRelegateArrivals(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getRelegateArrivals(struct soap *soap, const char *tag, int id, const ns1__getRelegateArrivals *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getRelegateArrivals), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->ns1__getRelegateArrivals::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg1", -1, &(a->ns1__getRelegateArrivals::arg1), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg2", -1, &(a->ns1__getRelegateArrivals::arg2), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg3", -1, &(a->ns1__getRelegateArrivals::arg3), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getRelegateArrivals::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getRelegateArrivals(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getRelegateArrivals * SOAP_FMAC4 soap_in_ns1__getRelegateArrivals(struct soap *soap, const char *tag, ns1__getRelegateArrivals *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getRelegateArrivals *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getRelegateArrivals, sizeof(ns1__getRelegateArrivals), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getRelegateArrivals)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getRelegateArrivals *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_arg21 = 1;
	size_t soap_flag_arg31 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->ns1__getRelegateArrivals::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_arg11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg1", &(a->ns1__getRelegateArrivals::arg1), "xsd:string"))
				{	soap_flag_arg11--;
					continue;
				}
			if (soap_flag_arg21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg2", &(a->ns1__getRelegateArrivals::arg2), "xsd:string"))
				{	soap_flag_arg21--;
					continue;
				}
			if (soap_flag_arg31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg3", &(a->ns1__getRelegateArrivals::arg3), "xsd:string"))
				{	soap_flag_arg31--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getRelegateArrivals *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getRelegateArrivals, 0, sizeof(ns1__getRelegateArrivals), 0, soap_copy_ns1__getRelegateArrivals);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getRelegateArrivals::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getRelegateArrivals);
	if (this->soap_out(soap, tag?tag:"ns1:getRelegateArrivals", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getRelegateArrivals::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getRelegateArrivals(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getRelegateArrivals * SOAP_FMAC4 soap_get_ns1__getRelegateArrivals(struct soap *soap, ns1__getRelegateArrivals *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getRelegateArrivals(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getRelegateArrivals * SOAP_FMAC2 soap_instantiate_ns1__getRelegateArrivals(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getRelegateArrivals(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getRelegateArrivals, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getRelegateArrivals);
		if (size)
			*size = sizeof(ns1__getRelegateArrivals);
		((ns1__getRelegateArrivals*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getRelegateArrivals[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getRelegateArrivals);
		for (int i = 0; i < n; i++)
			((ns1__getRelegateArrivals*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getRelegateArrivals*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getRelegateArrivals(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getRelegateArrivals %p -> %p\n", q, p));
	*(ns1__getRelegateArrivals*)p = *(ns1__getRelegateArrivals*)q;
}

void ns1__item::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__item::attachment = NULL;
	this->ns1__item::barCode = NULL;
	this->ns1__item::callNo = NULL;
	this->ns1__item::carrierName = NULL;
	this->ns1__item::location = NULL;
	this->ns1__item::locationDept = NULL;
	this->ns1__item::marcRecNo = NULL;
	soap_default_float(soap, &this->ns1__item::price);
	this->ns1__item::propNo = NULL;
	this->ns1__item::state = NULL;
	this->ns1__item::volPeri = NULL;
	this->ns1__item::year = NULL;
	/* transient soap skipped */
}

void ns1__item::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_wstring(soap, &this->ns1__item::attachment);
	soap_serialize_wstring(soap, &this->ns1__item::barCode);
	soap_serialize_wstring(soap, &this->ns1__item::callNo);
	soap_serialize_wstring(soap, &this->ns1__item::carrierName);
	soap_serialize_wstring(soap, &this->ns1__item::location);
	soap_serialize_wstring(soap, &this->ns1__item::locationDept);
	soap_serialize_wstring(soap, &this->ns1__item::marcRecNo);
	soap_serialize_wstring(soap, &this->ns1__item::propNo);
	soap_serialize_wstring(soap, &this->ns1__item::state);
	soap_serialize_wstring(soap, &this->ns1__item::volPeri);
	soap_serialize_wstring(soap, &this->ns1__item::year);
	/* transient soap skipped */
}

int ns1__item::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__item(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__item(struct soap *soap, const char *tag, int id, const ns1__item *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__item), type))
		return soap->error;
	if (soap_out_wstring(soap, "attachment", -1, &(a->ns1__item::attachment), ""))
		return soap->error;
	if (soap_out_wstring(soap, "barCode", -1, &(a->ns1__item::barCode), ""))
		return soap->error;
	if (soap_out_wstring(soap, "callNo", -1, &(a->ns1__item::callNo), ""))
		return soap->error;
	if (soap_out_wstring(soap, "carrierName", -1, &(a->ns1__item::carrierName), ""))
		return soap->error;
	if (soap_out_wstring(soap, "location", -1, &(a->ns1__item::location), ""))
		return soap->error;
	if (soap_out_wstring(soap, "locationDept", -1, &(a->ns1__item::locationDept), ""))
		return soap->error;
	if (soap_out_wstring(soap, "marcRecNo", -1, &(a->ns1__item::marcRecNo), ""))
		return soap->error;
	if (soap_out_float(soap, "price", -1, &(a->ns1__item::price), ""))
		return soap->error;
	if (soap_out_wstring(soap, "propNo", -1, &(a->ns1__item::propNo), ""))
		return soap->error;
	if (soap_out_wstring(soap, "state", -1, &(a->ns1__item::state), ""))
		return soap->error;
	if (soap_out_wstring(soap, "volPeri", -1, &(a->ns1__item::volPeri), ""))
		return soap->error;
	if (soap_out_wstring(soap, "year", -1, &(a->ns1__item::year), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__item::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__item(soap, tag, this, type);
}

SOAP_FMAC3 ns1__item * SOAP_FMAC4 soap_in_ns1__item(struct soap *soap, const char *tag, ns1__item *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__item *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__item, sizeof(ns1__item), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__item)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__item *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_attachment1 = 1;
	size_t soap_flag_barCode1 = 1;
	size_t soap_flag_callNo1 = 1;
	size_t soap_flag_carrierName1 = 1;
	size_t soap_flag_location1 = 1;
	size_t soap_flag_locationDept1 = 1;
	size_t soap_flag_marcRecNo1 = 1;
	size_t soap_flag_price1 = 1;
	size_t soap_flag_propNo1 = 1;
	size_t soap_flag_state1 = 1;
	size_t soap_flag_volPeri1 = 1;
	size_t soap_flag_year1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_attachment1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "attachment", &(a->ns1__item::attachment), "xsd:string"))
				{	soap_flag_attachment1--;
					continue;
				}
			if (soap_flag_barCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "barCode", &(a->ns1__item::barCode), "xsd:string"))
				{	soap_flag_barCode1--;
					continue;
				}
			if (soap_flag_callNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "callNo", &(a->ns1__item::callNo), "xsd:string"))
				{	soap_flag_callNo1--;
					continue;
				}
			if (soap_flag_carrierName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "carrierName", &(a->ns1__item::carrierName), "xsd:string"))
				{	soap_flag_carrierName1--;
					continue;
				}
			if (soap_flag_location1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "location", &(a->ns1__item::location), "xsd:string"))
				{	soap_flag_location1--;
					continue;
				}
			if (soap_flag_locationDept1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "locationDept", &(a->ns1__item::locationDept), "xsd:string"))
				{	soap_flag_locationDept1--;
					continue;
				}
			if (soap_flag_marcRecNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "marcRecNo", &(a->ns1__item::marcRecNo), "xsd:string"))
				{	soap_flag_marcRecNo1--;
					continue;
				}
			if (soap_flag_price1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "price", &(a->ns1__item::price), "xsd:float"))
				{	soap_flag_price1--;
					continue;
				}
			if (soap_flag_propNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "propNo", &(a->ns1__item::propNo), "xsd:string"))
				{	soap_flag_propNo1--;
					continue;
				}
			if (soap_flag_state1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "state", &(a->ns1__item::state), "xsd:string"))
				{	soap_flag_state1--;
					continue;
				}
			if (soap_flag_volPeri1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "volPeri", &(a->ns1__item::volPeri), "xsd:string"))
				{	soap_flag_volPeri1--;
					continue;
				}
			if (soap_flag_year1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "year", &(a->ns1__item::year), "xsd:string"))
				{	soap_flag_year1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__item *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__item, 0, sizeof(ns1__item), 0, soap_copy_ns1__item);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_price1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__item::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__item);
	if (this->soap_out(soap, tag?tag:"ns1:item", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__item::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__item(soap, this, tag, type);
}

SOAP_FMAC3 ns1__item * SOAP_FMAC4 soap_get_ns1__item(struct soap *soap, ns1__item *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__item(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__item * SOAP_FMAC2 soap_instantiate_ns1__item(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__item(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__item, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__item);
		if (size)
			*size = sizeof(ns1__item);
		((ns1__item*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__item[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__item);
		for (int i = 0; i < n; i++)
			((ns1__item*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__item*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__item(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__item %p -> %p\n", q, p));
	*(ns1__item*)p = *(ns1__item*)q;
}

void ns1__getItemsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__item(soap, &this->ns1__getItemsResponse::return_);
	/* transient soap skipped */
}

void ns1__getItemsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__item(soap, &this->ns1__getItemsResponse::return_);
	/* transient soap skipped */
}

int ns1__getItemsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getItemsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getItemsResponse(struct soap *soap, const char *tag, int id, const ns1__getItemsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getItemsResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__item(soap, "return", -1, &(a->ns1__getItemsResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getItemsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getItemsResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getItemsResponse * SOAP_FMAC4 soap_in_ns1__getItemsResponse(struct soap *soap, const char *tag, ns1__getItemsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getItemsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getItemsResponse, sizeof(ns1__getItemsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getItemsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getItemsResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__item(soap, "return", &(a->ns1__getItemsResponse::return_), "ns1:item"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getItemsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getItemsResponse, 0, sizeof(ns1__getItemsResponse), 0, soap_copy_ns1__getItemsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getItemsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getItemsResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getItemsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getItemsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getItemsResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getItemsResponse * SOAP_FMAC4 soap_get_ns1__getItemsResponse(struct soap *soap, ns1__getItemsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getItemsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getItemsResponse * SOAP_FMAC2 soap_instantiate_ns1__getItemsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getItemsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getItemsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getItemsResponse);
		if (size)
			*size = sizeof(ns1__getItemsResponse);
		((ns1__getItemsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getItemsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getItemsResponse);
		for (int i = 0; i < n; i++)
			((ns1__getItemsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getItemsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getItemsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getItemsResponse %p -> %p\n", q, p));
	*(ns1__getItemsResponse*)p = *(ns1__getItemsResponse*)q;
}

void ns1__getItems::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getItems::arg0 = NULL;
	this->ns1__getItems::arg1 = NULL;
	this->ns1__getItems::arg2 = NULL;
	this->ns1__getItems::arg3 = NULL;
	/* transient soap skipped */
}

void ns1__getItems::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getItems::arg0);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getItems::arg1);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getItems::arg2);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getItems::arg3);
	/* transient soap skipped */
}

int ns1__getItems::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getItems(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getItems(struct soap *soap, const char *tag, int id, const ns1__getItems *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getItems), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->ns1__getItems::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg1", -1, &(a->ns1__getItems::arg1), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg2", -1, &(a->ns1__getItems::arg2), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg3", -1, &(a->ns1__getItems::arg3), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getItems::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getItems(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getItems * SOAP_FMAC4 soap_in_ns1__getItems(struct soap *soap, const char *tag, ns1__getItems *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getItems *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getItems, sizeof(ns1__getItems), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getItems)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getItems *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_arg21 = 1;
	size_t soap_flag_arg31 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->ns1__getItems::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_arg11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg1", &(a->ns1__getItems::arg1), "xsd:string"))
				{	soap_flag_arg11--;
					continue;
				}
			if (soap_flag_arg21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg2", &(a->ns1__getItems::arg2), "xsd:string"))
				{	soap_flag_arg21--;
					continue;
				}
			if (soap_flag_arg31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg3", &(a->ns1__getItems::arg3), "xsd:string"))
				{	soap_flag_arg31--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getItems *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getItems, 0, sizeof(ns1__getItems), 0, soap_copy_ns1__getItems);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getItems::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getItems);
	if (this->soap_out(soap, tag?tag:"ns1:getItems", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getItems::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getItems(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getItems * SOAP_FMAC4 soap_get_ns1__getItems(struct soap *soap, ns1__getItems *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getItems(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getItems * SOAP_FMAC2 soap_instantiate_ns1__getItems(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getItems(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getItems, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getItems);
		if (size)
			*size = sizeof(ns1__getItems);
		((ns1__getItems*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getItems[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getItems);
		for (int i = 0; i < n; i++)
			((ns1__getItems*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getItems*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getItems(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getItems %p -> %p\n", q, p));
	*(ns1__getItems*)p = *(ns1__getItems*)q;
}

void ns1__SystemException::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__SystemException::message = NULL;
	/* transient soap skipped */
}

void ns1__SystemException::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_wstring(soap, &this->ns1__SystemException::message);
	/* transient soap skipped */
}

int ns1__SystemException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SystemException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SystemException(struct soap *soap, const char *tag, int id, const ns1__SystemException *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SystemException), type))
		return soap->error;
	if (soap_out_wstring(soap, "message", -1, &(a->ns1__SystemException::message), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__SystemException::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SystemException(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SystemException * SOAP_FMAC4 soap_in_ns1__SystemException(struct soap *soap, const char *tag, ns1__SystemException *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SystemException *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SystemException, sizeof(ns1__SystemException), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SystemException)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SystemException *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "message", &(a->ns1__SystemException::message), "xsd:string"))
				{	soap_flag_message1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SystemException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SystemException, 0, sizeof(ns1__SystemException), 0, soap_copy_ns1__SystemException);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__SystemException::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SystemException);
	if (this->soap_out(soap, tag?tag:"ns1:SystemException", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SystemException::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SystemException(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SystemException * SOAP_FMAC4 soap_get_ns1__SystemException(struct soap *soap, ns1__SystemException *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SystemException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__SystemException * SOAP_FMAC2 soap_instantiate_ns1__SystemException(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SystemException(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SystemException, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__SystemException);
		if (size)
			*size = sizeof(ns1__SystemException);
		((ns1__SystemException*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__SystemException[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__SystemException);
		for (int i = 0; i < n; i++)
			((ns1__SystemException*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SystemException*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SystemException(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SystemException %p -> %p\n", q, p));
	*(ns1__SystemException*)p = *(ns1__SystemException*)q;
}

void ns1__NoAuthorityException::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__NoAuthorityException::message = NULL;
	/* transient soap skipped */
}

void ns1__NoAuthorityException::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_wstring(soap, &this->ns1__NoAuthorityException::message);
	/* transient soap skipped */
}

int ns1__NoAuthorityException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__NoAuthorityException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__NoAuthorityException(struct soap *soap, const char *tag, int id, const ns1__NoAuthorityException *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__NoAuthorityException), type))
		return soap->error;
	if (soap_out_wstring(soap, "message", -1, &(a->ns1__NoAuthorityException::message), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__NoAuthorityException::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__NoAuthorityException(soap, tag, this, type);
}

SOAP_FMAC3 ns1__NoAuthorityException * SOAP_FMAC4 soap_in_ns1__NoAuthorityException(struct soap *soap, const char *tag, ns1__NoAuthorityException *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__NoAuthorityException *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__NoAuthorityException, sizeof(ns1__NoAuthorityException), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__NoAuthorityException)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__NoAuthorityException *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "message", &(a->ns1__NoAuthorityException::message), "xsd:string"))
				{	soap_flag_message1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__NoAuthorityException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__NoAuthorityException, 0, sizeof(ns1__NoAuthorityException), 0, soap_copy_ns1__NoAuthorityException);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__NoAuthorityException::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__NoAuthorityException);
	if (this->soap_out(soap, tag?tag:"ns1:NoAuthorityException", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__NoAuthorityException::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__NoAuthorityException(soap, this, tag, type);
}

SOAP_FMAC3 ns1__NoAuthorityException * SOAP_FMAC4 soap_get_ns1__NoAuthorityException(struct soap *soap, ns1__NoAuthorityException *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__NoAuthorityException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__NoAuthorityException * SOAP_FMAC2 soap_instantiate_ns1__NoAuthorityException(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__NoAuthorityException(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__NoAuthorityException, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__NoAuthorityException);
		if (size)
			*size = sizeof(ns1__NoAuthorityException);
		((ns1__NoAuthorityException*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__NoAuthorityException[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__NoAuthorityException);
		for (int i = 0; i < n; i++)
			((ns1__NoAuthorityException*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__NoAuthorityException*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__NoAuthorityException(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__NoAuthorityException %p -> %p\n", q, p));
	*(ns1__NoAuthorityException*)p = *(ns1__NoAuthorityException*)q;
}

void ns1__book::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__book::author = NULL;
	this->ns1__book::barcode = NULL;
	this->ns1__book::callNo = NULL;
	this->ns1__book::locationName = NULL;
	soap_default_float(soap, &this->ns1__book::price);
	this->ns1__book::propNo = NULL;
	this->ns1__book::publisher = NULL;
	this->ns1__book::state = NULL;
	this->ns1__book::stateName = NULL;
	this->ns1__book::title = NULL;
	/* transient soap skipped */
}

void ns1__book::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_wstring(soap, &this->ns1__book::author);
	soap_serialize_wstring(soap, &this->ns1__book::barcode);
	soap_serialize_wstring(soap, &this->ns1__book::callNo);
	soap_serialize_wstring(soap, &this->ns1__book::locationName);
	soap_serialize_wstring(soap, &this->ns1__book::propNo);
	soap_serialize_wstring(soap, &this->ns1__book::publisher);
	soap_serialize_wstring(soap, &this->ns1__book::state);
	soap_serialize_wstring(soap, &this->ns1__book::stateName);
	soap_serialize_wstring(soap, &this->ns1__book::title);
	/* transient soap skipped */
}

int ns1__book::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__book(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__book(struct soap *soap, const char *tag, int id, const ns1__book *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__book), type))
		return soap->error;
	if (soap_out_wstring(soap, "author", -1, &(a->ns1__book::author), ""))
		return soap->error;
	if (soap_out_wstring(soap, "barcode", -1, &(a->ns1__book::barcode), ""))
		return soap->error;
	if (soap_out_wstring(soap, "callNo", -1, &(a->ns1__book::callNo), ""))
		return soap->error;
	if (soap_out_wstring(soap, "locationName", -1, &(a->ns1__book::locationName), ""))
		return soap->error;
	if (soap_out_float(soap, "price", -1, &(a->ns1__book::price), ""))
		return soap->error;
	if (soap_out_wstring(soap, "propNo", -1, &(a->ns1__book::propNo), ""))
		return soap->error;
	if (soap_out_wstring(soap, "publisher", -1, &(a->ns1__book::publisher), ""))
		return soap->error;
	if (soap_out_wstring(soap, "state", -1, &(a->ns1__book::state), ""))
		return soap->error;
	if (soap_out_wstring(soap, "stateName", -1, &(a->ns1__book::stateName), ""))
		return soap->error;
	if (soap_out_wstring(soap, "title", -1, &(a->ns1__book::title), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__book::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__book(soap, tag, this, type);
}

SOAP_FMAC3 ns1__book * SOAP_FMAC4 soap_in_ns1__book(struct soap *soap, const char *tag, ns1__book *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__book *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__book, sizeof(ns1__book), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__book)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__book *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_author1 = 1;
	size_t soap_flag_barcode1 = 1;
	size_t soap_flag_callNo1 = 1;
	size_t soap_flag_locationName1 = 1;
	size_t soap_flag_price1 = 1;
	size_t soap_flag_propNo1 = 1;
	size_t soap_flag_publisher1 = 1;
	size_t soap_flag_state1 = 1;
	size_t soap_flag_stateName1 = 1;
	size_t soap_flag_title1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_author1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "author", &(a->ns1__book::author), "xsd:string"))
				{	soap_flag_author1--;
					continue;
				}
			if (soap_flag_barcode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "barcode", &(a->ns1__book::barcode), "xsd:string"))
				{	soap_flag_barcode1--;
					continue;
				}
			if (soap_flag_callNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "callNo", &(a->ns1__book::callNo), "xsd:string"))
				{	soap_flag_callNo1--;
					continue;
				}
			if (soap_flag_locationName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "locationName", &(a->ns1__book::locationName), "xsd:string"))
				{	soap_flag_locationName1--;
					continue;
				}
			if (soap_flag_price1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "price", &(a->ns1__book::price), "xsd:float"))
				{	soap_flag_price1--;
					continue;
				}
			if (soap_flag_propNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "propNo", &(a->ns1__book::propNo), "xsd:string"))
				{	soap_flag_propNo1--;
					continue;
				}
			if (soap_flag_publisher1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "publisher", &(a->ns1__book::publisher), "xsd:string"))
				{	soap_flag_publisher1--;
					continue;
				}
			if (soap_flag_state1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "state", &(a->ns1__book::state), "xsd:string"))
				{	soap_flag_state1--;
					continue;
				}
			if (soap_flag_stateName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "stateName", &(a->ns1__book::stateName), "xsd:string"))
				{	soap_flag_stateName1--;
					continue;
				}
			if (soap_flag_title1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wstring(soap, "title", &(a->ns1__book::title), "xsd:string"))
				{	soap_flag_title1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__book *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__book, 0, sizeof(ns1__book), 0, soap_copy_ns1__book);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_price1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__book::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__book);
	if (this->soap_out(soap, tag?tag:"ns1:book", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__book::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__book(soap, this, tag, type);
}

SOAP_FMAC3 ns1__book * SOAP_FMAC4 soap_get_ns1__book(struct soap *soap, ns1__book *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__book(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__book * SOAP_FMAC2 soap_instantiate_ns1__book(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__book(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__book, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__book);
		if (size)
			*size = sizeof(ns1__book);
		((ns1__book*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__book[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__book);
		for (int i = 0; i < n; i++)
			((ns1__book*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__book*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__book(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__book %p -> %p\n", q, p));
	*(ns1__book*)p = *(ns1__book*)q;
}

void ns1__getBookResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getBookResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__getBookResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__book(soap, &this->ns1__getBookResponse::return_);
	/* transient soap skipped */
}

int ns1__getBookResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getBookResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getBookResponse(struct soap *soap, const char *tag, int id, const ns1__getBookResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getBookResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__book(soap, "return", -1, &(a->ns1__getBookResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getBookResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getBookResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getBookResponse * SOAP_FMAC4 soap_in_ns1__getBookResponse(struct soap *soap, const char *tag, ns1__getBookResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getBookResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getBookResponse, sizeof(ns1__getBookResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getBookResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getBookResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__book(soap, "return", &(a->ns1__getBookResponse::return_), "ns1:book"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getBookResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getBookResponse, 0, sizeof(ns1__getBookResponse), 0, soap_copy_ns1__getBookResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getBookResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getBookResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getBookResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getBookResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getBookResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getBookResponse * SOAP_FMAC4 soap_get_ns1__getBookResponse(struct soap *soap, ns1__getBookResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getBookResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getBookResponse * SOAP_FMAC2 soap_instantiate_ns1__getBookResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getBookResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getBookResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getBookResponse);
		if (size)
			*size = sizeof(ns1__getBookResponse);
		((ns1__getBookResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getBookResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getBookResponse);
		for (int i = 0; i < n; i++)
			((ns1__getBookResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getBookResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getBookResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getBookResponse %p -> %p\n", q, p));
	*(ns1__getBookResponse*)p = *(ns1__getBookResponse*)q;
}

void ns1__getBook::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getBook::arg0 = NULL;
	this->ns1__getBook::arg1 = NULL;
	this->ns1__getBook::arg2 = NULL;
	soap_default_int(soap, &this->ns1__getBook::arg3);
	this->ns1__getBook::arg4 = NULL;
	/* transient soap skipped */
}

void ns1__getBook::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getBook::arg0);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getBook::arg1);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getBook::arg2);
	soap_serialize_PointerTostd__string(soap, &this->ns1__getBook::arg4);
	/* transient soap skipped */
}

int ns1__getBook::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getBook(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getBook(struct soap *soap, const char *tag, int id, const ns1__getBook *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getBook), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg0", -1, &(a->ns1__getBook::arg0), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg1", -1, &(a->ns1__getBook::arg1), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg2", -1, &(a->ns1__getBook::arg2), ""))
		return soap->error;
	if (soap_out_int(soap, "arg3", -1, &(a->ns1__getBook::arg3), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "arg4", -1, &(a->ns1__getBook::arg4), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getBook::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getBook(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getBook * SOAP_FMAC4 soap_in_ns1__getBook(struct soap *soap, const char *tag, ns1__getBook *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getBook *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getBook, sizeof(ns1__getBook), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getBook)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getBook *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	size_t soap_flag_arg11 = 1;
	size_t soap_flag_arg21 = 1;
	size_t soap_flag_arg31 = 1;
	size_t soap_flag_arg41 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg0", &(a->ns1__getBook::arg0), "xsd:string"))
				{	soap_flag_arg01--;
					continue;
				}
			if (soap_flag_arg11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg1", &(a->ns1__getBook::arg1), "xsd:string"))
				{	soap_flag_arg11--;
					continue;
				}
			if (soap_flag_arg21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg2", &(a->ns1__getBook::arg2), "xsd:string"))
				{	soap_flag_arg21--;
					continue;
				}
			if (soap_flag_arg31 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "arg3", &(a->ns1__getBook::arg3), "xsd:int"))
				{	soap_flag_arg31--;
					continue;
				}
			if (soap_flag_arg41 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "arg4", &(a->ns1__getBook::arg4), "xsd:string"))
				{	soap_flag_arg41--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getBook *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getBook, 0, sizeof(ns1__getBook), 0, soap_copy_ns1__getBook);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_arg31 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__getBook::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getBook);
	if (this->soap_out(soap, tag?tag:"ns1:getBook", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getBook::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getBook(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getBook * SOAP_FMAC4 soap_get_ns1__getBook(struct soap *soap, ns1__getBook *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getBook(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getBook * SOAP_FMAC2 soap_instantiate_ns1__getBook(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getBook(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getBook, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getBook);
		if (size)
			*size = sizeof(ns1__getBook);
		((ns1__getBook*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__getBook[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getBook);
		for (int i = 0; i < n; i++)
			((ns1__getBook*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getBook*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getBook(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getBook %p -> %p\n", q, p));
	*(ns1__getBook*)p = *(ns1__getBook*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getAccounts1(struct soap *soap, struct __ns1__getAccounts1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getAccounts1_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getAccounts1(struct soap *soap, const struct __ns1__getAccounts1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getAccounts1(soap, &a->ns1__getAccounts1_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getAccounts1(struct soap *soap, const char *tag, int id, const struct __ns1__getAccounts1 *a, const char *type)
{
	if (soap_out_PointerTons1__getAccounts1(soap, "ns1:getAccounts1", -1, &a->ns1__getAccounts1_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAccounts1 * SOAP_FMAC4 soap_in___ns1__getAccounts1(struct soap *soap, const char *tag, struct __ns1__getAccounts1 *a, const char *type)
{
	size_t soap_flag_ns1__getAccounts1_ = 1;
	short soap_flag;
	a = (struct __ns1__getAccounts1 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getAccounts1, sizeof(struct __ns1__getAccounts1), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getAccounts1(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getAccounts1_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getAccounts1(soap, "ns1:getAccounts1", &a->ns1__getAccounts1_, "ns1:getAccounts1"))
				{	soap_flag_ns1__getAccounts1_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getAccounts1(struct soap *soap, const struct __ns1__getAccounts1 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getAccounts1(soap, tag?tag:"-ns1:getAccounts1", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAccounts1 * SOAP_FMAC4 soap_get___ns1__getAccounts1(struct soap *soap, struct __ns1__getAccounts1 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getAccounts1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getAccounts1 * SOAP_FMAC2 soap_instantiate___ns1__getAccounts1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getAccounts1(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getAccounts1, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getAccounts1);
		if (size)
			*size = sizeof(struct __ns1__getAccounts1);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getAccounts1[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getAccounts1);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getAccounts1*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getAccounts1(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getAccounts1 %p -> %p\n", q, p));
	*(struct __ns1__getAccounts1*)p = *(struct __ns1__getAccounts1*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getDeps(struct soap *soap, struct __ns1__getDeps *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getDeps_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getDeps(struct soap *soap, const struct __ns1__getDeps *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getDeps(soap, &a->ns1__getDeps_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getDeps(struct soap *soap, const char *tag, int id, const struct __ns1__getDeps *a, const char *type)
{
	if (soap_out_PointerTons1__getDeps(soap, "ns1:getDeps", -1, &a->ns1__getDeps_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getDeps * SOAP_FMAC4 soap_in___ns1__getDeps(struct soap *soap, const char *tag, struct __ns1__getDeps *a, const char *type)
{
	size_t soap_flag_ns1__getDeps_ = 1;
	short soap_flag;
	a = (struct __ns1__getDeps *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getDeps, sizeof(struct __ns1__getDeps), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getDeps(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getDeps_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getDeps(soap, "ns1:getDeps", &a->ns1__getDeps_, "ns1:getDeps"))
				{	soap_flag_ns1__getDeps_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getDeps(struct soap *soap, const struct __ns1__getDeps *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getDeps(soap, tag?tag:"-ns1:getDeps", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getDeps * SOAP_FMAC4 soap_get___ns1__getDeps(struct soap *soap, struct __ns1__getDeps *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getDeps(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getDeps * SOAP_FMAC2 soap_instantiate___ns1__getDeps(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getDeps(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getDeps, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getDeps);
		if (size)
			*size = sizeof(struct __ns1__getDeps);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getDeps[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getDeps);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getDeps*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getDeps(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getDeps %p -> %p\n", q, p));
	*(struct __ns1__getDeps*)p = *(struct __ns1__getDeps*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getRedrTypes(struct soap *soap, struct __ns1__getRedrTypes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getRedrTypes_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getRedrTypes(struct soap *soap, const struct __ns1__getRedrTypes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getRedrTypes(soap, &a->ns1__getRedrTypes_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getRedrTypes(struct soap *soap, const char *tag, int id, const struct __ns1__getRedrTypes *a, const char *type)
{
	if (soap_out_PointerTons1__getRedrTypes(soap, "ns1:getRedrTypes", -1, &a->ns1__getRedrTypes_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getRedrTypes * SOAP_FMAC4 soap_in___ns1__getRedrTypes(struct soap *soap, const char *tag, struct __ns1__getRedrTypes *a, const char *type)
{
	size_t soap_flag_ns1__getRedrTypes_ = 1;
	short soap_flag;
	a = (struct __ns1__getRedrTypes *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getRedrTypes, sizeof(struct __ns1__getRedrTypes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getRedrTypes(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getRedrTypes_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getRedrTypes(soap, "ns1:getRedrTypes", &a->ns1__getRedrTypes_, "ns1:getRedrTypes"))
				{	soap_flag_ns1__getRedrTypes_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getRedrTypes(struct soap *soap, const struct __ns1__getRedrTypes *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getRedrTypes(soap, tag?tag:"-ns1:getRedrTypes", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getRedrTypes * SOAP_FMAC4 soap_get___ns1__getRedrTypes(struct soap *soap, struct __ns1__getRedrTypes *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getRedrTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getRedrTypes * SOAP_FMAC2 soap_instantiate___ns1__getRedrTypes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getRedrTypes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getRedrTypes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getRedrTypes);
		if (size)
			*size = sizeof(struct __ns1__getRedrTypes);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getRedrTypes[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getRedrTypes);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getRedrTypes*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getRedrTypes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getRedrTypes %p -> %p\n", q, p));
	*(struct __ns1__getRedrTypes*)p = *(struct __ns1__getRedrTypes*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__registerReader(struct soap *soap, struct __ns1__registerReader *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__registerReader_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__registerReader(struct soap *soap, const struct __ns1__registerReader *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__registerReader(soap, &a->ns1__registerReader_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__registerReader(struct soap *soap, const char *tag, int id, const struct __ns1__registerReader *a, const char *type)
{
	if (soap_out_PointerTons1__registerReader(soap, "ns1:registerReader", -1, &a->ns1__registerReader_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__registerReader * SOAP_FMAC4 soap_in___ns1__registerReader(struct soap *soap, const char *tag, struct __ns1__registerReader *a, const char *type)
{
	size_t soap_flag_ns1__registerReader_ = 1;
	short soap_flag;
	a = (struct __ns1__registerReader *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__registerReader, sizeof(struct __ns1__registerReader), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__registerReader(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__registerReader_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__registerReader(soap, "ns1:registerReader", &a->ns1__registerReader_, "ns1:registerReader"))
				{	soap_flag_ns1__registerReader_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__registerReader(struct soap *soap, const struct __ns1__registerReader *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__registerReader(soap, tag?tag:"-ns1:registerReader", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__registerReader * SOAP_FMAC4 soap_get___ns1__registerReader(struct soap *soap, struct __ns1__registerReader *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__registerReader(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__registerReader * SOAP_FMAC2 soap_instantiate___ns1__registerReader(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__registerReader(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__registerReader, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__registerReader);
		if (size)
			*size = sizeof(struct __ns1__registerReader);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__registerReader[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__registerReader);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__registerReader*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__registerReader(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__registerReader %p -> %p\n", q, p));
	*(struct __ns1__registerReader*)p = *(struct __ns1__registerReader*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__exceedFine1(struct soap *soap, struct __ns1__exceedFine1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__exceedFine1_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__exceedFine1(struct soap *soap, const struct __ns1__exceedFine1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__exceedFine1(soap, &a->ns1__exceedFine1_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__exceedFine1(struct soap *soap, const char *tag, int id, const struct __ns1__exceedFine1 *a, const char *type)
{
	if (soap_out_PointerTons1__exceedFine1(soap, "ns1:exceedFine1", -1, &a->ns1__exceedFine1_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__exceedFine1 * SOAP_FMAC4 soap_in___ns1__exceedFine1(struct soap *soap, const char *tag, struct __ns1__exceedFine1 *a, const char *type)
{
	size_t soap_flag_ns1__exceedFine1_ = 1;
	short soap_flag;
	a = (struct __ns1__exceedFine1 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__exceedFine1, sizeof(struct __ns1__exceedFine1), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__exceedFine1(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__exceedFine1_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__exceedFine1(soap, "ns1:exceedFine1", &a->ns1__exceedFine1_, "ns1:exceedFine1"))
				{	soap_flag_ns1__exceedFine1_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__exceedFine1(struct soap *soap, const struct __ns1__exceedFine1 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__exceedFine1(soap, tag?tag:"-ns1:exceedFine1", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__exceedFine1 * SOAP_FMAC4 soap_get___ns1__exceedFine1(struct soap *soap, struct __ns1__exceedFine1 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__exceedFine1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__exceedFine1 * SOAP_FMAC2 soap_instantiate___ns1__exceedFine1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__exceedFine1(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__exceedFine1, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__exceedFine1);
		if (size)
			*size = sizeof(struct __ns1__exceedFine1);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__exceedFine1[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__exceedFine1);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__exceedFine1*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__exceedFine1(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__exceedFine1 %p -> %p\n", q, p));
	*(struct __ns1__exceedFine1*)p = *(struct __ns1__exceedFine1*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getViolations1(struct soap *soap, struct __ns1__getViolations1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getViolations1_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getViolations1(struct soap *soap, const struct __ns1__getViolations1 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getViolations1(soap, &a->ns1__getViolations1_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getViolations1(struct soap *soap, const char *tag, int id, const struct __ns1__getViolations1 *a, const char *type)
{
	if (soap_out_PointerTons1__getViolations1(soap, "ns1:getViolations1", -1, &a->ns1__getViolations1_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getViolations1 * SOAP_FMAC4 soap_in___ns1__getViolations1(struct soap *soap, const char *tag, struct __ns1__getViolations1 *a, const char *type)
{
	size_t soap_flag_ns1__getViolations1_ = 1;
	short soap_flag;
	a = (struct __ns1__getViolations1 *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getViolations1, sizeof(struct __ns1__getViolations1), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getViolations1(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getViolations1_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getViolations1(soap, "ns1:getViolations1", &a->ns1__getViolations1_, "ns1:getViolations1"))
				{	soap_flag_ns1__getViolations1_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getViolations1(struct soap *soap, const struct __ns1__getViolations1 *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getViolations1(soap, tag?tag:"-ns1:getViolations1", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getViolations1 * SOAP_FMAC4 soap_get___ns1__getViolations1(struct soap *soap, struct __ns1__getViolations1 *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getViolations1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getViolations1 * SOAP_FMAC2 soap_instantiate___ns1__getViolations1(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getViolations1(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getViolations1, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getViolations1);
		if (size)
			*size = sizeof(struct __ns1__getViolations1);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getViolations1[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getViolations1);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getViolations1*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getViolations1(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getViolations1 %p -> %p\n", q, p));
	*(struct __ns1__getViolations1*)p = *(struct __ns1__getViolations1*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__voltFine(struct soap *soap, struct __ns1__voltFine *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__voltFine_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__voltFine(struct soap *soap, const struct __ns1__voltFine *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__voltFine(soap, &a->ns1__voltFine_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__voltFine(struct soap *soap, const char *tag, int id, const struct __ns1__voltFine *a, const char *type)
{
	if (soap_out_PointerTons1__voltFine(soap, "ns1:voltFine", -1, &a->ns1__voltFine_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__voltFine * SOAP_FMAC4 soap_in___ns1__voltFine(struct soap *soap, const char *tag, struct __ns1__voltFine *a, const char *type)
{
	size_t soap_flag_ns1__voltFine_ = 1;
	short soap_flag;
	a = (struct __ns1__voltFine *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__voltFine, sizeof(struct __ns1__voltFine), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__voltFine(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__voltFine_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__voltFine(soap, "ns1:voltFine", &a->ns1__voltFine_, "ns1:voltFine"))
				{	soap_flag_ns1__voltFine_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__voltFine(struct soap *soap, const struct __ns1__voltFine *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__voltFine(soap, tag?tag:"-ns1:voltFine", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__voltFine * SOAP_FMAC4 soap_get___ns1__voltFine(struct soap *soap, struct __ns1__voltFine *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__voltFine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__voltFine * SOAP_FMAC2 soap_instantiate___ns1__voltFine(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__voltFine(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__voltFine, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__voltFine);
		if (size)
			*size = sizeof(struct __ns1__voltFine);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__voltFine[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__voltFine);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__voltFine*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__voltFine(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__voltFine %p -> %p\n", q, p));
	*(struct __ns1__voltFine*)p = *(struct __ns1__voltFine*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__checkReader(struct soap *soap, struct __ns1__checkReader *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__checkReader_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__checkReader(struct soap *soap, const struct __ns1__checkReader *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__checkReader(soap, &a->ns1__checkReader_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__checkReader(struct soap *soap, const char *tag, int id, const struct __ns1__checkReader *a, const char *type)
{
	if (soap_out_PointerTons1__checkReader(soap, "ns1:checkReader", -1, &a->ns1__checkReader_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__checkReader * SOAP_FMAC4 soap_in___ns1__checkReader(struct soap *soap, const char *tag, struct __ns1__checkReader *a, const char *type)
{
	size_t soap_flag_ns1__checkReader_ = 1;
	short soap_flag;
	a = (struct __ns1__checkReader *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__checkReader, sizeof(struct __ns1__checkReader), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__checkReader(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__checkReader_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__checkReader(soap, "ns1:checkReader", &a->ns1__checkReader_, "ns1:checkReader"))
				{	soap_flag_ns1__checkReader_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__checkReader(struct soap *soap, const struct __ns1__checkReader *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__checkReader(soap, tag?tag:"-ns1:checkReader", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__checkReader * SOAP_FMAC4 soap_get___ns1__checkReader(struct soap *soap, struct __ns1__checkReader *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__checkReader(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__checkReader * SOAP_FMAC2 soap_instantiate___ns1__checkReader(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__checkReader(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__checkReader, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__checkReader);
		if (size)
			*size = sizeof(struct __ns1__checkReader);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__checkReader[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__checkReader);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__checkReader*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__checkReader(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__checkReader %p -> %p\n", q, p));
	*(struct __ns1__checkReader*)p = *(struct __ns1__checkReader*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getMarc(struct soap *soap, struct __ns1__getMarc *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getMarc_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getMarc(struct soap *soap, const struct __ns1__getMarc *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getMarc(soap, &a->ns1__getMarc_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getMarc(struct soap *soap, const char *tag, int id, const struct __ns1__getMarc *a, const char *type)
{
	if (soap_out_PointerTons1__getMarc(soap, "ns1:getMarc", -1, &a->ns1__getMarc_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMarc * SOAP_FMAC4 soap_in___ns1__getMarc(struct soap *soap, const char *tag, struct __ns1__getMarc *a, const char *type)
{
	size_t soap_flag_ns1__getMarc_ = 1;
	short soap_flag;
	a = (struct __ns1__getMarc *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getMarc, sizeof(struct __ns1__getMarc), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getMarc(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getMarc_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getMarc(soap, "ns1:getMarc", &a->ns1__getMarc_, "ns1:getMarc"))
				{	soap_flag_ns1__getMarc_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getMarc(struct soap *soap, const struct __ns1__getMarc *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getMarc(soap, tag?tag:"-ns1:getMarc", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMarc * SOAP_FMAC4 soap_get___ns1__getMarc(struct soap *soap, struct __ns1__getMarc *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getMarc(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getMarc * SOAP_FMAC2 soap_instantiate___ns1__getMarc(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getMarc(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getMarc, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getMarc);
		if (size)
			*size = sizeof(struct __ns1__getMarc);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getMarc[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getMarc);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getMarc*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getMarc(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getMarc %p -> %p\n", q, p));
	*(struct __ns1__getMarc*)p = *(struct __ns1__getMarc*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getLendHist(struct soap *soap, struct __ns1__getLendHist *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getLendHist_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getLendHist(struct soap *soap, const struct __ns1__getLendHist *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getLendHist(soap, &a->ns1__getLendHist_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getLendHist(struct soap *soap, const char *tag, int id, const struct __ns1__getLendHist *a, const char *type)
{
	if (soap_out_PointerTons1__getLendHist(soap, "ns1:getLendHist", -1, &a->ns1__getLendHist_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getLendHist * SOAP_FMAC4 soap_in___ns1__getLendHist(struct soap *soap, const char *tag, struct __ns1__getLendHist *a, const char *type)
{
	size_t soap_flag_ns1__getLendHist_ = 1;
	short soap_flag;
	a = (struct __ns1__getLendHist *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getLendHist, sizeof(struct __ns1__getLendHist), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getLendHist(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getLendHist_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getLendHist(soap, "ns1:getLendHist", &a->ns1__getLendHist_, "ns1:getLendHist"))
				{	soap_flag_ns1__getLendHist_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getLendHist(struct soap *soap, const struct __ns1__getLendHist *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getLendHist(soap, tag?tag:"-ns1:getLendHist", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getLendHist * SOAP_FMAC4 soap_get___ns1__getLendHist(struct soap *soap, struct __ns1__getLendHist *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getLendHist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getLendHist * SOAP_FMAC2 soap_instantiate___ns1__getLendHist(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getLendHist(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getLendHist, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getLendHist);
		if (size)
			*size = sizeof(struct __ns1__getLendHist);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getLendHist[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getLendHist);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getLendHist*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getLendHist(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getLendHist %p -> %p\n", q, p));
	*(struct __ns1__getLendHist*)p = *(struct __ns1__getLendHist*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__logout(struct soap *soap, struct __ns1__logout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__logout_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__logout(struct soap *soap, const struct __ns1__logout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__logout(soap, &a->ns1__logout_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__logout(struct soap *soap, const char *tag, int id, const struct __ns1__logout *a, const char *type)
{
	if (soap_out_PointerTons1__logout(soap, "ns1:logout", -1, &a->ns1__logout_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__logout * SOAP_FMAC4 soap_in___ns1__logout(struct soap *soap, const char *tag, struct __ns1__logout *a, const char *type)
{
	size_t soap_flag_ns1__logout_ = 1;
	short soap_flag;
	a = (struct __ns1__logout *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__logout, sizeof(struct __ns1__logout), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__logout(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__logout_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__logout(soap, "ns1:logout", &a->ns1__logout_, "ns1:logout"))
				{	soap_flag_ns1__logout_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__logout(struct soap *soap, const struct __ns1__logout *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__logout(soap, tag?tag:"-ns1:logout", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__logout * SOAP_FMAC4 soap_get___ns1__logout(struct soap *soap, struct __ns1__logout *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__logout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__logout * SOAP_FMAC2 soap_instantiate___ns1__logout(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__logout(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__logout, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__logout);
		if (size)
			*size = sizeof(struct __ns1__logout);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__logout[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__logout);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__logout*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__logout(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__logout %p -> %p\n", q, p));
	*(struct __ns1__logout*)p = *(struct __ns1__logout*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__certLoss(struct soap *soap, struct __ns1__certLoss *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__certLoss_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__certLoss(struct soap *soap, const struct __ns1__certLoss *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__certLoss(soap, &a->ns1__certLoss_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__certLoss(struct soap *soap, const char *tag, int id, const struct __ns1__certLoss *a, const char *type)
{
	if (soap_out_PointerTons1__certLoss(soap, "ns1:certLoss", -1, &a->ns1__certLoss_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__certLoss * SOAP_FMAC4 soap_in___ns1__certLoss(struct soap *soap, const char *tag, struct __ns1__certLoss *a, const char *type)
{
	size_t soap_flag_ns1__certLoss_ = 1;
	short soap_flag;
	a = (struct __ns1__certLoss *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__certLoss, sizeof(struct __ns1__certLoss), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__certLoss(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__certLoss_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__certLoss(soap, "ns1:certLoss", &a->ns1__certLoss_, "ns1:certLoss"))
				{	soap_flag_ns1__certLoss_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__certLoss(struct soap *soap, const struct __ns1__certLoss *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__certLoss(soap, tag?tag:"-ns1:certLoss", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__certLoss * SOAP_FMAC4 soap_get___ns1__certLoss(struct soap *soap, struct __ns1__certLoss *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__certLoss(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__certLoss * SOAP_FMAC2 soap_instantiate___ns1__certLoss(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__certLoss(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__certLoss, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__certLoss);
		if (size)
			*size = sizeof(struct __ns1__certLoss);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__certLoss[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__certLoss);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__certLoss*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__certLoss(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__certLoss %p -> %p\n", q, p));
	*(struct __ns1__certLoss*)p = *(struct __ns1__certLoss*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__exceedFine(struct soap *soap, struct __ns1__exceedFine *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__exceedFine_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__exceedFine(struct soap *soap, const struct __ns1__exceedFine *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__exceedFine(soap, &a->ns1__exceedFine_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__exceedFine(struct soap *soap, const char *tag, int id, const struct __ns1__exceedFine *a, const char *type)
{
	if (soap_out_PointerTons1__exceedFine(soap, "ns1:exceedFine", -1, &a->ns1__exceedFine_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__exceedFine * SOAP_FMAC4 soap_in___ns1__exceedFine(struct soap *soap, const char *tag, struct __ns1__exceedFine *a, const char *type)
{
	size_t soap_flag_ns1__exceedFine_ = 1;
	short soap_flag;
	a = (struct __ns1__exceedFine *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__exceedFine, sizeof(struct __ns1__exceedFine), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__exceedFine(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__exceedFine_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__exceedFine(soap, "ns1:exceedFine", &a->ns1__exceedFine_, "ns1:exceedFine"))
				{	soap_flag_ns1__exceedFine_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__exceedFine(struct soap *soap, const struct __ns1__exceedFine *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__exceedFine(soap, tag?tag:"-ns1:exceedFine", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__exceedFine * SOAP_FMAC4 soap_get___ns1__exceedFine(struct soap *soap, struct __ns1__exceedFine *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__exceedFine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__exceedFine * SOAP_FMAC2 soap_instantiate___ns1__exceedFine(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__exceedFine(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__exceedFine, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__exceedFine);
		if (size)
			*size = sizeof(struct __ns1__exceedFine);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__exceedFine[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__exceedFine);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__exceedFine*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__exceedFine(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__exceedFine %p -> %p\n", q, p));
	*(struct __ns1__exceedFine*)p = *(struct __ns1__exceedFine*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getLostPays(struct soap *soap, struct __ns1__getLostPays *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getLostPays_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getLostPays(struct soap *soap, const struct __ns1__getLostPays *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getLostPays(soap, &a->ns1__getLostPays_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getLostPays(struct soap *soap, const char *tag, int id, const struct __ns1__getLostPays *a, const char *type)
{
	if (soap_out_PointerTons1__getLostPays(soap, "ns1:getLostPays", -1, &a->ns1__getLostPays_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getLostPays * SOAP_FMAC4 soap_in___ns1__getLostPays(struct soap *soap, const char *tag, struct __ns1__getLostPays *a, const char *type)
{
	size_t soap_flag_ns1__getLostPays_ = 1;
	short soap_flag;
	a = (struct __ns1__getLostPays *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getLostPays, sizeof(struct __ns1__getLostPays), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getLostPays(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getLostPays_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getLostPays(soap, "ns1:getLostPays", &a->ns1__getLostPays_, "ns1:getLostPays"))
				{	soap_flag_ns1__getLostPays_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getLostPays(struct soap *soap, const struct __ns1__getLostPays *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getLostPays(soap, tag?tag:"-ns1:getLostPays", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getLostPays * SOAP_FMAC4 soap_get___ns1__getLostPays(struct soap *soap, struct __ns1__getLostPays *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getLostPays(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getLostPays * SOAP_FMAC2 soap_instantiate___ns1__getLostPays(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getLostPays(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getLostPays, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getLostPays);
		if (size)
			*size = sizeof(struct __ns1__getLostPays);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getLostPays[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getLostPays);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getLostPays*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getLostPays(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getLostPays %p -> %p\n", q, p));
	*(struct __ns1__getLostPays*)p = *(struct __ns1__getLostPays*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getAccounts(struct soap *soap, struct __ns1__getAccounts *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getAccounts_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getAccounts(struct soap *soap, const struct __ns1__getAccounts *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getAccounts(soap, &a->ns1__getAccounts_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getAccounts(struct soap *soap, const char *tag, int id, const struct __ns1__getAccounts *a, const char *type)
{
	if (soap_out_PointerTons1__getAccounts(soap, "ns1:getAccounts", -1, &a->ns1__getAccounts_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAccounts * SOAP_FMAC4 soap_in___ns1__getAccounts(struct soap *soap, const char *tag, struct __ns1__getAccounts *a, const char *type)
{
	size_t soap_flag_ns1__getAccounts_ = 1;
	short soap_flag;
	a = (struct __ns1__getAccounts *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getAccounts, sizeof(struct __ns1__getAccounts), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getAccounts(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getAccounts_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getAccounts(soap, "ns1:getAccounts", &a->ns1__getAccounts_, "ns1:getAccounts"))
				{	soap_flag_ns1__getAccounts_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getAccounts(struct soap *soap, const struct __ns1__getAccounts *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getAccounts(soap, tag?tag:"-ns1:getAccounts", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getAccounts * SOAP_FMAC4 soap_get___ns1__getAccounts(struct soap *soap, struct __ns1__getAccounts *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getAccounts(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getAccounts * SOAP_FMAC2 soap_instantiate___ns1__getAccounts(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getAccounts(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getAccounts, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getAccounts);
		if (size)
			*size = sizeof(struct __ns1__getAccounts);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getAccounts[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getAccounts);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getAccounts*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getAccounts(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getAccounts %p -> %p\n", q, p));
	*(struct __ns1__getAccounts*)p = *(struct __ns1__getAccounts*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getRelegates(struct soap *soap, struct __ns1__getRelegates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getRelegates_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getRelegates(struct soap *soap, const struct __ns1__getRelegates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getRelegates(soap, &a->ns1__getRelegates_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getRelegates(struct soap *soap, const char *tag, int id, const struct __ns1__getRelegates *a, const char *type)
{
	if (soap_out_PointerTons1__getRelegates(soap, "ns1:getRelegates", -1, &a->ns1__getRelegates_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getRelegates * SOAP_FMAC4 soap_in___ns1__getRelegates(struct soap *soap, const char *tag, struct __ns1__getRelegates *a, const char *type)
{
	size_t soap_flag_ns1__getRelegates_ = 1;
	short soap_flag;
	a = (struct __ns1__getRelegates *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getRelegates, sizeof(struct __ns1__getRelegates), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getRelegates(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getRelegates_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getRelegates(soap, "ns1:getRelegates", &a->ns1__getRelegates_, "ns1:getRelegates"))
				{	soap_flag_ns1__getRelegates_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getRelegates(struct soap *soap, const struct __ns1__getRelegates *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getRelegates(soap, tag?tag:"-ns1:getRelegates", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getRelegates * SOAP_FMAC4 soap_get___ns1__getRelegates(struct soap *soap, struct __ns1__getRelegates *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getRelegates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getRelegates * SOAP_FMAC2 soap_instantiate___ns1__getRelegates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getRelegates(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getRelegates, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getRelegates);
		if (size)
			*size = sizeof(struct __ns1__getRelegates);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getRelegates[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getRelegates);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getRelegates*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getRelegates(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getRelegates %p -> %p\n", q, p));
	*(struct __ns1__getRelegates*)p = *(struct __ns1__getRelegates*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getPregs(struct soap *soap, struct __ns1__getPregs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getPregs_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getPregs(struct soap *soap, const struct __ns1__getPregs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getPregs(soap, &a->ns1__getPregs_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getPregs(struct soap *soap, const char *tag, int id, const struct __ns1__getPregs *a, const char *type)
{
	if (soap_out_PointerTons1__getPregs(soap, "ns1:getPregs", -1, &a->ns1__getPregs_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPregs * SOAP_FMAC4 soap_in___ns1__getPregs(struct soap *soap, const char *tag, struct __ns1__getPregs *a, const char *type)
{
	size_t soap_flag_ns1__getPregs_ = 1;
	short soap_flag;
	a = (struct __ns1__getPregs *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getPregs, sizeof(struct __ns1__getPregs), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getPregs(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getPregs_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getPregs(soap, "ns1:getPregs", &a->ns1__getPregs_, "ns1:getPregs"))
				{	soap_flag_ns1__getPregs_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getPregs(struct soap *soap, const struct __ns1__getPregs *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getPregs(soap, tag?tag:"-ns1:getPregs", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPregs * SOAP_FMAC4 soap_get___ns1__getPregs(struct soap *soap, struct __ns1__getPregs *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getPregs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getPregs * SOAP_FMAC2 soap_instantiate___ns1__getPregs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getPregs(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getPregs, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getPregs);
		if (size)
			*size = sizeof(struct __ns1__getPregs);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getPregs[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getPregs);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getPregs*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getPregs(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getPregs %p -> %p\n", q, p));
	*(struct __ns1__getPregs*)p = *(struct __ns1__getPregs*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getRelegateArrivals(struct soap *soap, struct __ns1__getRelegateArrivals *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getRelegateArrivals_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getRelegateArrivals(struct soap *soap, const struct __ns1__getRelegateArrivals *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getRelegateArrivals(soap, &a->ns1__getRelegateArrivals_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getRelegateArrivals(struct soap *soap, const char *tag, int id, const struct __ns1__getRelegateArrivals *a, const char *type)
{
	if (soap_out_PointerTons1__getRelegateArrivals(soap, "ns1:getRelegateArrivals", -1, &a->ns1__getRelegateArrivals_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getRelegateArrivals * SOAP_FMAC4 soap_in___ns1__getRelegateArrivals(struct soap *soap, const char *tag, struct __ns1__getRelegateArrivals *a, const char *type)
{
	size_t soap_flag_ns1__getRelegateArrivals_ = 1;
	short soap_flag;
	a = (struct __ns1__getRelegateArrivals *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getRelegateArrivals, sizeof(struct __ns1__getRelegateArrivals), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getRelegateArrivals(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getRelegateArrivals_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getRelegateArrivals(soap, "ns1:getRelegateArrivals", &a->ns1__getRelegateArrivals_, "ns1:getRelegateArrivals"))
				{	soap_flag_ns1__getRelegateArrivals_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getRelegateArrivals(struct soap *soap, const struct __ns1__getRelegateArrivals *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getRelegateArrivals(soap, tag?tag:"-ns1:getRelegateArrivals", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getRelegateArrivals * SOAP_FMAC4 soap_get___ns1__getRelegateArrivals(struct soap *soap, struct __ns1__getRelegateArrivals *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getRelegateArrivals(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getRelegateArrivals * SOAP_FMAC2 soap_instantiate___ns1__getRelegateArrivals(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getRelegateArrivals(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getRelegateArrivals, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getRelegateArrivals);
		if (size)
			*size = sizeof(struct __ns1__getRelegateArrivals);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getRelegateArrivals[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getRelegateArrivals);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getRelegateArrivals*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getRelegateArrivals(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getRelegateArrivals %p -> %p\n", q, p));
	*(struct __ns1__getRelegateArrivals*)p = *(struct __ns1__getRelegateArrivals*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getPregArrivals(struct soap *soap, struct __ns1__getPregArrivals *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getPregArrivals_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getPregArrivals(struct soap *soap, const struct __ns1__getPregArrivals *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getPregArrivals(soap, &a->ns1__getPregArrivals_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getPregArrivals(struct soap *soap, const char *tag, int id, const struct __ns1__getPregArrivals *a, const char *type)
{
	if (soap_out_PointerTons1__getPregArrivals(soap, "ns1:getPregArrivals", -1, &a->ns1__getPregArrivals_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPregArrivals * SOAP_FMAC4 soap_in___ns1__getPregArrivals(struct soap *soap, const char *tag, struct __ns1__getPregArrivals *a, const char *type)
{
	size_t soap_flag_ns1__getPregArrivals_ = 1;
	short soap_flag;
	a = (struct __ns1__getPregArrivals *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getPregArrivals, sizeof(struct __ns1__getPregArrivals), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getPregArrivals(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getPregArrivals_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getPregArrivals(soap, "ns1:getPregArrivals", &a->ns1__getPregArrivals_, "ns1:getPregArrivals"))
				{	soap_flag_ns1__getPregArrivals_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getPregArrivals(struct soap *soap, const struct __ns1__getPregArrivals *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getPregArrivals(soap, tag?tag:"-ns1:getPregArrivals", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPregArrivals * SOAP_FMAC4 soap_get___ns1__getPregArrivals(struct soap *soap, struct __ns1__getPregArrivals *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getPregArrivals(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getPregArrivals * SOAP_FMAC2 soap_instantiate___ns1__getPregArrivals(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getPregArrivals(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getPregArrivals, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getPregArrivals);
		if (size)
			*size = sizeof(struct __ns1__getPregArrivals);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getPregArrivals[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getPregArrivals);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getPregArrivals*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getPregArrivals(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getPregArrivals %p -> %p\n", q, p));
	*(struct __ns1__getPregArrivals*)p = *(struct __ns1__getPregArrivals*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getDebts(struct soap *soap, struct __ns1__getDebts *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getDebts_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getDebts(struct soap *soap, const struct __ns1__getDebts *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getDebts(soap, &a->ns1__getDebts_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getDebts(struct soap *soap, const char *tag, int id, const struct __ns1__getDebts *a, const char *type)
{
	if (soap_out_PointerTons1__getDebts(soap, "ns1:getDebts", -1, &a->ns1__getDebts_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getDebts * SOAP_FMAC4 soap_in___ns1__getDebts(struct soap *soap, const char *tag, struct __ns1__getDebts *a, const char *type)
{
	size_t soap_flag_ns1__getDebts_ = 1;
	short soap_flag;
	a = (struct __ns1__getDebts *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getDebts, sizeof(struct __ns1__getDebts), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getDebts(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getDebts_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getDebts(soap, "ns1:getDebts", &a->ns1__getDebts_, "ns1:getDebts"))
				{	soap_flag_ns1__getDebts_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getDebts(struct soap *soap, const struct __ns1__getDebts *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getDebts(soap, tag?tag:"-ns1:getDebts", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getDebts * SOAP_FMAC4 soap_get___ns1__getDebts(struct soap *soap, struct __ns1__getDebts *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getDebts(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getDebts * SOAP_FMAC2 soap_instantiate___ns1__getDebts(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getDebts(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getDebts, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getDebts);
		if (size)
			*size = sizeof(struct __ns1__getDebts);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getDebts[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getDebts);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getDebts*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getDebts(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getDebts %p -> %p\n", q, p));
	*(struct __ns1__getDebts*)p = *(struct __ns1__getDebts*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getViolations(struct soap *soap, struct __ns1__getViolations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getViolations_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getViolations(struct soap *soap, const struct __ns1__getViolations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getViolations(soap, &a->ns1__getViolations_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getViolations(struct soap *soap, const char *tag, int id, const struct __ns1__getViolations *a, const char *type)
{
	if (soap_out_PointerTons1__getViolations(soap, "ns1:getViolations", -1, &a->ns1__getViolations_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getViolations * SOAP_FMAC4 soap_in___ns1__getViolations(struct soap *soap, const char *tag, struct __ns1__getViolations *a, const char *type)
{
	size_t soap_flag_ns1__getViolations_ = 1;
	short soap_flag;
	a = (struct __ns1__getViolations *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getViolations, sizeof(struct __ns1__getViolations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getViolations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getViolations_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getViolations(soap, "ns1:getViolations", &a->ns1__getViolations_, "ns1:getViolations"))
				{	soap_flag_ns1__getViolations_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getViolations(struct soap *soap, const struct __ns1__getViolations *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getViolations(soap, tag?tag:"-ns1:getViolations", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getViolations * SOAP_FMAC4 soap_get___ns1__getViolations(struct soap *soap, struct __ns1__getViolations *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getViolations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getViolations * SOAP_FMAC2 soap_instantiate___ns1__getViolations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getViolations(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getViolations, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getViolations);
		if (size)
			*size = sizeof(struct __ns1__getViolations);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getViolations[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getViolations);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getViolations*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getViolations(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getViolations %p -> %p\n", q, p));
	*(struct __ns1__getViolations*)p = *(struct __ns1__getViolations*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getCircs(struct soap *soap, struct __ns1__getCircs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getCircs_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getCircs(struct soap *soap, const struct __ns1__getCircs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getCircs(soap, &a->ns1__getCircs_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getCircs(struct soap *soap, const char *tag, int id, const struct __ns1__getCircs *a, const char *type)
{
	if (soap_out_PointerTons1__getCircs(soap, "ns1:getCircs", -1, &a->ns1__getCircs_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getCircs * SOAP_FMAC4 soap_in___ns1__getCircs(struct soap *soap, const char *tag, struct __ns1__getCircs *a, const char *type)
{
	size_t soap_flag_ns1__getCircs_ = 1;
	short soap_flag;
	a = (struct __ns1__getCircs *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getCircs, sizeof(struct __ns1__getCircs), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getCircs(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getCircs_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getCircs(soap, "ns1:getCircs", &a->ns1__getCircs_, "ns1:getCircs"))
				{	soap_flag_ns1__getCircs_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getCircs(struct soap *soap, const struct __ns1__getCircs *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getCircs(soap, tag?tag:"-ns1:getCircs", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getCircs * SOAP_FMAC4 soap_get___ns1__getCircs(struct soap *soap, struct __ns1__getCircs *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getCircs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getCircs * SOAP_FMAC2 soap_instantiate___ns1__getCircs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getCircs(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getCircs, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getCircs);
		if (size)
			*size = sizeof(struct __ns1__getCircs);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getCircs[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getCircs);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getCircs*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getCircs(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getCircs %p -> %p\n", q, p));
	*(struct __ns1__getCircs*)p = *(struct __ns1__getCircs*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getBook(struct soap *soap, struct __ns1__getBook *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getBook_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getBook(struct soap *soap, const struct __ns1__getBook *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getBook(soap, &a->ns1__getBook_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getBook(struct soap *soap, const char *tag, int id, const struct __ns1__getBook *a, const char *type)
{
	if (soap_out_PointerTons1__getBook(soap, "ns1:getBook", -1, &a->ns1__getBook_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getBook * SOAP_FMAC4 soap_in___ns1__getBook(struct soap *soap, const char *tag, struct __ns1__getBook *a, const char *type)
{
	size_t soap_flag_ns1__getBook_ = 1;
	short soap_flag;
	a = (struct __ns1__getBook *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getBook, sizeof(struct __ns1__getBook), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getBook(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getBook_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getBook(soap, "ns1:getBook", &a->ns1__getBook_, "ns1:getBook"))
				{	soap_flag_ns1__getBook_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getBook(struct soap *soap, const struct __ns1__getBook *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getBook(soap, tag?tag:"-ns1:getBook", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getBook * SOAP_FMAC4 soap_get___ns1__getBook(struct soap *soap, struct __ns1__getBook *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getBook(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getBook * SOAP_FMAC2 soap_instantiate___ns1__getBook(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getBook(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getBook, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getBook);
		if (size)
			*size = sizeof(struct __ns1__getBook);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getBook[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getBook);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getBook*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getBook(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getBook %p -> %p\n", q, p));
	*(struct __ns1__getBook*)p = *(struct __ns1__getBook*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getItems(struct soap *soap, struct __ns1__getItems *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getItems_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getItems(struct soap *soap, const struct __ns1__getItems *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getItems(soap, &a->ns1__getItems_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getItems(struct soap *soap, const char *tag, int id, const struct __ns1__getItems *a, const char *type)
{
	if (soap_out_PointerTons1__getItems(soap, "ns1:getItems", -1, &a->ns1__getItems_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getItems * SOAP_FMAC4 soap_in___ns1__getItems(struct soap *soap, const char *tag, struct __ns1__getItems *a, const char *type)
{
	size_t soap_flag_ns1__getItems_ = 1;
	short soap_flag;
	a = (struct __ns1__getItems *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getItems, sizeof(struct __ns1__getItems), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getItems(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getItems_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getItems(soap, "ns1:getItems", &a->ns1__getItems_, "ns1:getItems"))
				{	soap_flag_ns1__getItems_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getItems(struct soap *soap, const struct __ns1__getItems *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getItems(soap, tag?tag:"-ns1:getItems", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getItems * SOAP_FMAC4 soap_get___ns1__getItems(struct soap *soap, struct __ns1__getItems *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getItems(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getItems * SOAP_FMAC2 soap_instantiate___ns1__getItems(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getItems(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getItems, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getItems);
		if (size)
			*size = sizeof(struct __ns1__getItems);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getItems[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getItems);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getItems*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getItems(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getItems %p -> %p\n", q, p));
	*(struct __ns1__getItems*)p = *(struct __ns1__getItems*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getReader(struct soap *soap, struct __ns1__getReader *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getReader_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getReader(struct soap *soap, const struct __ns1__getReader *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getReader(soap, &a->ns1__getReader_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getReader(struct soap *soap, const char *tag, int id, const struct __ns1__getReader *a, const char *type)
{
	if (soap_out_PointerTons1__getReader(soap, "ns1:getReader", -1, &a->ns1__getReader_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getReader * SOAP_FMAC4 soap_in___ns1__getReader(struct soap *soap, const char *tag, struct __ns1__getReader *a, const char *type)
{
	size_t soap_flag_ns1__getReader_ = 1;
	short soap_flag;
	a = (struct __ns1__getReader *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getReader, sizeof(struct __ns1__getReader), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getReader(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getReader_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getReader(soap, "ns1:getReader", &a->ns1__getReader_, "ns1:getReader"))
				{	soap_flag_ns1__getReader_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getReader(struct soap *soap, const struct __ns1__getReader *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getReader(soap, tag?tag:"-ns1:getReader", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getReader * SOAP_FMAC4 soap_get___ns1__getReader(struct soap *soap, struct __ns1__getReader *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getReader(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getReader * SOAP_FMAC2 soap_instantiate___ns1__getReader(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getReader(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getReader, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getReader);
		if (size)
			*size = sizeof(struct __ns1__getReader);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getReader[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getReader);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getReader*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getReader(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getReader %p -> %p\n", q, p));
	*(struct __ns1__getReader*)p = *(struct __ns1__getReader*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__NoAuthorityException_ = NULL;
	a->ns1__SystemException_ = NULL;
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__NoAuthorityException(soap, &a->ns1__NoAuthorityException_);
	soap_serialize_PointerTons1__SystemException(soap, &a->ns1__SystemException_);
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_out_PointerTons1__NoAuthorityException(soap, "ns1:NoAuthorityException", -1, &a->ns1__NoAuthorityException_, ""))
		return soap->error;
	if (soap_out_PointerTons1__SystemException(soap, "ns1:SystemException", -1, &a->ns1__SystemException_, ""))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_ns1__NoAuthorityException_ = 1;
	size_t soap_flag_ns1__SystemException_ = 1;
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__NoAuthorityException_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__NoAuthorityException(soap, "ns1:NoAuthorityException", &a->ns1__NoAuthorityException_, "ns1:NoAuthorityException"))
				{	soap_flag_ns1__NoAuthorityException_--;
					continue;
				}
			if (soap_flag_ns1__SystemException_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SystemException(soap, "ns1:SystemException", &a->ns1__SystemException_, "ns1:SystemException"))
				{	soap_flag_ns1__SystemException_--;
					continue;
				}
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fault > 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getAccounts1Response(struct soap *soap, ns1__getAccounts1Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getAccounts1Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getAccounts1Response(struct soap *soap, const char *tag, int id, ns1__getAccounts1Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getAccounts1Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getAccounts1Response ** SOAP_FMAC4 soap_in_PointerTons1__getAccounts1Response(struct soap *soap, const char *tag, ns1__getAccounts1Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getAccounts1Response **)soap_malloc(soap, sizeof(ns1__getAccounts1Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getAccounts1Response *)soap_instantiate_ns1__getAccounts1Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getAccounts1Response ** p = (ns1__getAccounts1Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getAccounts1Response, sizeof(ns1__getAccounts1Response), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getAccounts1Response(struct soap *soap, ns1__getAccounts1Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getAccounts1Response);
	if (soap_out_PointerTons1__getAccounts1Response(soap, tag?tag:"ns1:getAccounts1Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getAccounts1Response ** SOAP_FMAC4 soap_get_PointerTons1__getAccounts1Response(struct soap *soap, ns1__getAccounts1Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getAccounts1Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getAccounts1(struct soap *soap, ns1__getAccounts1 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getAccounts1))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getAccounts1(struct soap *soap, const char *tag, int id, ns1__getAccounts1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getAccounts1);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getAccounts1 ** SOAP_FMAC4 soap_in_PointerTons1__getAccounts1(struct soap *soap, const char *tag, ns1__getAccounts1 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getAccounts1 **)soap_malloc(soap, sizeof(ns1__getAccounts1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getAccounts1 *)soap_instantiate_ns1__getAccounts1(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getAccounts1 ** p = (ns1__getAccounts1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getAccounts1, sizeof(ns1__getAccounts1), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getAccounts1(struct soap *soap, ns1__getAccounts1 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getAccounts1);
	if (soap_out_PointerTons1__getAccounts1(soap, tag?tag:"ns1:getAccounts1", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getAccounts1 ** SOAP_FMAC4 soap_get_PointerTons1__getAccounts1(struct soap *soap, ns1__getAccounts1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getAccounts1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getDepsResponse(struct soap *soap, ns1__getDepsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getDepsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getDepsResponse(struct soap *soap, const char *tag, int id, ns1__getDepsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getDepsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getDepsResponse ** SOAP_FMAC4 soap_in_PointerTons1__getDepsResponse(struct soap *soap, const char *tag, ns1__getDepsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getDepsResponse **)soap_malloc(soap, sizeof(ns1__getDepsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getDepsResponse *)soap_instantiate_ns1__getDepsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getDepsResponse ** p = (ns1__getDepsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getDepsResponse, sizeof(ns1__getDepsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getDepsResponse(struct soap *soap, ns1__getDepsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getDepsResponse);
	if (soap_out_PointerTons1__getDepsResponse(soap, tag?tag:"ns1:getDepsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getDepsResponse ** SOAP_FMAC4 soap_get_PointerTons1__getDepsResponse(struct soap *soap, ns1__getDepsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getDepsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getDeps(struct soap *soap, ns1__getDeps *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getDeps))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getDeps(struct soap *soap, const char *tag, int id, ns1__getDeps *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getDeps);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getDeps ** SOAP_FMAC4 soap_in_PointerTons1__getDeps(struct soap *soap, const char *tag, ns1__getDeps **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getDeps **)soap_malloc(soap, sizeof(ns1__getDeps *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getDeps *)soap_instantiate_ns1__getDeps(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getDeps ** p = (ns1__getDeps **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getDeps, sizeof(ns1__getDeps), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getDeps(struct soap *soap, ns1__getDeps *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getDeps);
	if (soap_out_PointerTons1__getDeps(soap, tag?tag:"ns1:getDeps", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getDeps ** SOAP_FMAC4 soap_get_PointerTons1__getDeps(struct soap *soap, ns1__getDeps **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getDeps(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getRedrTypesResponse(struct soap *soap, ns1__getRedrTypesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getRedrTypesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getRedrTypesResponse(struct soap *soap, const char *tag, int id, ns1__getRedrTypesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getRedrTypesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getRedrTypesResponse ** SOAP_FMAC4 soap_in_PointerTons1__getRedrTypesResponse(struct soap *soap, const char *tag, ns1__getRedrTypesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getRedrTypesResponse **)soap_malloc(soap, sizeof(ns1__getRedrTypesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getRedrTypesResponse *)soap_instantiate_ns1__getRedrTypesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getRedrTypesResponse ** p = (ns1__getRedrTypesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getRedrTypesResponse, sizeof(ns1__getRedrTypesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getRedrTypesResponse(struct soap *soap, ns1__getRedrTypesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getRedrTypesResponse);
	if (soap_out_PointerTons1__getRedrTypesResponse(soap, tag?tag:"ns1:getRedrTypesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getRedrTypesResponse ** SOAP_FMAC4 soap_get_PointerTons1__getRedrTypesResponse(struct soap *soap, ns1__getRedrTypesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getRedrTypesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getRedrTypes(struct soap *soap, ns1__getRedrTypes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getRedrTypes))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getRedrTypes(struct soap *soap, const char *tag, int id, ns1__getRedrTypes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getRedrTypes);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getRedrTypes ** SOAP_FMAC4 soap_in_PointerTons1__getRedrTypes(struct soap *soap, const char *tag, ns1__getRedrTypes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getRedrTypes **)soap_malloc(soap, sizeof(ns1__getRedrTypes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getRedrTypes *)soap_instantiate_ns1__getRedrTypes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getRedrTypes ** p = (ns1__getRedrTypes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getRedrTypes, sizeof(ns1__getRedrTypes), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getRedrTypes(struct soap *soap, ns1__getRedrTypes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getRedrTypes);
	if (soap_out_PointerTons1__getRedrTypes(soap, tag?tag:"ns1:getRedrTypes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getRedrTypes ** SOAP_FMAC4 soap_get_PointerTons1__getRedrTypes(struct soap *soap, ns1__getRedrTypes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getRedrTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__registerReaderResponse(struct soap *soap, ns1__registerReaderResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__registerReaderResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__registerReaderResponse(struct soap *soap, const char *tag, int id, ns1__registerReaderResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__registerReaderResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__registerReaderResponse ** SOAP_FMAC4 soap_in_PointerTons1__registerReaderResponse(struct soap *soap, const char *tag, ns1__registerReaderResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__registerReaderResponse **)soap_malloc(soap, sizeof(ns1__registerReaderResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__registerReaderResponse *)soap_instantiate_ns1__registerReaderResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__registerReaderResponse ** p = (ns1__registerReaderResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__registerReaderResponse, sizeof(ns1__registerReaderResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__registerReaderResponse(struct soap *soap, ns1__registerReaderResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__registerReaderResponse);
	if (soap_out_PointerTons1__registerReaderResponse(soap, tag?tag:"ns1:registerReaderResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__registerReaderResponse ** SOAP_FMAC4 soap_get_PointerTons1__registerReaderResponse(struct soap *soap, ns1__registerReaderResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__registerReaderResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__registerReader(struct soap *soap, ns1__registerReader *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__registerReader))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__registerReader(struct soap *soap, const char *tag, int id, ns1__registerReader *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__registerReader);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__registerReader ** SOAP_FMAC4 soap_in_PointerTons1__registerReader(struct soap *soap, const char *tag, ns1__registerReader **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__registerReader **)soap_malloc(soap, sizeof(ns1__registerReader *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__registerReader *)soap_instantiate_ns1__registerReader(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__registerReader ** p = (ns1__registerReader **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__registerReader, sizeof(ns1__registerReader), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__registerReader(struct soap *soap, ns1__registerReader *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__registerReader);
	if (soap_out_PointerTons1__registerReader(soap, tag?tag:"ns1:registerReader", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__registerReader ** SOAP_FMAC4 soap_get_PointerTons1__registerReader(struct soap *soap, ns1__registerReader **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__registerReader(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__exceedFine1Response(struct soap *soap, ns1__exceedFine1Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__exceedFine1Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__exceedFine1Response(struct soap *soap, const char *tag, int id, ns1__exceedFine1Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__exceedFine1Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__exceedFine1Response ** SOAP_FMAC4 soap_in_PointerTons1__exceedFine1Response(struct soap *soap, const char *tag, ns1__exceedFine1Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__exceedFine1Response **)soap_malloc(soap, sizeof(ns1__exceedFine1Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__exceedFine1Response *)soap_instantiate_ns1__exceedFine1Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__exceedFine1Response ** p = (ns1__exceedFine1Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__exceedFine1Response, sizeof(ns1__exceedFine1Response), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__exceedFine1Response(struct soap *soap, ns1__exceedFine1Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__exceedFine1Response);
	if (soap_out_PointerTons1__exceedFine1Response(soap, tag?tag:"ns1:exceedFine1Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__exceedFine1Response ** SOAP_FMAC4 soap_get_PointerTons1__exceedFine1Response(struct soap *soap, ns1__exceedFine1Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__exceedFine1Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__exceedFine1(struct soap *soap, ns1__exceedFine1 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__exceedFine1))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__exceedFine1(struct soap *soap, const char *tag, int id, ns1__exceedFine1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__exceedFine1);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__exceedFine1 ** SOAP_FMAC4 soap_in_PointerTons1__exceedFine1(struct soap *soap, const char *tag, ns1__exceedFine1 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__exceedFine1 **)soap_malloc(soap, sizeof(ns1__exceedFine1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__exceedFine1 *)soap_instantiate_ns1__exceedFine1(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__exceedFine1 ** p = (ns1__exceedFine1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__exceedFine1, sizeof(ns1__exceedFine1), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__exceedFine1(struct soap *soap, ns1__exceedFine1 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__exceedFine1);
	if (soap_out_PointerTons1__exceedFine1(soap, tag?tag:"ns1:exceedFine1", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__exceedFine1 ** SOAP_FMAC4 soap_get_PointerTons1__exceedFine1(struct soap *soap, ns1__exceedFine1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__exceedFine1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getViolations1Response(struct soap *soap, ns1__getViolations1Response *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getViolations1Response))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getViolations1Response(struct soap *soap, const char *tag, int id, ns1__getViolations1Response *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getViolations1Response);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getViolations1Response ** SOAP_FMAC4 soap_in_PointerTons1__getViolations1Response(struct soap *soap, const char *tag, ns1__getViolations1Response **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getViolations1Response **)soap_malloc(soap, sizeof(ns1__getViolations1Response *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getViolations1Response *)soap_instantiate_ns1__getViolations1Response(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getViolations1Response ** p = (ns1__getViolations1Response **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getViolations1Response, sizeof(ns1__getViolations1Response), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getViolations1Response(struct soap *soap, ns1__getViolations1Response *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getViolations1Response);
	if (soap_out_PointerTons1__getViolations1Response(soap, tag?tag:"ns1:getViolations1Response", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getViolations1Response ** SOAP_FMAC4 soap_get_PointerTons1__getViolations1Response(struct soap *soap, ns1__getViolations1Response **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getViolations1Response(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getViolations1(struct soap *soap, ns1__getViolations1 *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getViolations1))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getViolations1(struct soap *soap, const char *tag, int id, ns1__getViolations1 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getViolations1);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getViolations1 ** SOAP_FMAC4 soap_in_PointerTons1__getViolations1(struct soap *soap, const char *tag, ns1__getViolations1 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getViolations1 **)soap_malloc(soap, sizeof(ns1__getViolations1 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getViolations1 *)soap_instantiate_ns1__getViolations1(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getViolations1 ** p = (ns1__getViolations1 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getViolations1, sizeof(ns1__getViolations1), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getViolations1(struct soap *soap, ns1__getViolations1 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getViolations1);
	if (soap_out_PointerTons1__getViolations1(soap, tag?tag:"ns1:getViolations1", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getViolations1 ** SOAP_FMAC4 soap_get_PointerTons1__getViolations1(struct soap *soap, ns1__getViolations1 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getViolations1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__voltFineResponse(struct soap *soap, ns1__voltFineResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__voltFineResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__voltFineResponse(struct soap *soap, const char *tag, int id, ns1__voltFineResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__voltFineResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__voltFineResponse ** SOAP_FMAC4 soap_in_PointerTons1__voltFineResponse(struct soap *soap, const char *tag, ns1__voltFineResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__voltFineResponse **)soap_malloc(soap, sizeof(ns1__voltFineResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__voltFineResponse *)soap_instantiate_ns1__voltFineResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__voltFineResponse ** p = (ns1__voltFineResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__voltFineResponse, sizeof(ns1__voltFineResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__voltFineResponse(struct soap *soap, ns1__voltFineResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__voltFineResponse);
	if (soap_out_PointerTons1__voltFineResponse(soap, tag?tag:"ns1:voltFineResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__voltFineResponse ** SOAP_FMAC4 soap_get_PointerTons1__voltFineResponse(struct soap *soap, ns1__voltFineResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__voltFineResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__voltFine(struct soap *soap, ns1__voltFine *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__voltFine))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__voltFine(struct soap *soap, const char *tag, int id, ns1__voltFine *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__voltFine);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__voltFine ** SOAP_FMAC4 soap_in_PointerTons1__voltFine(struct soap *soap, const char *tag, ns1__voltFine **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__voltFine **)soap_malloc(soap, sizeof(ns1__voltFine *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__voltFine *)soap_instantiate_ns1__voltFine(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__voltFine ** p = (ns1__voltFine **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__voltFine, sizeof(ns1__voltFine), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__voltFine(struct soap *soap, ns1__voltFine *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__voltFine);
	if (soap_out_PointerTons1__voltFine(soap, tag?tag:"ns1:voltFine", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__voltFine ** SOAP_FMAC4 soap_get_PointerTons1__voltFine(struct soap *soap, ns1__voltFine **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__voltFine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__checkReaderResponse(struct soap *soap, ns1__checkReaderResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__checkReaderResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__checkReaderResponse(struct soap *soap, const char *tag, int id, ns1__checkReaderResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__checkReaderResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__checkReaderResponse ** SOAP_FMAC4 soap_in_PointerTons1__checkReaderResponse(struct soap *soap, const char *tag, ns1__checkReaderResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__checkReaderResponse **)soap_malloc(soap, sizeof(ns1__checkReaderResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__checkReaderResponse *)soap_instantiate_ns1__checkReaderResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__checkReaderResponse ** p = (ns1__checkReaderResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__checkReaderResponse, sizeof(ns1__checkReaderResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__checkReaderResponse(struct soap *soap, ns1__checkReaderResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__checkReaderResponse);
	if (soap_out_PointerTons1__checkReaderResponse(soap, tag?tag:"ns1:checkReaderResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__checkReaderResponse ** SOAP_FMAC4 soap_get_PointerTons1__checkReaderResponse(struct soap *soap, ns1__checkReaderResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__checkReaderResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__checkReader(struct soap *soap, ns1__checkReader *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__checkReader))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__checkReader(struct soap *soap, const char *tag, int id, ns1__checkReader *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__checkReader);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__checkReader ** SOAP_FMAC4 soap_in_PointerTons1__checkReader(struct soap *soap, const char *tag, ns1__checkReader **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__checkReader **)soap_malloc(soap, sizeof(ns1__checkReader *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__checkReader *)soap_instantiate_ns1__checkReader(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__checkReader ** p = (ns1__checkReader **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__checkReader, sizeof(ns1__checkReader), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__checkReader(struct soap *soap, ns1__checkReader *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__checkReader);
	if (soap_out_PointerTons1__checkReader(soap, tag?tag:"ns1:checkReader", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__checkReader ** SOAP_FMAC4 soap_get_PointerTons1__checkReader(struct soap *soap, ns1__checkReader **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__checkReader(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getMarcResponse(struct soap *soap, ns1__getMarcResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getMarcResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getMarcResponse(struct soap *soap, const char *tag, int id, ns1__getMarcResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getMarcResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getMarcResponse ** SOAP_FMAC4 soap_in_PointerTons1__getMarcResponse(struct soap *soap, const char *tag, ns1__getMarcResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getMarcResponse **)soap_malloc(soap, sizeof(ns1__getMarcResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getMarcResponse *)soap_instantiate_ns1__getMarcResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getMarcResponse ** p = (ns1__getMarcResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getMarcResponse, sizeof(ns1__getMarcResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getMarcResponse(struct soap *soap, ns1__getMarcResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getMarcResponse);
	if (soap_out_PointerTons1__getMarcResponse(soap, tag?tag:"ns1:getMarcResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getMarcResponse ** SOAP_FMAC4 soap_get_PointerTons1__getMarcResponse(struct soap *soap, ns1__getMarcResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getMarcResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getMarc(struct soap *soap, ns1__getMarc *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getMarc))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getMarc(struct soap *soap, const char *tag, int id, ns1__getMarc *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getMarc);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getMarc ** SOAP_FMAC4 soap_in_PointerTons1__getMarc(struct soap *soap, const char *tag, ns1__getMarc **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getMarc **)soap_malloc(soap, sizeof(ns1__getMarc *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getMarc *)soap_instantiate_ns1__getMarc(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getMarc ** p = (ns1__getMarc **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getMarc, sizeof(ns1__getMarc), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getMarc(struct soap *soap, ns1__getMarc *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getMarc);
	if (soap_out_PointerTons1__getMarc(soap, tag?tag:"ns1:getMarc", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getMarc ** SOAP_FMAC4 soap_get_PointerTons1__getMarc(struct soap *soap, ns1__getMarc **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getMarc(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getLendHistResponse(struct soap *soap, ns1__getLendHistResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getLendHistResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getLendHistResponse(struct soap *soap, const char *tag, int id, ns1__getLendHistResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getLendHistResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getLendHistResponse ** SOAP_FMAC4 soap_in_PointerTons1__getLendHistResponse(struct soap *soap, const char *tag, ns1__getLendHistResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getLendHistResponse **)soap_malloc(soap, sizeof(ns1__getLendHistResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getLendHistResponse *)soap_instantiate_ns1__getLendHistResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getLendHistResponse ** p = (ns1__getLendHistResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getLendHistResponse, sizeof(ns1__getLendHistResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getLendHistResponse(struct soap *soap, ns1__getLendHistResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getLendHistResponse);
	if (soap_out_PointerTons1__getLendHistResponse(soap, tag?tag:"ns1:getLendHistResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getLendHistResponse ** SOAP_FMAC4 soap_get_PointerTons1__getLendHistResponse(struct soap *soap, ns1__getLendHistResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getLendHistResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getLendHist(struct soap *soap, ns1__getLendHist *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getLendHist))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getLendHist(struct soap *soap, const char *tag, int id, ns1__getLendHist *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getLendHist);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getLendHist ** SOAP_FMAC4 soap_in_PointerTons1__getLendHist(struct soap *soap, const char *tag, ns1__getLendHist **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getLendHist **)soap_malloc(soap, sizeof(ns1__getLendHist *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getLendHist *)soap_instantiate_ns1__getLendHist(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getLendHist ** p = (ns1__getLendHist **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getLendHist, sizeof(ns1__getLendHist), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getLendHist(struct soap *soap, ns1__getLendHist *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getLendHist);
	if (soap_out_PointerTons1__getLendHist(soap, tag?tag:"ns1:getLendHist", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getLendHist ** SOAP_FMAC4 soap_get_PointerTons1__getLendHist(struct soap *soap, ns1__getLendHist **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getLendHist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__logoutResponse(struct soap *soap, ns1__logoutResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__logoutResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__logoutResponse(struct soap *soap, const char *tag, int id, ns1__logoutResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__logoutResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__logoutResponse ** SOAP_FMAC4 soap_in_PointerTons1__logoutResponse(struct soap *soap, const char *tag, ns1__logoutResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__logoutResponse **)soap_malloc(soap, sizeof(ns1__logoutResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__logoutResponse *)soap_instantiate_ns1__logoutResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__logoutResponse ** p = (ns1__logoutResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__logoutResponse, sizeof(ns1__logoutResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__logoutResponse(struct soap *soap, ns1__logoutResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__logoutResponse);
	if (soap_out_PointerTons1__logoutResponse(soap, tag?tag:"ns1:logoutResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__logoutResponse ** SOAP_FMAC4 soap_get_PointerTons1__logoutResponse(struct soap *soap, ns1__logoutResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__logoutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__logout(struct soap *soap, ns1__logout *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__logout))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__logout(struct soap *soap, const char *tag, int id, ns1__logout *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__logout);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__logout ** SOAP_FMAC4 soap_in_PointerTons1__logout(struct soap *soap, const char *tag, ns1__logout **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__logout **)soap_malloc(soap, sizeof(ns1__logout *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__logout *)soap_instantiate_ns1__logout(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__logout ** p = (ns1__logout **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__logout, sizeof(ns1__logout), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__logout(struct soap *soap, ns1__logout *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__logout);
	if (soap_out_PointerTons1__logout(soap, tag?tag:"ns1:logout", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__logout ** SOAP_FMAC4 soap_get_PointerTons1__logout(struct soap *soap, ns1__logout **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__logout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__certLossResponse(struct soap *soap, ns1__certLossResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__certLossResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__certLossResponse(struct soap *soap, const char *tag, int id, ns1__certLossResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__certLossResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__certLossResponse ** SOAP_FMAC4 soap_in_PointerTons1__certLossResponse(struct soap *soap, const char *tag, ns1__certLossResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__certLossResponse **)soap_malloc(soap, sizeof(ns1__certLossResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__certLossResponse *)soap_instantiate_ns1__certLossResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__certLossResponse ** p = (ns1__certLossResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__certLossResponse, sizeof(ns1__certLossResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__certLossResponse(struct soap *soap, ns1__certLossResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__certLossResponse);
	if (soap_out_PointerTons1__certLossResponse(soap, tag?tag:"ns1:certLossResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__certLossResponse ** SOAP_FMAC4 soap_get_PointerTons1__certLossResponse(struct soap *soap, ns1__certLossResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__certLossResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__certLoss(struct soap *soap, ns1__certLoss *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__certLoss))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__certLoss(struct soap *soap, const char *tag, int id, ns1__certLoss *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__certLoss);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__certLoss ** SOAP_FMAC4 soap_in_PointerTons1__certLoss(struct soap *soap, const char *tag, ns1__certLoss **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__certLoss **)soap_malloc(soap, sizeof(ns1__certLoss *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__certLoss *)soap_instantiate_ns1__certLoss(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__certLoss ** p = (ns1__certLoss **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__certLoss, sizeof(ns1__certLoss), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__certLoss(struct soap *soap, ns1__certLoss *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__certLoss);
	if (soap_out_PointerTons1__certLoss(soap, tag?tag:"ns1:certLoss", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__certLoss ** SOAP_FMAC4 soap_get_PointerTons1__certLoss(struct soap *soap, ns1__certLoss **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__certLoss(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__exceedFineResponse(struct soap *soap, ns1__exceedFineResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__exceedFineResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__exceedFineResponse(struct soap *soap, const char *tag, int id, ns1__exceedFineResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__exceedFineResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__exceedFineResponse ** SOAP_FMAC4 soap_in_PointerTons1__exceedFineResponse(struct soap *soap, const char *tag, ns1__exceedFineResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__exceedFineResponse **)soap_malloc(soap, sizeof(ns1__exceedFineResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__exceedFineResponse *)soap_instantiate_ns1__exceedFineResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__exceedFineResponse ** p = (ns1__exceedFineResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__exceedFineResponse, sizeof(ns1__exceedFineResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__exceedFineResponse(struct soap *soap, ns1__exceedFineResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__exceedFineResponse);
	if (soap_out_PointerTons1__exceedFineResponse(soap, tag?tag:"ns1:exceedFineResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__exceedFineResponse ** SOAP_FMAC4 soap_get_PointerTons1__exceedFineResponse(struct soap *soap, ns1__exceedFineResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__exceedFineResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__exceedFine(struct soap *soap, ns1__exceedFine *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__exceedFine))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__exceedFine(struct soap *soap, const char *tag, int id, ns1__exceedFine *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__exceedFine);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__exceedFine ** SOAP_FMAC4 soap_in_PointerTons1__exceedFine(struct soap *soap, const char *tag, ns1__exceedFine **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__exceedFine **)soap_malloc(soap, sizeof(ns1__exceedFine *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__exceedFine *)soap_instantiate_ns1__exceedFine(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__exceedFine ** p = (ns1__exceedFine **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__exceedFine, sizeof(ns1__exceedFine), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__exceedFine(struct soap *soap, ns1__exceedFine *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__exceedFine);
	if (soap_out_PointerTons1__exceedFine(soap, tag?tag:"ns1:exceedFine", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__exceedFine ** SOAP_FMAC4 soap_get_PointerTons1__exceedFine(struct soap *soap, ns1__exceedFine **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__exceedFine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getLostPaysResponse(struct soap *soap, ns1__getLostPaysResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getLostPaysResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getLostPaysResponse(struct soap *soap, const char *tag, int id, ns1__getLostPaysResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getLostPaysResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getLostPaysResponse ** SOAP_FMAC4 soap_in_PointerTons1__getLostPaysResponse(struct soap *soap, const char *tag, ns1__getLostPaysResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getLostPaysResponse **)soap_malloc(soap, sizeof(ns1__getLostPaysResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getLostPaysResponse *)soap_instantiate_ns1__getLostPaysResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getLostPaysResponse ** p = (ns1__getLostPaysResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getLostPaysResponse, sizeof(ns1__getLostPaysResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getLostPaysResponse(struct soap *soap, ns1__getLostPaysResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getLostPaysResponse);
	if (soap_out_PointerTons1__getLostPaysResponse(soap, tag?tag:"ns1:getLostPaysResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getLostPaysResponse ** SOAP_FMAC4 soap_get_PointerTons1__getLostPaysResponse(struct soap *soap, ns1__getLostPaysResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getLostPaysResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getLostPays(struct soap *soap, ns1__getLostPays *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getLostPays))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getLostPays(struct soap *soap, const char *tag, int id, ns1__getLostPays *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getLostPays);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getLostPays ** SOAP_FMAC4 soap_in_PointerTons1__getLostPays(struct soap *soap, const char *tag, ns1__getLostPays **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getLostPays **)soap_malloc(soap, sizeof(ns1__getLostPays *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getLostPays *)soap_instantiate_ns1__getLostPays(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getLostPays ** p = (ns1__getLostPays **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getLostPays, sizeof(ns1__getLostPays), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getLostPays(struct soap *soap, ns1__getLostPays *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getLostPays);
	if (soap_out_PointerTons1__getLostPays(soap, tag?tag:"ns1:getLostPays", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getLostPays ** SOAP_FMAC4 soap_get_PointerTons1__getLostPays(struct soap *soap, ns1__getLostPays **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getLostPays(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getAccountsResponse(struct soap *soap, ns1__getAccountsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getAccountsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getAccountsResponse(struct soap *soap, const char *tag, int id, ns1__getAccountsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getAccountsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getAccountsResponse ** SOAP_FMAC4 soap_in_PointerTons1__getAccountsResponse(struct soap *soap, const char *tag, ns1__getAccountsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getAccountsResponse **)soap_malloc(soap, sizeof(ns1__getAccountsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getAccountsResponse *)soap_instantiate_ns1__getAccountsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getAccountsResponse ** p = (ns1__getAccountsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getAccountsResponse, sizeof(ns1__getAccountsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getAccountsResponse(struct soap *soap, ns1__getAccountsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getAccountsResponse);
	if (soap_out_PointerTons1__getAccountsResponse(soap, tag?tag:"ns1:getAccountsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getAccountsResponse ** SOAP_FMAC4 soap_get_PointerTons1__getAccountsResponse(struct soap *soap, ns1__getAccountsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getAccountsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getAccounts(struct soap *soap, ns1__getAccounts *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getAccounts))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getAccounts(struct soap *soap, const char *tag, int id, ns1__getAccounts *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getAccounts);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getAccounts ** SOAP_FMAC4 soap_in_PointerTons1__getAccounts(struct soap *soap, const char *tag, ns1__getAccounts **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getAccounts **)soap_malloc(soap, sizeof(ns1__getAccounts *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getAccounts *)soap_instantiate_ns1__getAccounts(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getAccounts ** p = (ns1__getAccounts **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getAccounts, sizeof(ns1__getAccounts), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getAccounts(struct soap *soap, ns1__getAccounts *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getAccounts);
	if (soap_out_PointerTons1__getAccounts(soap, tag?tag:"ns1:getAccounts", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getAccounts ** SOAP_FMAC4 soap_get_PointerTons1__getAccounts(struct soap *soap, ns1__getAccounts **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getAccounts(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getRelegatesResponse(struct soap *soap, ns1__getRelegatesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getRelegatesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getRelegatesResponse(struct soap *soap, const char *tag, int id, ns1__getRelegatesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getRelegatesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getRelegatesResponse ** SOAP_FMAC4 soap_in_PointerTons1__getRelegatesResponse(struct soap *soap, const char *tag, ns1__getRelegatesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getRelegatesResponse **)soap_malloc(soap, sizeof(ns1__getRelegatesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getRelegatesResponse *)soap_instantiate_ns1__getRelegatesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getRelegatesResponse ** p = (ns1__getRelegatesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getRelegatesResponse, sizeof(ns1__getRelegatesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getRelegatesResponse(struct soap *soap, ns1__getRelegatesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getRelegatesResponse);
	if (soap_out_PointerTons1__getRelegatesResponse(soap, tag?tag:"ns1:getRelegatesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getRelegatesResponse ** SOAP_FMAC4 soap_get_PointerTons1__getRelegatesResponse(struct soap *soap, ns1__getRelegatesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getRelegatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getRelegates(struct soap *soap, ns1__getRelegates *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getRelegates))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getRelegates(struct soap *soap, const char *tag, int id, ns1__getRelegates *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getRelegates);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getRelegates ** SOAP_FMAC4 soap_in_PointerTons1__getRelegates(struct soap *soap, const char *tag, ns1__getRelegates **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getRelegates **)soap_malloc(soap, sizeof(ns1__getRelegates *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getRelegates *)soap_instantiate_ns1__getRelegates(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getRelegates ** p = (ns1__getRelegates **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getRelegates, sizeof(ns1__getRelegates), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getRelegates(struct soap *soap, ns1__getRelegates *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getRelegates);
	if (soap_out_PointerTons1__getRelegates(soap, tag?tag:"ns1:getRelegates", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getRelegates ** SOAP_FMAC4 soap_get_PointerTons1__getRelegates(struct soap *soap, ns1__getRelegates **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getRelegates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getPregsResponse(struct soap *soap, ns1__getPregsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getPregsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getPregsResponse(struct soap *soap, const char *tag, int id, ns1__getPregsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getPregsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getPregsResponse ** SOAP_FMAC4 soap_in_PointerTons1__getPregsResponse(struct soap *soap, const char *tag, ns1__getPregsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getPregsResponse **)soap_malloc(soap, sizeof(ns1__getPregsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getPregsResponse *)soap_instantiate_ns1__getPregsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getPregsResponse ** p = (ns1__getPregsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getPregsResponse, sizeof(ns1__getPregsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getPregsResponse(struct soap *soap, ns1__getPregsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getPregsResponse);
	if (soap_out_PointerTons1__getPregsResponse(soap, tag?tag:"ns1:getPregsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getPregsResponse ** SOAP_FMAC4 soap_get_PointerTons1__getPregsResponse(struct soap *soap, ns1__getPregsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getPregsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getPregs(struct soap *soap, ns1__getPregs *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getPregs))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getPregs(struct soap *soap, const char *tag, int id, ns1__getPregs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getPregs);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getPregs ** SOAP_FMAC4 soap_in_PointerTons1__getPregs(struct soap *soap, const char *tag, ns1__getPregs **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getPregs **)soap_malloc(soap, sizeof(ns1__getPregs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getPregs *)soap_instantiate_ns1__getPregs(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getPregs ** p = (ns1__getPregs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getPregs, sizeof(ns1__getPregs), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getPregs(struct soap *soap, ns1__getPregs *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getPregs);
	if (soap_out_PointerTons1__getPregs(soap, tag?tag:"ns1:getPregs", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getPregs ** SOAP_FMAC4 soap_get_PointerTons1__getPregs(struct soap *soap, ns1__getPregs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getPregs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getRelegateArrivalsResponse(struct soap *soap, ns1__getRelegateArrivalsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getRelegateArrivalsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getRelegateArrivalsResponse(struct soap *soap, const char *tag, int id, ns1__getRelegateArrivalsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getRelegateArrivalsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getRelegateArrivalsResponse ** SOAP_FMAC4 soap_in_PointerTons1__getRelegateArrivalsResponse(struct soap *soap, const char *tag, ns1__getRelegateArrivalsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getRelegateArrivalsResponse **)soap_malloc(soap, sizeof(ns1__getRelegateArrivalsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getRelegateArrivalsResponse *)soap_instantiate_ns1__getRelegateArrivalsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getRelegateArrivalsResponse ** p = (ns1__getRelegateArrivalsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getRelegateArrivalsResponse, sizeof(ns1__getRelegateArrivalsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getRelegateArrivalsResponse(struct soap *soap, ns1__getRelegateArrivalsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getRelegateArrivalsResponse);
	if (soap_out_PointerTons1__getRelegateArrivalsResponse(soap, tag?tag:"ns1:getRelegateArrivalsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getRelegateArrivalsResponse ** SOAP_FMAC4 soap_get_PointerTons1__getRelegateArrivalsResponse(struct soap *soap, ns1__getRelegateArrivalsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getRelegateArrivalsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getRelegateArrivals(struct soap *soap, ns1__getRelegateArrivals *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getRelegateArrivals))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getRelegateArrivals(struct soap *soap, const char *tag, int id, ns1__getRelegateArrivals *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getRelegateArrivals);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getRelegateArrivals ** SOAP_FMAC4 soap_in_PointerTons1__getRelegateArrivals(struct soap *soap, const char *tag, ns1__getRelegateArrivals **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getRelegateArrivals **)soap_malloc(soap, sizeof(ns1__getRelegateArrivals *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getRelegateArrivals *)soap_instantiate_ns1__getRelegateArrivals(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getRelegateArrivals ** p = (ns1__getRelegateArrivals **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getRelegateArrivals, sizeof(ns1__getRelegateArrivals), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getRelegateArrivals(struct soap *soap, ns1__getRelegateArrivals *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getRelegateArrivals);
	if (soap_out_PointerTons1__getRelegateArrivals(soap, tag?tag:"ns1:getRelegateArrivals", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getRelegateArrivals ** SOAP_FMAC4 soap_get_PointerTons1__getRelegateArrivals(struct soap *soap, ns1__getRelegateArrivals **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getRelegateArrivals(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getPregArrivalsResponse(struct soap *soap, ns1__getPregArrivalsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getPregArrivalsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getPregArrivalsResponse(struct soap *soap, const char *tag, int id, ns1__getPregArrivalsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getPregArrivalsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getPregArrivalsResponse ** SOAP_FMAC4 soap_in_PointerTons1__getPregArrivalsResponse(struct soap *soap, const char *tag, ns1__getPregArrivalsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getPregArrivalsResponse **)soap_malloc(soap, sizeof(ns1__getPregArrivalsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getPregArrivalsResponse *)soap_instantiate_ns1__getPregArrivalsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getPregArrivalsResponse ** p = (ns1__getPregArrivalsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getPregArrivalsResponse, sizeof(ns1__getPregArrivalsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getPregArrivalsResponse(struct soap *soap, ns1__getPregArrivalsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getPregArrivalsResponse);
	if (soap_out_PointerTons1__getPregArrivalsResponse(soap, tag?tag:"ns1:getPregArrivalsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getPregArrivalsResponse ** SOAP_FMAC4 soap_get_PointerTons1__getPregArrivalsResponse(struct soap *soap, ns1__getPregArrivalsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getPregArrivalsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getPregArrivals(struct soap *soap, ns1__getPregArrivals *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getPregArrivals))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getPregArrivals(struct soap *soap, const char *tag, int id, ns1__getPregArrivals *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getPregArrivals);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getPregArrivals ** SOAP_FMAC4 soap_in_PointerTons1__getPregArrivals(struct soap *soap, const char *tag, ns1__getPregArrivals **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getPregArrivals **)soap_malloc(soap, sizeof(ns1__getPregArrivals *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getPregArrivals *)soap_instantiate_ns1__getPregArrivals(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getPregArrivals ** p = (ns1__getPregArrivals **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getPregArrivals, sizeof(ns1__getPregArrivals), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getPregArrivals(struct soap *soap, ns1__getPregArrivals *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getPregArrivals);
	if (soap_out_PointerTons1__getPregArrivals(soap, tag?tag:"ns1:getPregArrivals", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getPregArrivals ** SOAP_FMAC4 soap_get_PointerTons1__getPregArrivals(struct soap *soap, ns1__getPregArrivals **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getPregArrivals(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getDebtsResponse(struct soap *soap, ns1__getDebtsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getDebtsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getDebtsResponse(struct soap *soap, const char *tag, int id, ns1__getDebtsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getDebtsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getDebtsResponse ** SOAP_FMAC4 soap_in_PointerTons1__getDebtsResponse(struct soap *soap, const char *tag, ns1__getDebtsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getDebtsResponse **)soap_malloc(soap, sizeof(ns1__getDebtsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getDebtsResponse *)soap_instantiate_ns1__getDebtsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getDebtsResponse ** p = (ns1__getDebtsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getDebtsResponse, sizeof(ns1__getDebtsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getDebtsResponse(struct soap *soap, ns1__getDebtsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getDebtsResponse);
	if (soap_out_PointerTons1__getDebtsResponse(soap, tag?tag:"ns1:getDebtsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getDebtsResponse ** SOAP_FMAC4 soap_get_PointerTons1__getDebtsResponse(struct soap *soap, ns1__getDebtsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getDebtsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getDebts(struct soap *soap, ns1__getDebts *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getDebts))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getDebts(struct soap *soap, const char *tag, int id, ns1__getDebts *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getDebts);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getDebts ** SOAP_FMAC4 soap_in_PointerTons1__getDebts(struct soap *soap, const char *tag, ns1__getDebts **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getDebts **)soap_malloc(soap, sizeof(ns1__getDebts *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getDebts *)soap_instantiate_ns1__getDebts(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getDebts ** p = (ns1__getDebts **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getDebts, sizeof(ns1__getDebts), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getDebts(struct soap *soap, ns1__getDebts *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getDebts);
	if (soap_out_PointerTons1__getDebts(soap, tag?tag:"ns1:getDebts", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getDebts ** SOAP_FMAC4 soap_get_PointerTons1__getDebts(struct soap *soap, ns1__getDebts **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getDebts(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getViolationsResponse(struct soap *soap, ns1__getViolationsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getViolationsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getViolationsResponse(struct soap *soap, const char *tag, int id, ns1__getViolationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getViolationsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getViolationsResponse ** SOAP_FMAC4 soap_in_PointerTons1__getViolationsResponse(struct soap *soap, const char *tag, ns1__getViolationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getViolationsResponse **)soap_malloc(soap, sizeof(ns1__getViolationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getViolationsResponse *)soap_instantiate_ns1__getViolationsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getViolationsResponse ** p = (ns1__getViolationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getViolationsResponse, sizeof(ns1__getViolationsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getViolationsResponse(struct soap *soap, ns1__getViolationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getViolationsResponse);
	if (soap_out_PointerTons1__getViolationsResponse(soap, tag?tag:"ns1:getViolationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getViolationsResponse ** SOAP_FMAC4 soap_get_PointerTons1__getViolationsResponse(struct soap *soap, ns1__getViolationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getViolationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getViolations(struct soap *soap, ns1__getViolations *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getViolations))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getViolations(struct soap *soap, const char *tag, int id, ns1__getViolations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getViolations);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getViolations ** SOAP_FMAC4 soap_in_PointerTons1__getViolations(struct soap *soap, const char *tag, ns1__getViolations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getViolations **)soap_malloc(soap, sizeof(ns1__getViolations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getViolations *)soap_instantiate_ns1__getViolations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getViolations ** p = (ns1__getViolations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getViolations, sizeof(ns1__getViolations), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getViolations(struct soap *soap, ns1__getViolations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getViolations);
	if (soap_out_PointerTons1__getViolations(soap, tag?tag:"ns1:getViolations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getViolations ** SOAP_FMAC4 soap_get_PointerTons1__getViolations(struct soap *soap, ns1__getViolations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getViolations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getCircsResponse(struct soap *soap, ns1__getCircsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getCircsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getCircsResponse(struct soap *soap, const char *tag, int id, ns1__getCircsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getCircsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getCircsResponse ** SOAP_FMAC4 soap_in_PointerTons1__getCircsResponse(struct soap *soap, const char *tag, ns1__getCircsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getCircsResponse **)soap_malloc(soap, sizeof(ns1__getCircsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getCircsResponse *)soap_instantiate_ns1__getCircsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getCircsResponse ** p = (ns1__getCircsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getCircsResponse, sizeof(ns1__getCircsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getCircsResponse(struct soap *soap, ns1__getCircsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getCircsResponse);
	if (soap_out_PointerTons1__getCircsResponse(soap, tag?tag:"ns1:getCircsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getCircsResponse ** SOAP_FMAC4 soap_get_PointerTons1__getCircsResponse(struct soap *soap, ns1__getCircsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getCircsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getCircs(struct soap *soap, ns1__getCircs *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getCircs))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getCircs(struct soap *soap, const char *tag, int id, ns1__getCircs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getCircs);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getCircs ** SOAP_FMAC4 soap_in_PointerTons1__getCircs(struct soap *soap, const char *tag, ns1__getCircs **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getCircs **)soap_malloc(soap, sizeof(ns1__getCircs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getCircs *)soap_instantiate_ns1__getCircs(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getCircs ** p = (ns1__getCircs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getCircs, sizeof(ns1__getCircs), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getCircs(struct soap *soap, ns1__getCircs *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getCircs);
	if (soap_out_PointerTons1__getCircs(soap, tag?tag:"ns1:getCircs", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getCircs ** SOAP_FMAC4 soap_get_PointerTons1__getCircs(struct soap *soap, ns1__getCircs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getCircs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getBookResponse(struct soap *soap, ns1__getBookResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getBookResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getBookResponse(struct soap *soap, const char *tag, int id, ns1__getBookResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getBookResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getBookResponse ** SOAP_FMAC4 soap_in_PointerTons1__getBookResponse(struct soap *soap, const char *tag, ns1__getBookResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getBookResponse **)soap_malloc(soap, sizeof(ns1__getBookResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getBookResponse *)soap_instantiate_ns1__getBookResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getBookResponse ** p = (ns1__getBookResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getBookResponse, sizeof(ns1__getBookResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getBookResponse(struct soap *soap, ns1__getBookResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getBookResponse);
	if (soap_out_PointerTons1__getBookResponse(soap, tag?tag:"ns1:getBookResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getBookResponse ** SOAP_FMAC4 soap_get_PointerTons1__getBookResponse(struct soap *soap, ns1__getBookResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getBookResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getBook(struct soap *soap, ns1__getBook *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getBook))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getBook(struct soap *soap, const char *tag, int id, ns1__getBook *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getBook);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getBook ** SOAP_FMAC4 soap_in_PointerTons1__getBook(struct soap *soap, const char *tag, ns1__getBook **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getBook **)soap_malloc(soap, sizeof(ns1__getBook *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getBook *)soap_instantiate_ns1__getBook(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getBook ** p = (ns1__getBook **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getBook, sizeof(ns1__getBook), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getBook(struct soap *soap, ns1__getBook *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getBook);
	if (soap_out_PointerTons1__getBook(soap, tag?tag:"ns1:getBook", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getBook ** SOAP_FMAC4 soap_get_PointerTons1__getBook(struct soap *soap, ns1__getBook **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getBook(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getItemsResponse(struct soap *soap, ns1__getItemsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getItemsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getItemsResponse(struct soap *soap, const char *tag, int id, ns1__getItemsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getItemsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getItemsResponse ** SOAP_FMAC4 soap_in_PointerTons1__getItemsResponse(struct soap *soap, const char *tag, ns1__getItemsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getItemsResponse **)soap_malloc(soap, sizeof(ns1__getItemsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getItemsResponse *)soap_instantiate_ns1__getItemsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getItemsResponse ** p = (ns1__getItemsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getItemsResponse, sizeof(ns1__getItemsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getItemsResponse(struct soap *soap, ns1__getItemsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getItemsResponse);
	if (soap_out_PointerTons1__getItemsResponse(soap, tag?tag:"ns1:getItemsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getItemsResponse ** SOAP_FMAC4 soap_get_PointerTons1__getItemsResponse(struct soap *soap, ns1__getItemsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getItemsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getItems(struct soap *soap, ns1__getItems *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getItems))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getItems(struct soap *soap, const char *tag, int id, ns1__getItems *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getItems);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getItems ** SOAP_FMAC4 soap_in_PointerTons1__getItems(struct soap *soap, const char *tag, ns1__getItems **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getItems **)soap_malloc(soap, sizeof(ns1__getItems *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getItems *)soap_instantiate_ns1__getItems(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getItems ** p = (ns1__getItems **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getItems, sizeof(ns1__getItems), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getItems(struct soap *soap, ns1__getItems *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getItems);
	if (soap_out_PointerTons1__getItems(soap, tag?tag:"ns1:getItems", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getItems ** SOAP_FMAC4 soap_get_PointerTons1__getItems(struct soap *soap, ns1__getItems **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getItems(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getReaderResponse(struct soap *soap, ns1__getReaderResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getReaderResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getReaderResponse(struct soap *soap, const char *tag, int id, ns1__getReaderResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getReaderResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getReaderResponse ** SOAP_FMAC4 soap_in_PointerTons1__getReaderResponse(struct soap *soap, const char *tag, ns1__getReaderResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getReaderResponse **)soap_malloc(soap, sizeof(ns1__getReaderResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getReaderResponse *)soap_instantiate_ns1__getReaderResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getReaderResponse ** p = (ns1__getReaderResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getReaderResponse, sizeof(ns1__getReaderResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getReaderResponse(struct soap *soap, ns1__getReaderResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getReaderResponse);
	if (soap_out_PointerTons1__getReaderResponse(soap, tag?tag:"ns1:getReaderResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getReaderResponse ** SOAP_FMAC4 soap_get_PointerTons1__getReaderResponse(struct soap *soap, ns1__getReaderResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getReaderResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getReader(struct soap *soap, ns1__getReader *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getReader))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getReader(struct soap *soap, const char *tag, int id, ns1__getReader *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getReader);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getReader ** SOAP_FMAC4 soap_in_PointerTons1__getReader(struct soap *soap, const char *tag, ns1__getReader **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getReader **)soap_malloc(soap, sizeof(ns1__getReader *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getReader *)soap_instantiate_ns1__getReader(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getReader ** p = (ns1__getReader **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getReader, sizeof(ns1__getReader), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getReader(struct soap *soap, ns1__getReader *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getReader);
	if (soap_out_PointerTons1__getReader(soap, tag?tag:"ns1:getReader", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getReader ** SOAP_FMAC4 soap_get_PointerTons1__getReader(struct soap *soap, ns1__getReader **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getReader(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SystemException(struct soap *soap, ns1__SystemException *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SystemException))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SystemException(struct soap *soap, const char *tag, int id, ns1__SystemException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SystemException);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SystemException ** SOAP_FMAC4 soap_in_PointerTons1__SystemException(struct soap *soap, const char *tag, ns1__SystemException **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SystemException **)soap_malloc(soap, sizeof(ns1__SystemException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SystemException *)soap_instantiate_ns1__SystemException(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__SystemException ** p = (ns1__SystemException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SystemException, sizeof(ns1__SystemException), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SystemException(struct soap *soap, ns1__SystemException *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SystemException);
	if (soap_out_PointerTons1__SystemException(soap, tag?tag:"ns1:SystemException", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SystemException ** SOAP_FMAC4 soap_get_PointerTons1__SystemException(struct soap *soap, ns1__SystemException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SystemException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__NoAuthorityException(struct soap *soap, ns1__NoAuthorityException *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__NoAuthorityException))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__NoAuthorityException(struct soap *soap, const char *tag, int id, ns1__NoAuthorityException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__NoAuthorityException);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__NoAuthorityException ** SOAP_FMAC4 soap_in_PointerTons1__NoAuthorityException(struct soap *soap, const char *tag, ns1__NoAuthorityException **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__NoAuthorityException **)soap_malloc(soap, sizeof(ns1__NoAuthorityException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__NoAuthorityException *)soap_instantiate_ns1__NoAuthorityException(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__NoAuthorityException ** p = (ns1__NoAuthorityException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__NoAuthorityException, sizeof(ns1__NoAuthorityException), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__NoAuthorityException(struct soap *soap, ns1__NoAuthorityException *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__NoAuthorityException);
	if (soap_out_PointerTons1__NoAuthorityException(soap, tag?tag:"ns1:NoAuthorityException", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__NoAuthorityException ** SOAP_FMAC4 soap_get_PointerTons1__NoAuthorityException(struct soap *soap, ns1__NoAuthorityException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__NoAuthorityException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__lostPay(struct soap *soap, ns1__lostPay *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__lostPay))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__lostPay(struct soap *soap, const char *tag, int id, ns1__lostPay *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__lostPay);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__lostPay ** SOAP_FMAC4 soap_in_PointerTons1__lostPay(struct soap *soap, const char *tag, ns1__lostPay **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__lostPay **)soap_malloc(soap, sizeof(ns1__lostPay *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__lostPay *)soap_instantiate_ns1__lostPay(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__lostPay ** p = (ns1__lostPay **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__lostPay, sizeof(ns1__lostPay), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__lostPay(struct soap *soap, ns1__lostPay *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__lostPay);
	if (soap_out_PointerTons1__lostPay(soap, tag?tag:"ns1:lostPay", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__lostPay ** SOAP_FMAC4 soap_get_PointerTons1__lostPay(struct soap *soap, ns1__lostPay **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__lostPay(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__preg(struct soap *soap, ns1__preg *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__preg))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__preg(struct soap *soap, const char *tag, int id, ns1__preg *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__preg);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__preg ** SOAP_FMAC4 soap_in_PointerTons1__preg(struct soap *soap, const char *tag, ns1__preg **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__preg **)soap_malloc(soap, sizeof(ns1__preg *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__preg *)soap_instantiate_ns1__preg(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__preg ** p = (ns1__preg **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__preg, sizeof(ns1__preg), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__preg(struct soap *soap, ns1__preg *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__preg);
	if (soap_out_PointerTons1__preg(soap, tag?tag:"ns1:preg", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__preg ** SOAP_FMAC4 soap_get_PointerTons1__preg(struct soap *soap, ns1__preg **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__preg(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__account(struct soap *soap, ns1__account *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__account))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__account(struct soap *soap, const char *tag, int id, ns1__account *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__account);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__account ** SOAP_FMAC4 soap_in_PointerTons1__account(struct soap *soap, const char *tag, ns1__account **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__account **)soap_malloc(soap, sizeof(ns1__account *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__account *)soap_instantiate_ns1__account(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__account ** p = (ns1__account **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__account, sizeof(ns1__account), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__account(struct soap *soap, ns1__account *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__account);
	if (soap_out_PointerTons1__account(soap, tag?tag:"ns1:account", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__account ** SOAP_FMAC4 soap_get_PointerTons1__account(struct soap *soap, ns1__account **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__account(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__marc(struct soap *soap, ns1__marc *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__marc))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__marc(struct soap *soap, const char *tag, int id, ns1__marc *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__marc);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__marc ** SOAP_FMAC4 soap_in_PointerTons1__marc(struct soap *soap, const char *tag, ns1__marc **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__marc **)soap_malloc(soap, sizeof(ns1__marc *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__marc *)soap_instantiate_ns1__marc(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__marc ** p = (ns1__marc **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__marc, sizeof(ns1__marc), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__marc(struct soap *soap, ns1__marc *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__marc);
	if (soap_out_PointerTons1__marc(soap, tag?tag:"ns1:marc", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__marc ** SOAP_FMAC4 soap_get_PointerTons1__marc(struct soap *soap, ns1__marc **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__marc(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__relegate(struct soap *soap, ns1__relegate *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__relegate))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__relegate(struct soap *soap, const char *tag, int id, ns1__relegate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__relegate);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__relegate ** SOAP_FMAC4 soap_in_PointerTons1__relegate(struct soap *soap, const char *tag, ns1__relegate **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__relegate **)soap_malloc(soap, sizeof(ns1__relegate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__relegate *)soap_instantiate_ns1__relegate(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__relegate ** p = (ns1__relegate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__relegate, sizeof(ns1__relegate), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__relegate(struct soap *soap, ns1__relegate *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__relegate);
	if (soap_out_PointerTons1__relegate(soap, tag?tag:"ns1:relegate", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__relegate ** SOAP_FMAC4 soap_get_PointerTons1__relegate(struct soap *soap, ns1__relegate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__relegate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__violation(struct soap *soap, ns1__violation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__violation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__violation(struct soap *soap, const char *tag, int id, ns1__violation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__violation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__violation ** SOAP_FMAC4 soap_in_PointerTons1__violation(struct soap *soap, const char *tag, ns1__violation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__violation **)soap_malloc(soap, sizeof(ns1__violation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__violation *)soap_instantiate_ns1__violation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__violation ** p = (ns1__violation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__violation, sizeof(ns1__violation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__violation(struct soap *soap, ns1__violation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__violation);
	if (soap_out_PointerTons1__violation(soap, tag?tag:"ns1:violation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__violation ** SOAP_FMAC4 soap_get_PointerTons1__violation(struct soap *soap, ns1__violation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__violation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__debt(struct soap *soap, ns1__debt *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__debt))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__debt(struct soap *soap, const char *tag, int id, ns1__debt *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__debt);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__debt ** SOAP_FMAC4 soap_in_PointerTons1__debt(struct soap *soap, const char *tag, ns1__debt **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__debt **)soap_malloc(soap, sizeof(ns1__debt *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__debt *)soap_instantiate_ns1__debt(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__debt ** p = (ns1__debt **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__debt, sizeof(ns1__debt), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__debt(struct soap *soap, ns1__debt *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__debt);
	if (soap_out_PointerTons1__debt(soap, tag?tag:"ns1:debt", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__debt ** SOAP_FMAC4 soap_get_PointerTons1__debt(struct soap *soap, ns1__debt **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__debt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__checkRedrResult(struct soap *soap, ns1__checkRedrResult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__checkRedrResult))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__checkRedrResult(struct soap *soap, const char *tag, int id, ns1__checkRedrResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__checkRedrResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__checkRedrResult ** SOAP_FMAC4 soap_in_PointerTons1__checkRedrResult(struct soap *soap, const char *tag, ns1__checkRedrResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__checkRedrResult **)soap_malloc(soap, sizeof(ns1__checkRedrResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__checkRedrResult *)soap_instantiate_ns1__checkRedrResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__checkRedrResult ** p = (ns1__checkRedrResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__checkRedrResult, sizeof(ns1__checkRedrResult), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__checkRedrResult(struct soap *soap, ns1__checkRedrResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__checkRedrResult);
	if (soap_out_PointerTons1__checkRedrResult(soap, tag?tag:"ns1:checkRedrResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__checkRedrResult ** SOAP_FMAC4 soap_get_PointerTons1__checkRedrResult(struct soap *soap, ns1__checkRedrResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__checkRedrResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__simpleBean(struct soap *soap, ns1__simpleBean *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__simpleBean))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__simpleBean(struct soap *soap, const char *tag, int id, ns1__simpleBean *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__simpleBean);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__simpleBean ** SOAP_FMAC4 soap_in_PointerTons1__simpleBean(struct soap *soap, const char *tag, ns1__simpleBean **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__simpleBean **)soap_malloc(soap, sizeof(ns1__simpleBean *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__simpleBean *)soap_instantiate_ns1__simpleBean(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__simpleBean ** p = (ns1__simpleBean **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__simpleBean, sizeof(ns1__simpleBean), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__simpleBean(struct soap *soap, ns1__simpleBean *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__simpleBean);
	if (soap_out_PointerTons1__simpleBean(soap, tag?tag:"ns1:simpleBean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__simpleBean ** SOAP_FMAC4 soap_get_PointerTons1__simpleBean(struct soap *soap, ns1__simpleBean **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__simpleBean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__reader(struct soap *soap, ns1__reader *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__reader))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__reader(struct soap *soap, const char *tag, int id, ns1__reader *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__reader);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__reader ** SOAP_FMAC4 soap_in_PointerTons1__reader(struct soap *soap, const char *tag, ns1__reader **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__reader **)soap_malloc(soap, sizeof(ns1__reader *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__reader *)soap_instantiate_ns1__reader(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__reader ** p = (ns1__reader **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__reader, sizeof(ns1__reader), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__reader(struct soap *soap, ns1__reader *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__reader);
	if (soap_out_PointerTons1__reader(soap, tag?tag:"ns1:reader", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__reader ** SOAP_FMAC4 soap_get_PointerTons1__reader(struct soap *soap, ns1__reader **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__reader(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__circ(struct soap *soap, ns1__circ *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__circ))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__circ(struct soap *soap, const char *tag, int id, ns1__circ *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__circ);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__circ ** SOAP_FMAC4 soap_in_PointerTons1__circ(struct soap *soap, const char *tag, ns1__circ **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__circ **)soap_malloc(soap, sizeof(ns1__circ *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__circ *)soap_instantiate_ns1__circ(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__circ ** p = (ns1__circ **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__circ, sizeof(ns1__circ), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__circ(struct soap *soap, ns1__circ *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__circ);
	if (soap_out_PointerTons1__circ(soap, tag?tag:"ns1:circ", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__circ ** SOAP_FMAC4 soap_get_PointerTons1__circ(struct soap *soap, ns1__circ **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__circ(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__arrival(struct soap *soap, ns1__arrival *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__arrival))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__arrival(struct soap *soap, const char *tag, int id, ns1__arrival *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__arrival);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__arrival ** SOAP_FMAC4 soap_in_PointerTons1__arrival(struct soap *soap, const char *tag, ns1__arrival **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__arrival **)soap_malloc(soap, sizeof(ns1__arrival *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__arrival *)soap_instantiate_ns1__arrival(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__arrival ** p = (ns1__arrival **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__arrival, sizeof(ns1__arrival), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__arrival(struct soap *soap, ns1__arrival *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__arrival);
	if (soap_out_PointerTons1__arrival(soap, tag?tag:"ns1:arrival", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__arrival ** SOAP_FMAC4 soap_get_PointerTons1__arrival(struct soap *soap, ns1__arrival **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__arrival(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__item(struct soap *soap, ns1__item *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__item))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__item(struct soap *soap, const char *tag, int id, ns1__item *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__item);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__item ** SOAP_FMAC4 soap_in_PointerTons1__item(struct soap *soap, const char *tag, ns1__item **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__item **)soap_malloc(soap, sizeof(ns1__item *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__item *)soap_instantiate_ns1__item(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__item ** p = (ns1__item **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__item, sizeof(ns1__item), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__item(struct soap *soap, ns1__item *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__item);
	if (soap_out_PointerTons1__item(soap, tag?tag:"ns1:item", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__item ** SOAP_FMAC4 soap_get_PointerTons1__item(struct soap *soap, ns1__item **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__item(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wstring(struct soap *soap, wchar_t *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_wstring);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstring(struct soap *soap, const char *tag, int id, wchar_t *const*a, const char *type)
{
	return soap_outwstring(soap, tag, id, a, type, SOAP_TYPE_wstring);
}

SOAP_FMAC3 wchar_t * * SOAP_FMAC4 soap_in_wstring(struct soap *soap, const char *tag, wchar_t **a, const char *type)
{	wchar_t **p;
	p = soap_inwstring(soap, tag, a, type, SOAP_TYPE_wstring, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstring(struct soap *soap, wchar_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wstring);
	if (soap_out_wstring(soap, tag?tag:"wchar", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wchar_t ** SOAP_FMAC4 soap_get_wstring(struct soap *soap, wchar_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_wstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__book(struct soap *soap, ns1__book *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__book))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__book(struct soap *soap, const char *tag, int id, ns1__book *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__book);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__book ** SOAP_FMAC4 soap_in_PointerTons1__book(struct soap *soap, const char *tag, ns1__book **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__book **)soap_malloc(soap, sizeof(ns1__book *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__book *)soap_instantiate_ns1__book(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__book ** p = (ns1__book **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__book, sizeof(ns1__book), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__book(struct soap *soap, ns1__book *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__book);
	if (soap_out_PointerTons1__book(soap, tag?tag:"ns1:book", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__book ** SOAP_FMAC4 soap_get_PointerTons1__book(struct soap *soap, ns1__book **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__book(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__lostPay(struct soap *soap, std::vector<ns1__lostPay * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__lostPay(struct soap *soap, const std::vector<ns1__lostPay * >*a)
{
	for (std::vector<ns1__lostPay * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__lostPay(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__lostPay(struct soap *soap, const char *tag, int id, const std::vector<ns1__lostPay * >*a, const char *type)
{
	for (std::vector<ns1__lostPay * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__lostPay(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__lostPay * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__lostPay(struct soap *soap, const char *tag, std::vector<ns1__lostPay * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__lostPay(soap, -1)))
		return NULL;
	ns1__lostPay *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__lostPay, SOAP_TYPE_std__vectorTemplateOfPointerTons1__lostPay, sizeof(ns1__lostPay), 1))
				break;
			if (!soap_in_PointerTons1__lostPay(soap, tag, NULL, "ns1:lostPay"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__lostPay(soap, tag, &n, "ns1:lostPay"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__lostPay * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__lostPay(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__lostPay(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__lostPay, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__lostPay * >);
		if (size)
			*size = sizeof(std::vector<ns1__lostPay * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__lostPay * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__lostPay * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__lostPay * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__lostPay(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__lostPay * > %p -> %p\n", q, p));
	*(std::vector<ns1__lostPay * >*)p = *(std::vector<ns1__lostPay * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__preg(struct soap *soap, std::vector<ns1__preg * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__preg(struct soap *soap, const std::vector<ns1__preg * >*a)
{
	for (std::vector<ns1__preg * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__preg(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__preg(struct soap *soap, const char *tag, int id, const std::vector<ns1__preg * >*a, const char *type)
{
	for (std::vector<ns1__preg * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__preg(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__preg * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__preg(struct soap *soap, const char *tag, std::vector<ns1__preg * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__preg(soap, -1)))
		return NULL;
	ns1__preg *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__preg, SOAP_TYPE_std__vectorTemplateOfPointerTons1__preg, sizeof(ns1__preg), 1))
				break;
			if (!soap_in_PointerTons1__preg(soap, tag, NULL, "ns1:preg"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__preg(soap, tag, &n, "ns1:preg"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__preg * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__preg(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__preg(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__preg, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__preg * >);
		if (size)
			*size = sizeof(std::vector<ns1__preg * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__preg * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__preg * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__preg * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__preg(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__preg * > %p -> %p\n", q, p));
	*(std::vector<ns1__preg * >*)p = *(std::vector<ns1__preg * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__account(struct soap *soap, std::vector<ns1__account * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__account(struct soap *soap, const std::vector<ns1__account * >*a)
{
	for (std::vector<ns1__account * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__account(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__account(struct soap *soap, const char *tag, int id, const std::vector<ns1__account * >*a, const char *type)
{
	for (std::vector<ns1__account * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__account(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__account * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__account(struct soap *soap, const char *tag, std::vector<ns1__account * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__account(soap, -1)))
		return NULL;
	ns1__account *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__account, SOAP_TYPE_std__vectorTemplateOfPointerTons1__account, sizeof(ns1__account), 1))
				break;
			if (!soap_in_PointerTons1__account(soap, tag, NULL, "ns1:account"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__account(soap, tag, &n, "ns1:account"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__account * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__account(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__account(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__account, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__account * >);
		if (size)
			*size = sizeof(std::vector<ns1__account * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__account * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__account * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__account * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__account(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__account * > %p -> %p\n", q, p));
	*(std::vector<ns1__account * >*)p = *(std::vector<ns1__account * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__relegate(struct soap *soap, std::vector<ns1__relegate * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__relegate(struct soap *soap, const std::vector<ns1__relegate * >*a)
{
	for (std::vector<ns1__relegate * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__relegate(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__relegate(struct soap *soap, const char *tag, int id, const std::vector<ns1__relegate * >*a, const char *type)
{
	for (std::vector<ns1__relegate * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__relegate(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__relegate * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__relegate(struct soap *soap, const char *tag, std::vector<ns1__relegate * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__relegate(soap, -1)))
		return NULL;
	ns1__relegate *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__relegate, SOAP_TYPE_std__vectorTemplateOfPointerTons1__relegate, sizeof(ns1__relegate), 1))
				break;
			if (!soap_in_PointerTons1__relegate(soap, tag, NULL, "ns1:relegate"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__relegate(soap, tag, &n, "ns1:relegate"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__relegate * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__relegate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__relegate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__relegate, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__relegate * >);
		if (size)
			*size = sizeof(std::vector<ns1__relegate * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__relegate * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__relegate * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__relegate * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__relegate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__relegate * > %p -> %p\n", q, p));
	*(std::vector<ns1__relegate * >*)p = *(std::vector<ns1__relegate * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__violation(struct soap *soap, std::vector<ns1__violation * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__violation(struct soap *soap, const std::vector<ns1__violation * >*a)
{
	for (std::vector<ns1__violation * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__violation(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__violation(struct soap *soap, const char *tag, int id, const std::vector<ns1__violation * >*a, const char *type)
{
	for (std::vector<ns1__violation * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__violation(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__violation * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__violation(struct soap *soap, const char *tag, std::vector<ns1__violation * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__violation(soap, -1)))
		return NULL;
	ns1__violation *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__violation, SOAP_TYPE_std__vectorTemplateOfPointerTons1__violation, sizeof(ns1__violation), 1))
				break;
			if (!soap_in_PointerTons1__violation(soap, tag, NULL, "ns1:violation"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__violation(soap, tag, &n, "ns1:violation"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__violation * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__violation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__violation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__violation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__violation * >);
		if (size)
			*size = sizeof(std::vector<ns1__violation * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__violation * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__violation * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__violation * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__violation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__violation * > %p -> %p\n", q, p));
	*(std::vector<ns1__violation * >*)p = *(std::vector<ns1__violation * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__debt(struct soap *soap, std::vector<ns1__debt * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__debt(struct soap *soap, const std::vector<ns1__debt * >*a)
{
	for (std::vector<ns1__debt * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__debt(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__debt(struct soap *soap, const char *tag, int id, const std::vector<ns1__debt * >*a, const char *type)
{
	for (std::vector<ns1__debt * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__debt(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__debt * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__debt(struct soap *soap, const char *tag, std::vector<ns1__debt * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__debt(soap, -1)))
		return NULL;
	ns1__debt *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__debt, SOAP_TYPE_std__vectorTemplateOfPointerTons1__debt, sizeof(ns1__debt), 1))
				break;
			if (!soap_in_PointerTons1__debt(soap, tag, NULL, "ns1:debt"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__debt(soap, tag, &n, "ns1:debt"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__debt * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__debt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__debt(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__debt, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__debt * >);
		if (size)
			*size = sizeof(std::vector<ns1__debt * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__debt * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__debt * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__debt * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__debt(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__debt * > %p -> %p\n", q, p));
	*(std::vector<ns1__debt * >*)p = *(std::vector<ns1__debt * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__simpleBean(struct soap *soap, std::vector<ns1__simpleBean * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__simpleBean(struct soap *soap, const std::vector<ns1__simpleBean * >*a)
{
	for (std::vector<ns1__simpleBean * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__simpleBean(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__simpleBean(struct soap *soap, const char *tag, int id, const std::vector<ns1__simpleBean * >*a, const char *type)
{
	for (std::vector<ns1__simpleBean * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__simpleBean(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__simpleBean * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__simpleBean(struct soap *soap, const char *tag, std::vector<ns1__simpleBean * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__simpleBean(soap, -1)))
		return NULL;
	ns1__simpleBean *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__simpleBean, SOAP_TYPE_std__vectorTemplateOfPointerTons1__simpleBean, sizeof(ns1__simpleBean), 1))
				break;
			if (!soap_in_PointerTons1__simpleBean(soap, tag, NULL, "ns1:simpleBean"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__simpleBean(soap, tag, &n, "ns1:simpleBean"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__simpleBean * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__simpleBean(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__simpleBean(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__simpleBean, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__simpleBean * >);
		if (size)
			*size = sizeof(std::vector<ns1__simpleBean * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__simpleBean * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__simpleBean * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__simpleBean * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__simpleBean(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__simpleBean * > %p -> %p\n", q, p));
	*(std::vector<ns1__simpleBean * >*)p = *(std::vector<ns1__simpleBean * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__circ(struct soap *soap, std::vector<ns1__circ * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__circ(struct soap *soap, const std::vector<ns1__circ * >*a)
{
	for (std::vector<ns1__circ * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__circ(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__circ(struct soap *soap, const char *tag, int id, const std::vector<ns1__circ * >*a, const char *type)
{
	for (std::vector<ns1__circ * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__circ(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__circ * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__circ(struct soap *soap, const char *tag, std::vector<ns1__circ * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__circ(soap, -1)))
		return NULL;
	ns1__circ *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__circ, SOAP_TYPE_std__vectorTemplateOfPointerTons1__circ, sizeof(ns1__circ), 1))
				break;
			if (!soap_in_PointerTons1__circ(soap, tag, NULL, "ns1:circ"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__circ(soap, tag, &n, "ns1:circ"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__circ * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__circ(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__circ(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__circ, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__circ * >);
		if (size)
			*size = sizeof(std::vector<ns1__circ * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__circ * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__circ * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__circ * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__circ(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__circ * > %p -> %p\n", q, p));
	*(std::vector<ns1__circ * >*)p = *(std::vector<ns1__circ * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__arrival(struct soap *soap, std::vector<ns1__arrival * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__arrival(struct soap *soap, const std::vector<ns1__arrival * >*a)
{
	for (std::vector<ns1__arrival * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__arrival(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__arrival(struct soap *soap, const char *tag, int id, const std::vector<ns1__arrival * >*a, const char *type)
{
	for (std::vector<ns1__arrival * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__arrival(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__arrival * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__arrival(struct soap *soap, const char *tag, std::vector<ns1__arrival * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__arrival(soap, -1)))
		return NULL;
	ns1__arrival *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__arrival, SOAP_TYPE_std__vectorTemplateOfPointerTons1__arrival, sizeof(ns1__arrival), 1))
				break;
			if (!soap_in_PointerTons1__arrival(soap, tag, NULL, "ns1:arrival"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__arrival(soap, tag, &n, "ns1:arrival"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__arrival * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__arrival(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__arrival(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__arrival, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__arrival * >);
		if (size)
			*size = sizeof(std::vector<ns1__arrival * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__arrival * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__arrival * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__arrival * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__arrival(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__arrival * > %p -> %p\n", q, p));
	*(std::vector<ns1__arrival * >*)p = *(std::vector<ns1__arrival * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__item(struct soap *soap, std::vector<ns1__item * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__item(struct soap *soap, const std::vector<ns1__item * >*a)
{
	for (std::vector<ns1__item * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__item(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__item(struct soap *soap, const char *tag, int id, const std::vector<ns1__item * >*a, const char *type)
{
	for (std::vector<ns1__item * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__item(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__item * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__item(struct soap *soap, const char *tag, std::vector<ns1__item * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__item(soap, -1)))
		return NULL;
	ns1__item *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__item, SOAP_TYPE_std__vectorTemplateOfPointerTons1__item, sizeof(ns1__item), 1))
				break;
			if (!soap_in_PointerTons1__item(soap, tag, NULL, "ns1:item"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__item(soap, tag, &n, "ns1:item"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__item * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__item(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__item(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__item, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__item * >);
		if (size)
			*size = sizeof(std::vector<ns1__item * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__item * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__item * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__item * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__item(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__item * > %p -> %p\n", q, p));
	*(std::vector<ns1__item * >*)p = *(std::vector<ns1__item * >*)q;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */

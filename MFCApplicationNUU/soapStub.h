/* soapStub.h
   Generated by gSOAP 2.7.16 from LibServicePort.h
   Copyright(C) 2000-2010, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#ifndef soapStub_H
#define soapStub_H
#include <vector>
#define SOAP_NAMESPACE_OF_ns2	""
#define SOAP_NAMESPACE_OF_ns1	"http://service.ws.hw.com/"
#include "stdsoap2.h"

/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not redeclare here */

#endif

#if 0 /* volatile type: do not redeclare here */

#endif

#ifndef SOAP_TYPE_ns1__getBook
#define SOAP_TYPE_ns1__getBook (8)
/* ns1:getBook */
class SOAP_CMAC ns1__getBook
{
public:
	std::string *arg0;	/* optional element of type xsd:string */
	std::string *arg1;	/* optional element of type xsd:string */
	std::string *arg2;	/* optional element of type xsd:string */
	int arg3;	/* required element of type xsd:int */
	std::string *arg4;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 8; } /* = unique id SOAP_TYPE_ns1__getBook */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getBook(): arg0(NULL), arg1(NULL), arg2(NULL), arg4(NULL), soap(NULL) { ns1__getBook::soap_default(NULL); }
	virtual ~ns1__getBook() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getBookResponse
#define SOAP_TYPE_ns1__getBookResponse (9)
/* ns1:getBookResponse */
class SOAP_CMAC ns1__getBookResponse
{
public:
	class ns1__book *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:book */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 9; } /* = unique id SOAP_TYPE_ns1__getBookResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getBookResponse(): return_(NULL), soap(NULL) { ns1__getBookResponse::soap_default(NULL); }
	virtual ~ns1__getBookResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__book
#define SOAP_TYPE_ns1__book (10)
/* ns1:book */
class SOAP_CMAC ns1__book
{
public:
	wchar_t *author;	/* optional element of type xsd:string */
	wchar_t *barcode;	/* optional element of type xsd:string */
	wchar_t *callNo;	/* optional element of type xsd:string */
	wchar_t *locationName;	/* optional element of type xsd:string */
	float price;	/* required element of type xsd:float */
	wchar_t *propNo;	/* optional element of type xsd:string */
	wchar_t *publisher;	/* optional element of type xsd:string */
	wchar_t *state;	/* optional element of type xsd:string */
	wchar_t *stateName;	/* optional element of type xsd:string */
	wchar_t *title;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 10; } /* = unique id SOAP_TYPE_ns1__book */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__book(): author(NULL), barcode(NULL), callNo(NULL), locationName(NULL), propNo(NULL), publisher(NULL), state(NULL), stateName(NULL), title(NULL), soap(NULL) { ns1__book::soap_default(NULL); }
	virtual ~ns1__book() { }
};
#endif

#ifndef SOAP_TYPE_ns1__NoAuthorityException
#define SOAP_TYPE_ns1__NoAuthorityException (11)
/* ns1:NoAuthorityException */
class SOAP_CMAC ns1__NoAuthorityException
{
public:
	wchar_t *message;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 11; } /* = unique id SOAP_TYPE_ns1__NoAuthorityException */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__NoAuthorityException(): message(NULL), soap(NULL) { ns1__NoAuthorityException::soap_default(NULL); }
	virtual ~ns1__NoAuthorityException() { }
};
#endif

#ifndef SOAP_TYPE_ns1__SystemException
#define SOAP_TYPE_ns1__SystemException (12)
/* ns1:SystemException */
class SOAP_CMAC ns1__SystemException
{
public:
	wchar_t *message;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 12; } /* = unique id SOAP_TYPE_ns1__SystemException */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__SystemException(): message(NULL), soap(NULL) { ns1__SystemException::soap_default(NULL); }
	virtual ~ns1__SystemException() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getItems
#define SOAP_TYPE_ns1__getItems (13)
/* ns1:getItems */
class SOAP_CMAC ns1__getItems
{
public:
	std::string *arg0;	/* optional element of type xsd:string */
	std::string *arg1;	/* optional element of type xsd:string */
	std::string *arg2;	/* optional element of type xsd:string */
	std::string *arg3;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 13; } /* = unique id SOAP_TYPE_ns1__getItems */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getItems(): arg0(NULL), arg1(NULL), arg2(NULL), arg3(NULL), soap(NULL) { ns1__getItems::soap_default(NULL); }
	virtual ~ns1__getItems() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getItemsResponse
#define SOAP_TYPE_ns1__getItemsResponse (14)
/* ns1:getItemsResponse */
class SOAP_CMAC ns1__getItemsResponse
{
public:
	std::vector<class ns1__item * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:item */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 14; } /* = unique id SOAP_TYPE_ns1__getItemsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getItemsResponse(): soap(NULL) { ns1__getItemsResponse::soap_default(NULL); }
	virtual ~ns1__getItemsResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__item
#define SOAP_TYPE_ns1__item (15)
/* ns1:item */
class SOAP_CMAC ns1__item
{
public:
	wchar_t *attachment;	/* optional element of type xsd:string */
	wchar_t *barCode;	/* optional element of type xsd:string */
	wchar_t *callNo;	/* optional element of type xsd:string */
	wchar_t *carrierName;	/* optional element of type xsd:string */
	wchar_t *location;	/* optional element of type xsd:string */
	wchar_t *locationDept;	/* optional element of type xsd:string */
	wchar_t *marcRecNo;	/* optional element of type xsd:string */
	float price;	/* required element of type xsd:float */
	wchar_t *propNo;	/* optional element of type xsd:string */
	wchar_t *state;	/* optional element of type xsd:string */
	wchar_t *volPeri;	/* optional element of type xsd:string */
	wchar_t *year;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 15; } /* = unique id SOAP_TYPE_ns1__item */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__item(): attachment(NULL), barCode(NULL), callNo(NULL), carrierName(NULL), location(NULL), locationDept(NULL), marcRecNo(NULL), propNo(NULL), state(NULL), volPeri(NULL), year(NULL), soap(NULL) { ns1__item::soap_default(NULL); }
	virtual ~ns1__item() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getRelegateArrivals
#define SOAP_TYPE_ns1__getRelegateArrivals (16)
/* ns1:getRelegateArrivals */
class SOAP_CMAC ns1__getRelegateArrivals
{
public:
	std::string *arg0;	/* optional element of type xsd:string */
	std::string *arg1;	/* optional element of type xsd:string */
	std::string *arg2;	/* optional element of type xsd:string */
	std::string *arg3;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 16; } /* = unique id SOAP_TYPE_ns1__getRelegateArrivals */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getRelegateArrivals(): arg0(NULL), arg1(NULL), arg2(NULL), arg3(NULL), soap(NULL) { ns1__getRelegateArrivals::soap_default(NULL); }
	virtual ~ns1__getRelegateArrivals() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getRelegateArrivalsResponse
#define SOAP_TYPE_ns1__getRelegateArrivalsResponse (17)
/* ns1:getRelegateArrivalsResponse */
class SOAP_CMAC ns1__getRelegateArrivalsResponse
{
public:
	std::vector<class ns1__arrival * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:arrival */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 17; } /* = unique id SOAP_TYPE_ns1__getRelegateArrivalsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getRelegateArrivalsResponse(): soap(NULL) { ns1__getRelegateArrivalsResponse::soap_default(NULL); }
	virtual ~ns1__getRelegateArrivalsResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__arrival
#define SOAP_TYPE_ns1__arrival (18)
/* ns1:arrival */
class SOAP_CMAC ns1__arrival
{
public:
	wchar_t *arrivalDate;	/* optional element of type xsd:string */
	wchar_t *author;	/* optional element of type xsd:string */
	wchar_t *barcode;	/* optional element of type xsd:string */
	wchar_t *callNo;	/* optional element of type xsd:string */
	wchar_t *certId;	/* optional element of type xsd:string */
	wchar_t *keepEndDate;	/* optional element of type xsd:string */
	wchar_t *marcRecNo;	/* optional element of type xsd:string */
	wchar_t *name;	/* optional element of type xsd:string */
	wchar_t *propNo;	/* optional element of type xsd:string */
	wchar_t *takeLocation;	/* optional element of type xsd:string */
	wchar_t *title;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 18; } /* = unique id SOAP_TYPE_ns1__arrival */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__arrival(): arrivalDate(NULL), author(NULL), barcode(NULL), callNo(NULL), certId(NULL), keepEndDate(NULL), marcRecNo(NULL), name(NULL), propNo(NULL), takeLocation(NULL), title(NULL), soap(NULL) { ns1__arrival::soap_default(NULL); }
	virtual ~ns1__arrival() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getPregArrivals
#define SOAP_TYPE_ns1__getPregArrivals (19)
/* ns1:getPregArrivals */
class SOAP_CMAC ns1__getPregArrivals
{
public:
	std::string *arg0;	/* optional element of type xsd:string */
	std::string *arg1;	/* optional element of type xsd:string */
	std::string *arg2;	/* optional element of type xsd:string */
	std::string *arg3;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 19; } /* = unique id SOAP_TYPE_ns1__getPregArrivals */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getPregArrivals(): arg0(NULL), arg1(NULL), arg2(NULL), arg3(NULL), soap(NULL) { ns1__getPregArrivals::soap_default(NULL); }
	virtual ~ns1__getPregArrivals() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getPregArrivalsResponse
#define SOAP_TYPE_ns1__getPregArrivalsResponse (20)
/* ns1:getPregArrivalsResponse */
class SOAP_CMAC ns1__getPregArrivalsResponse
{
public:
	std::vector<ns1__arrival * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:arrival */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 20; } /* = unique id SOAP_TYPE_ns1__getPregArrivalsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getPregArrivalsResponse(): soap(NULL) { ns1__getPregArrivalsResponse::soap_default(NULL); }
	virtual ~ns1__getPregArrivalsResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__logout
#define SOAP_TYPE_ns1__logout (21)
/* ns1:logout */
class SOAP_CMAC ns1__logout
{
public:
	std::string *arg0;	/* optional element of type xsd:string */
	std::string *arg1;	/* optional element of type xsd:string */
	std::string *arg2;	/* optional element of type xsd:string */
	int arg3;	/* required element of type xsd:int */
	std::string *arg4;	/* optional element of type xsd:string */
	int arg5;	/* required element of type xsd:int */
	int arg6;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 21; } /* = unique id SOAP_TYPE_ns1__logout */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__logout(): arg0(NULL), arg1(NULL), arg2(NULL), arg4(NULL), soap(NULL) { ns1__logout::soap_default(NULL); }
	virtual ~ns1__logout() { }
};
#endif

#ifndef SOAP_TYPE_ns1__logoutResponse
#define SOAP_TYPE_ns1__logoutResponse (22)
/* ns1:logoutResponse */
class SOAP_CMAC ns1__logoutResponse
{
public:
	int return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 22; } /* = unique id SOAP_TYPE_ns1__logoutResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__logoutResponse(): soap(NULL) { ns1__logoutResponse::soap_default(NULL); }
	virtual ~ns1__logoutResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__voltFine
#define SOAP_TYPE_ns1__voltFine (23)
/* ns1:voltFine */
class SOAP_CMAC ns1__voltFine
{
public:
	std::string *arg0;	/* optional element of type xsd:string */
	std::string *arg1;	/* optional element of type xsd:string */
	std::string *arg2;	/* optional element of type xsd:string */
	std::string *arg3;	/* optional element of type xsd:string */
	std::string *arg4;	/* optional element of type xsd:string */
	float arg5;	/* required element of type xsd:float */
	std::string *arg6;	/* optional element of type xsd:string */
	std::string *arg7;	/* optional element of type xsd:string */
	std::string *arg8;	/* optional element of type xsd:string */
	int arg9;	/* required element of type xsd:int */
	std::string *arg10;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 23; } /* = unique id SOAP_TYPE_ns1__voltFine */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__voltFine(): arg0(NULL), arg1(NULL), arg2(NULL), arg3(NULL), arg4(NULL), arg6(NULL), arg7(NULL), arg8(NULL), arg10(NULL), soap(NULL) { ns1__voltFine::soap_default(NULL); }
	virtual ~ns1__voltFine() { }
};
#endif

#ifndef SOAP_TYPE_ns1__voltFineResponse
#define SOAP_TYPE_ns1__voltFineResponse (24)
/* ns1:voltFineResponse */
class SOAP_CMAC ns1__voltFineResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 24; } /* = unique id SOAP_TYPE_ns1__voltFineResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__voltFineResponse(): soap(NULL) { ns1__voltFineResponse::soap_default(NULL); }
	virtual ~ns1__voltFineResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__exceedFine
#define SOAP_TYPE_ns1__exceedFine (25)
/* ns1:exceedFine */
class SOAP_CMAC ns1__exceedFine
{
public:
	std::string *arg0;	/* optional element of type xsd:string */
	std::string *arg1;	/* optional element of type xsd:string */
	std::string *arg2;	/* optional element of type xsd:string */
	std::string *arg3;	/* optional element of type xsd:string */
	std::string *arg4;	/* optional element of type xsd:string */
	std::string *arg5;	/* optional element of type xsd:string */
	std::string *arg6;	/* optional element of type xsd:string */
	std::string *arg7;	/* optional element of type xsd:string */
	std::string *arg8;	/* optional element of type xsd:string */
	std::string *arg9;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 25; } /* = unique id SOAP_TYPE_ns1__exceedFine */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__exceedFine(): arg0(NULL), arg1(NULL), arg2(NULL), arg3(NULL), arg4(NULL), arg5(NULL), arg6(NULL), arg7(NULL), arg8(NULL), arg9(NULL), soap(NULL) { ns1__exceedFine::soap_default(NULL); }
	virtual ~ns1__exceedFine() { }
};
#endif

#ifndef SOAP_TYPE_ns1__exceedFineResponse
#define SOAP_TYPE_ns1__exceedFineResponse (26)
/* ns1:exceedFineResponse */
class SOAP_CMAC ns1__exceedFineResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 26; } /* = unique id SOAP_TYPE_ns1__exceedFineResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__exceedFineResponse(): soap(NULL) { ns1__exceedFineResponse::soap_default(NULL); }
	virtual ~ns1__exceedFineResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getCircs
#define SOAP_TYPE_ns1__getCircs (27)
/* ns1:getCircs */
class SOAP_CMAC ns1__getCircs
{
public:
	std::string *arg0;	/* optional element of type xsd:string */
	std::string *arg1;	/* optional element of type xsd:string */
	std::string *arg2;	/* optional element of type xsd:string */
	std::string *arg3;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 27; } /* = unique id SOAP_TYPE_ns1__getCircs */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getCircs(): arg0(NULL), arg1(NULL), arg2(NULL), arg3(NULL), soap(NULL) { ns1__getCircs::soap_default(NULL); }
	virtual ~ns1__getCircs() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getCircsResponse
#define SOAP_TYPE_ns1__getCircsResponse (28)
/* ns1:getCircsResponse */
class SOAP_CMAC ns1__getCircsResponse
{
public:
	std::vector<class ns1__circ * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:circ */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 28; } /* = unique id SOAP_TYPE_ns1__getCircsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getCircsResponse(): soap(NULL) { ns1__getCircsResponse::soap_default(NULL); }
	virtual ~ns1__getCircsResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__circ
#define SOAP_TYPE_ns1__circ (29)
/* ns1:circ */
class SOAP_CMAC ns1__circ
{
public:
	wchar_t *attachment;	/* optional element of type xsd:string */
	wchar_t *author;	/* optional element of type xsd:string */
	wchar_t *barcode;	/* optional element of type xsd:string */
	wchar_t *certId;	/* optional element of type xsd:string */
	wchar_t *dueDay;	/* optional element of type xsd:string */
	wchar_t *lendDate;	/* optional element of type xsd:string */
	wchar_t *location;	/* optional element of type xsd:string */
	wchar_t *marcRecNo;	/* optional element of type xsd:string */
	wchar_t *name;	/* optional element of type xsd:string */
	float price;	/* required element of type xsd:float */
	wchar_t *propNo;	/* optional element of type xsd:string */
	int renewTimes;	/* required element of type xsd:int */
	wchar_t *title;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 29; } /* = unique id SOAP_TYPE_ns1__circ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__circ(): attachment(NULL), author(NULL), barcode(NULL), certId(NULL), dueDay(NULL), lendDate(NULL), location(NULL), marcRecNo(NULL), name(NULL), propNo(NULL), title(NULL), soap(NULL) { ns1__circ::soap_default(NULL); }
	virtual ~ns1__circ() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getReader
#define SOAP_TYPE_ns1__getReader (30)
/* ns1:getReader */
class SOAP_CMAC ns1__getReader
{
public:
	std::string *arg0;	/* optional element of type xsd:string */
	std::string *arg1;	/* optional element of type xsd:string */
	std::string *arg2;	/* optional element of type xsd:string */
	int arg3;	/* required element of type xsd:int */
	std::string *arg4;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 30; } /* = unique id SOAP_TYPE_ns1__getReader */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getReader(): arg0(NULL), arg1(NULL), arg2(NULL), arg4(NULL), soap(NULL) { ns1__getReader::soap_default(NULL); }
	virtual ~ns1__getReader() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getReaderResponse
#define SOAP_TYPE_ns1__getReaderResponse (31)
/* ns1:getReaderResponse */
class SOAP_CMAC ns1__getReaderResponse
{
public:
	class ns1__reader *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:reader */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 31; } /* = unique id SOAP_TYPE_ns1__getReaderResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getReaderResponse(): return_(NULL), soap(NULL) { ns1__getReaderResponse::soap_default(NULL); }
	virtual ~ns1__getReaderResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__reader
#define SOAP_TYPE_ns1__reader (32)
/* ns1:reader */
class SOAP_CMAC ns1__reader
{
public:
	wchar_t *beginDate;	/* optional element of type xsd:string */
	wchar_t *certFlag;	/* optional element of type xsd:string */
	wchar_t *certFlagName;	/* optional element of type xsd:string */
	wchar_t *certId;	/* optional element of type xsd:string */
	float debt;	/* required element of type xsd:float */
	wchar_t *dept;	/* optional element of type xsd:string */
	wchar_t *email;	/* optional element of type xsd:string */
	wchar_t *endDate;	/* optional element of type xsd:string */
	wchar_t *grade;	/* optional element of type xsd:string */
	wchar_t *idCard;	/* optional element of type xsd:string */
	int lendQuantity;	/* required element of type xsd:int */
	wchar_t *limitFlag;	/* optional element of type xsd:string */
	wchar_t *limitFlagName;	/* optional element of type xsd:string */
	int maxLendQuantity;	/* required element of type xsd:int */
	wchar_t *name;	/* optional element of type xsd:string */
	wchar_t *readerCertId;	/* optional element of type xsd:string */
	wchar_t *readerDept;	/* optional element of type xsd:string */
	wchar_t *readerType;	/* optional element of type xsd:string */
	wchar_t *registerDay;	/* optional element of type xsd:string */
	wchar_t *sex;	/* optional element of type xsd:string */
	int voltFlag;	/* required element of type xsd:int */
	wchar_t *voltFlagName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 32; } /* = unique id SOAP_TYPE_ns1__reader */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__reader(): beginDate(NULL), certFlag(NULL), certFlagName(NULL), certId(NULL), dept(NULL), email(NULL), endDate(NULL), grade(NULL), idCard(NULL), limitFlag(NULL), limitFlagName(NULL), name(NULL), readerCertId(NULL), readerDept(NULL), readerType(NULL), registerDay(NULL), sex(NULL), voltFlagName(NULL), soap(NULL) { ns1__reader::soap_default(NULL); }
	virtual ~ns1__reader() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getDeps
#define SOAP_TYPE_ns1__getDeps (33)
/* ns1:getDeps */
class SOAP_CMAC ns1__getDeps
{
public:
	std::string *arg0;	/* optional element of type xsd:string */
	std::string *arg1;	/* optional element of type xsd:string */
	std::string *arg2;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 33; } /* = unique id SOAP_TYPE_ns1__getDeps */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getDeps(): arg0(NULL), arg1(NULL), arg2(NULL), soap(NULL) { ns1__getDeps::soap_default(NULL); }
	virtual ~ns1__getDeps() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getDepsResponse
#define SOAP_TYPE_ns1__getDepsResponse (34)
/* ns1:getDepsResponse */
class SOAP_CMAC ns1__getDepsResponse
{
public:
	std::vector<class ns1__simpleBean * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:simpleBean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 34; } /* = unique id SOAP_TYPE_ns1__getDepsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getDepsResponse(): soap(NULL) { ns1__getDepsResponse::soap_default(NULL); }
	virtual ~ns1__getDepsResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__simpleBean
#define SOAP_TYPE_ns1__simpleBean (35)
/* ns1:simpleBean */
class SOAP_CMAC ns1__simpleBean
{
public:
	wchar_t *code;	/* optional element of type xsd:string */
	wchar_t *name;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 35; } /* = unique id SOAP_TYPE_ns1__simpleBean */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__simpleBean(): code(NULL), name(NULL), soap(NULL) { ns1__simpleBean::soap_default(NULL); }
	virtual ~ns1__simpleBean() { }
};
#endif

#ifndef SOAP_TYPE_ns1__checkReader
#define SOAP_TYPE_ns1__checkReader (36)
/* ns1:checkReader */
class SOAP_CMAC ns1__checkReader
{
public:
	std::string *arg0;	/* optional element of type xsd:string */
	std::string *arg1;	/* optional element of type xsd:string */
	std::string *arg2;	/* optional element of type xsd:string */
	int arg3;	/* required element of type xsd:int */
	std::string *arg4;	/* optional element of type xsd:string */
	std::string *arg5;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 36; } /* = unique id SOAP_TYPE_ns1__checkReader */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__checkReader(): arg0(NULL), arg1(NULL), arg2(NULL), arg4(NULL), arg5(NULL), soap(NULL) { ns1__checkReader::soap_default(NULL); }
	virtual ~ns1__checkReader() { }
};
#endif

#ifndef SOAP_TYPE_ns1__checkReaderResponse
#define SOAP_TYPE_ns1__checkReaderResponse (37)
/* ns1:checkReaderResponse */
class SOAP_CMAC ns1__checkReaderResponse
{
public:
	class ns1__checkRedrResult *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:checkRedrResult */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 37; } /* = unique id SOAP_TYPE_ns1__checkReaderResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__checkReaderResponse(): return_(NULL), soap(NULL) { ns1__checkReaderResponse::soap_default(NULL); }
	virtual ~ns1__checkReaderResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__checkRedrResult
#define SOAP_TYPE_ns1__checkRedrResult (38)
/* ns1:checkRedrResult */
class SOAP_CMAC ns1__checkRedrResult
{
public:
	int code;	/* required element of type xsd:int */
	ns1__reader *reader;	/* optional element of type ns1:reader */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 38; } /* = unique id SOAP_TYPE_ns1__checkRedrResult */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__checkRedrResult(): reader(NULL), soap(NULL) { ns1__checkRedrResult::soap_default(NULL); }
	virtual ~ns1__checkRedrResult() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getDebts
#define SOAP_TYPE_ns1__getDebts (39)
/* ns1:getDebts */
class SOAP_CMAC ns1__getDebts
{
public:
	std::string *arg0;	/* optional element of type xsd:string */
	std::string *arg1;	/* optional element of type xsd:string */
	std::string *arg2;	/* optional element of type xsd:string */
	std::string *arg3;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 39; } /* = unique id SOAP_TYPE_ns1__getDebts */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getDebts(): arg0(NULL), arg1(NULL), arg2(NULL), arg3(NULL), soap(NULL) { ns1__getDebts::soap_default(NULL); }
	virtual ~ns1__getDebts() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getDebtsResponse
#define SOAP_TYPE_ns1__getDebtsResponse (40)
/* ns1:getDebtsResponse */
class SOAP_CMAC ns1__getDebtsResponse
{
public:
	std::vector<class ns1__debt * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:debt */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 40; } /* = unique id SOAP_TYPE_ns1__getDebtsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getDebtsResponse(): soap(NULL) { ns1__getDebtsResponse::soap_default(NULL); }
	virtual ~ns1__getDebtsResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__debt
#define SOAP_TYPE_ns1__debt (41)
/* ns1:debt */
class SOAP_CMAC ns1__debt
{
public:
	wchar_t *certId;	/* optional element of type xsd:string */
	wchar_t *debtDealFlag;	/* optional element of type xsd:string */
	wchar_t *debtDealFlagName;	/* optional element of type xsd:string */
	float dueFineAmount;	/* required element of type xsd:float */
	float fineAmount;	/* required element of type xsd:float */
	wchar_t *lendDate;	/* optional element of type xsd:string */
	wchar_t *locationF;	/* optional element of type xsd:string */
	wchar_t *name;	/* optional element of type xsd:string */
	wchar_t *propNo;	/* optional element of type xsd:string */
	wchar_t *retDate;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 41; } /* = unique id SOAP_TYPE_ns1__debt */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__debt(): certId(NULL), debtDealFlag(NULL), debtDealFlagName(NULL), lendDate(NULL), locationF(NULL), name(NULL), propNo(NULL), retDate(NULL), soap(NULL) { ns1__debt::soap_default(NULL); }
	virtual ~ns1__debt() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getViolations1
#define SOAP_TYPE_ns1__getViolations1 (42)
/* ns1:getViolations1 */
class SOAP_CMAC ns1__getViolations1
{
public:
	std::string *arg0;	/* optional element of type xsd:string */
	std::string *arg1;	/* optional element of type xsd:string */
	std::string *arg2;	/* optional element of type xsd:string */
	std::string *arg3;	/* optional element of type xsd:string */
	std::string *arg4;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 42; } /* = unique id SOAP_TYPE_ns1__getViolations1 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getViolations1(): arg0(NULL), arg1(NULL), arg2(NULL), arg3(NULL), arg4(NULL), soap(NULL) { ns1__getViolations1::soap_default(NULL); }
	virtual ~ns1__getViolations1() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getViolations1Response
#define SOAP_TYPE_ns1__getViolations1Response (43)
/* ns1:getViolations1Response */
class SOAP_CMAC ns1__getViolations1Response
{
public:
	std::vector<class ns1__violation * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:violation */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 43; } /* = unique id SOAP_TYPE_ns1__getViolations1Response */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getViolations1Response(): soap(NULL) { ns1__getViolations1Response::soap_default(NULL); }
	virtual ~ns1__getViolations1Response() { }
};
#endif

#ifndef SOAP_TYPE_ns1__violation
#define SOAP_TYPE_ns1__violation (44)
/* ns1:violation */
class SOAP_CMAC ns1__violation
{
public:
	wchar_t *certId;	/* optional element of type xsd:string */
	wchar_t *dealFlag;	/* optional element of type xsd:string */
	wchar_t *dealFlagName;	/* optional element of type xsd:string */
	float fineAmount;	/* required element of type xsd:float */
	wchar_t *frozEndDate;	/* optional element of type xsd:string */
	wchar_t *name;	/* optional element of type xsd:string */
	wchar_t *pulishDate;	/* optional element of type xsd:string */
	wchar_t *voltName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 44; } /* = unique id SOAP_TYPE_ns1__violation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__violation(): certId(NULL), dealFlag(NULL), dealFlagName(NULL), frozEndDate(NULL), name(NULL), pulishDate(NULL), voltName(NULL), soap(NULL) { ns1__violation::soap_default(NULL); }
	virtual ~ns1__violation() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getRelegates
#define SOAP_TYPE_ns1__getRelegates (45)
/* ns1:getRelegates */
class SOAP_CMAC ns1__getRelegates
{
public:
	std::string *arg0;	/* optional element of type xsd:string */
	std::string *arg1;	/* optional element of type xsd:string */
	std::string *arg2;	/* optional element of type xsd:string */
	std::string *arg3;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 45; } /* = unique id SOAP_TYPE_ns1__getRelegates */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getRelegates(): arg0(NULL), arg1(NULL), arg2(NULL), arg3(NULL), soap(NULL) { ns1__getRelegates::soap_default(NULL); }
	virtual ~ns1__getRelegates() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getRelegatesResponse
#define SOAP_TYPE_ns1__getRelegatesResponse (46)
/* ns1:getRelegatesResponse */
class SOAP_CMAC ns1__getRelegatesResponse
{
public:
	std::vector<class ns1__relegate * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:relegate */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 46; } /* = unique id SOAP_TYPE_ns1__getRelegatesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getRelegatesResponse(): soap(NULL) { ns1__getRelegatesResponse::soap_default(NULL); }
	virtual ~ns1__getRelegatesResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__pregOrRelegate
#define SOAP_TYPE_ns1__pregOrRelegate (48)
/* ns1:pregOrRelegate */
class SOAP_CMAC ns1__pregOrRelegate
{
public:
	wchar_t *callNo;	/* optional element of type xsd:string */
	wchar_t *certId;	/* optional element of type xsd:string */
	wchar_t *dealFlag;	/* optional element of type xsd:string */
	wchar_t *dealFlagName;	/* optional element of type xsd:string */
	wchar_t *location;	/* optional element of type xsd:string */
	wchar_t *name;	/* optional element of type xsd:string */
	wchar_t *title;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 48; } /* = unique id SOAP_TYPE_ns1__pregOrRelegate */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__pregOrRelegate(): callNo(NULL), certId(NULL), dealFlag(NULL), dealFlagName(NULL), location(NULL), name(NULL), title(NULL), soap(NULL) { ns1__pregOrRelegate::soap_default(NULL); }
	virtual ~ns1__pregOrRelegate() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getViolations
#define SOAP_TYPE_ns1__getViolations (49)
/* ns1:getViolations */
class SOAP_CMAC ns1__getViolations
{
public:
	std::string *arg0;	/* optional element of type xsd:string */
	std::string *arg1;	/* optional element of type xsd:string */
	std::string *arg2;	/* optional element of type xsd:string */
	std::string *arg3;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 49; } /* = unique id SOAP_TYPE_ns1__getViolations */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getViolations(): arg0(NULL), arg1(NULL), arg2(NULL), arg3(NULL), soap(NULL) { ns1__getViolations::soap_default(NULL); }
	virtual ~ns1__getViolations() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getViolationsResponse
#define SOAP_TYPE_ns1__getViolationsResponse (50)
/* ns1:getViolationsResponse */
class SOAP_CMAC ns1__getViolationsResponse
{
public:
	std::vector<ns1__violation * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:violation */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 50; } /* = unique id SOAP_TYPE_ns1__getViolationsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getViolationsResponse(): soap(NULL) { ns1__getViolationsResponse::soap_default(NULL); }
	virtual ~ns1__getViolationsResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__certLoss
#define SOAP_TYPE_ns1__certLoss (51)
/* ns1:certLoss */
class SOAP_CMAC ns1__certLoss
{
public:
	std::string *arg0;	/* optional element of type xsd:string */
	std::string *arg1;	/* optional element of type xsd:string */
	std::string *arg2;	/* optional element of type xsd:string */
	std::string *arg3;	/* optional element of type xsd:string */
	int arg4;	/* required element of type xsd:int */
	std::string *arg5;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 51; } /* = unique id SOAP_TYPE_ns1__certLoss */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__certLoss(): arg0(NULL), arg1(NULL), arg2(NULL), arg3(NULL), arg5(NULL), soap(NULL) { ns1__certLoss::soap_default(NULL); }
	virtual ~ns1__certLoss() { }
};
#endif

#ifndef SOAP_TYPE_ns1__certLossResponse
#define SOAP_TYPE_ns1__certLossResponse (52)
/* ns1:certLossResponse */
class SOAP_CMAC ns1__certLossResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 52; } /* = unique id SOAP_TYPE_ns1__certLossResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__certLossResponse(): soap(NULL) { ns1__certLossResponse::soap_default(NULL); }
	virtual ~ns1__certLossResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getLendHist
#define SOAP_TYPE_ns1__getLendHist (53)
/* ns1:getLendHist */
class SOAP_CMAC ns1__getLendHist
{
public:
	std::string *arg0;	/* optional element of type xsd:string */
	std::string *arg1;	/* optional element of type xsd:string */
	std::string *arg2;	/* optional element of type xsd:string */
	std::string *arg3;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 53; } /* = unique id SOAP_TYPE_ns1__getLendHist */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getLendHist(): arg0(NULL), arg1(NULL), arg2(NULL), arg3(NULL), soap(NULL) { ns1__getLendHist::soap_default(NULL); }
	virtual ~ns1__getLendHist() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getLendHistResponse
#define SOAP_TYPE_ns1__getLendHistResponse (54)
/* ns1:getLendHistResponse */
class SOAP_CMAC ns1__getLendHistResponse
{
public:
	std::vector<ns1__circ * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:circ */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 54; } /* = unique id SOAP_TYPE_ns1__getLendHistResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getLendHistResponse(): soap(NULL) { ns1__getLendHistResponse::soap_default(NULL); }
	virtual ~ns1__getLendHistResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getMarc
#define SOAP_TYPE_ns1__getMarc (55)
/* ns1:getMarc */
class SOAP_CMAC ns1__getMarc
{
public:
	std::string *arg0;	/* optional element of type xsd:string */
	std::string *arg1;	/* optional element of type xsd:string */
	std::string *arg2;	/* optional element of type xsd:string */
	std::string *arg3;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 55; } /* = unique id SOAP_TYPE_ns1__getMarc */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getMarc(): arg0(NULL), arg1(NULL), arg2(NULL), arg3(NULL), soap(NULL) { ns1__getMarc::soap_default(NULL); }
	virtual ~ns1__getMarc() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getMarcResponse
#define SOAP_TYPE_ns1__getMarcResponse (56)
/* ns1:getMarcResponse */
class SOAP_CMAC ns1__getMarcResponse
{
public:
	class ns1__marc *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:marc */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 56; } /* = unique id SOAP_TYPE_ns1__getMarcResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getMarcResponse(): return_(NULL), soap(NULL) { ns1__getMarcResponse::soap_default(NULL); }
	virtual ~ns1__getMarcResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__marc
#define SOAP_TYPE_ns1__marc (57)
/* ns1:marc */
class SOAP_CMAC ns1__marc
{
public:
	wchar_t *author;	/* optional element of type xsd:string */
	wchar_t *callNo;	/* optional element of type xsd:string */
	wchar_t *isbn;	/* optional element of type xsd:string */
	wchar_t *marcRecNo;	/* optional element of type xsd:string */
	wchar_t *pubYear;	/* optional element of type xsd:string */
	wchar_t *publisher;	/* optional element of type xsd:string */
	wchar_t *title;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 57; } /* = unique id SOAP_TYPE_ns1__marc */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__marc(): author(NULL), callNo(NULL), isbn(NULL), marcRecNo(NULL), pubYear(NULL), publisher(NULL), title(NULL), soap(NULL) { ns1__marc::soap_default(NULL); }
	virtual ~ns1__marc() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getAccounts
#define SOAP_TYPE_ns1__getAccounts (58)
/* ns1:getAccounts */
class SOAP_CMAC ns1__getAccounts
{
public:
	std::string *arg0;	/* optional element of type xsd:string */
	std::string *arg1;	/* optional element of type xsd:string */
	std::string *arg2;	/* optional element of type xsd:string */
	std::string *arg3;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 58; } /* = unique id SOAP_TYPE_ns1__getAccounts */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getAccounts(): arg0(NULL), arg1(NULL), arg2(NULL), arg3(NULL), soap(NULL) { ns1__getAccounts::soap_default(NULL); }
	virtual ~ns1__getAccounts() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getAccountsResponse
#define SOAP_TYPE_ns1__getAccountsResponse (59)
/* ns1:getAccountsResponse */
class SOAP_CMAC ns1__getAccountsResponse
{
public:
	std::vector<class ns1__account * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:account */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 59; } /* = unique id SOAP_TYPE_ns1__getAccountsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getAccountsResponse(): soap(NULL) { ns1__getAccountsResponse::soap_default(NULL); }
	virtual ~ns1__getAccountsResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__account
#define SOAP_TYPE_ns1__account (60)
/* ns1:account */
class SOAP_CMAC ns1__account
{
public:
	float amount;	/* required element of type xsd:float */
	wchar_t *billNo;	/* optional element of type xsd:string */
	wchar_t *certId;	/* optional element of type xsd:string */
	wchar_t *name;	/* optional element of type xsd:string */
	wchar_t *paymentFlag;	/* optional element of type xsd:string */
	wchar_t *paymentFlagName;	/* optional element of type xsd:string */
	wchar_t *paymentItem;	/* optional element of type xsd:string */
	wchar_t *paymentItemName;	/* optional element of type xsd:string */
	wchar_t *paymentTime;	/* optional element of type xsd:string */
	wchar_t *paymentType;	/* optional element of type xsd:string */
	wchar_t *paymentTypeName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 60; } /* = unique id SOAP_TYPE_ns1__account */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__account(): billNo(NULL), certId(NULL), name(NULL), paymentFlag(NULL), paymentFlagName(NULL), paymentItem(NULL), paymentItemName(NULL), paymentTime(NULL), paymentType(NULL), paymentTypeName(NULL), soap(NULL) { ns1__account::soap_default(NULL); }
	virtual ~ns1__account() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getPregs
#define SOAP_TYPE_ns1__getPregs (61)
/* ns1:getPregs */
class SOAP_CMAC ns1__getPregs
{
public:
	std::string *arg0;	/* optional element of type xsd:string */
	std::string *arg1;	/* optional element of type xsd:string */
	std::string *arg2;	/* optional element of type xsd:string */
	std::string *arg3;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 61; } /* = unique id SOAP_TYPE_ns1__getPregs */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getPregs(): arg0(NULL), arg1(NULL), arg2(NULL), arg3(NULL), soap(NULL) { ns1__getPregs::soap_default(NULL); }
	virtual ~ns1__getPregs() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getPregsResponse
#define SOAP_TYPE_ns1__getPregsResponse (62)
/* ns1:getPregsResponse */
class SOAP_CMAC ns1__getPregsResponse
{
public:
	std::vector<class ns1__preg * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:preg */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 62; } /* = unique id SOAP_TYPE_ns1__getPregsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getPregsResponse(): soap(NULL) { ns1__getPregsResponse::soap_default(NULL); }
	virtual ~ns1__getPregsResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__registerReader
#define SOAP_TYPE_ns1__registerReader (64)
/* ns1:registerReader */
class SOAP_CMAC ns1__registerReader
{
public:
	std::string *arg0;	/* optional element of type xsd:string */
	std::string *arg1;	/* optional element of type xsd:string */
	std::string *arg2;	/* optional element of type xsd:string */
	std::string *arg3;	/* optional element of type xsd:string */
	std::string *arg4;	/* optional element of type xsd:string */
	std::string *arg5;	/* optional element of type xsd:string */
	std::string *arg6;	/* optional element of type xsd:string */
	std::string *arg7;	/* optional element of type xsd:string */
	std::string *arg8;	/* optional element of type xsd:string */
	std::string *arg9;	/* optional element of type xsd:string */
	std::string *arg10;	/* optional element of type xsd:string */
	std::string *arg11;	/* optional element of type xsd:string */
	std::string *arg12;	/* optional element of type xsd:string */
	std::string *arg13;	/* optional element of type xsd:string */
	std::string *arg14;	/* optional element of type xsd:string */
	std::string *arg15;	/* optional element of type xsd:string */
	std::string *arg16;	/* optional element of type xsd:string */
	std::string *arg17;	/* optional element of type xsd:string */
	std::string *arg18;	/* optional element of type xsd:string */
	std::string *arg19;	/* optional element of type xsd:string */
	std::string *arg20;	/* optional element of type xsd:string */
	std::string *arg21;	/* optional element of type xsd:string */
	std::string *arg22;	/* optional element of type xsd:string */
	std::string *arg23;	/* optional element of type xsd:string */
	std::string *arg24;	/* optional element of type xsd:string */
	std::string *arg25;	/* optional element of type xsd:string */
	std::string *arg26;	/* optional element of type xsd:string */
	std::string *arg27;	/* optional element of type xsd:string */
	std::string *arg28;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 64; } /* = unique id SOAP_TYPE_ns1__registerReader */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__registerReader(): arg0(NULL), arg1(NULL), arg2(NULL), arg3(NULL), arg4(NULL), arg5(NULL), arg6(NULL), arg7(NULL), arg8(NULL), arg9(NULL), arg10(NULL), arg11(NULL), arg12(NULL), arg13(NULL), arg14(NULL), arg15(NULL), arg16(NULL), arg17(NULL), arg18(NULL), arg19(NULL), arg20(NULL), arg21(NULL), arg22(NULL), arg23(NULL), arg24(NULL), arg25(NULL), arg26(NULL), arg27(NULL), arg28(NULL), soap(NULL) { ns1__registerReader::soap_default(NULL); }
	virtual ~ns1__registerReader() { }
};
#endif

#ifndef SOAP_TYPE_ns1__registerReaderResponse
#define SOAP_TYPE_ns1__registerReaderResponse (65)
/* ns1:registerReaderResponse */
class SOAP_CMAC ns1__registerReaderResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 65; } /* = unique id SOAP_TYPE_ns1__registerReaderResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__registerReaderResponse(): soap(NULL) { ns1__registerReaderResponse::soap_default(NULL); }
	virtual ~ns1__registerReaderResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getAccounts1
#define SOAP_TYPE_ns1__getAccounts1 (66)
/* ns1:getAccounts1 */
class SOAP_CMAC ns1__getAccounts1
{
public:
	std::string *arg0;	/* optional element of type xsd:string */
	std::string *arg1;	/* optional element of type xsd:string */
	std::string *arg2;	/* optional element of type xsd:string */
	std::string *arg3;	/* optional element of type xsd:string */
	std::string *arg4;	/* optional element of type xsd:string */
	std::string *arg5;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 66; } /* = unique id SOAP_TYPE_ns1__getAccounts1 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getAccounts1(): arg0(NULL), arg1(NULL), arg2(NULL), arg3(NULL), arg4(NULL), arg5(NULL), soap(NULL) { ns1__getAccounts1::soap_default(NULL); }
	virtual ~ns1__getAccounts1() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getAccounts1Response
#define SOAP_TYPE_ns1__getAccounts1Response (67)
/* ns1:getAccounts1Response */
class SOAP_CMAC ns1__getAccounts1Response
{
public:
	std::vector<ns1__account * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:account */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 67; } /* = unique id SOAP_TYPE_ns1__getAccounts1Response */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getAccounts1Response(): soap(NULL) { ns1__getAccounts1Response::soap_default(NULL); }
	virtual ~ns1__getAccounts1Response() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getLostPays
#define SOAP_TYPE_ns1__getLostPays (68)
/* ns1:getLostPays */
class SOAP_CMAC ns1__getLostPays
{
public:
	std::string *arg0;	/* optional element of type xsd:string */
	std::string *arg1;	/* optional element of type xsd:string */
	std::string *arg2;	/* optional element of type xsd:string */
	std::string *arg3;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 68; } /* = unique id SOAP_TYPE_ns1__getLostPays */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getLostPays(): arg0(NULL), arg1(NULL), arg2(NULL), arg3(NULL), soap(NULL) { ns1__getLostPays::soap_default(NULL); }
	virtual ~ns1__getLostPays() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getLostPaysResponse
#define SOAP_TYPE_ns1__getLostPaysResponse (69)
/* ns1:getLostPaysResponse */
class SOAP_CMAC ns1__getLostPaysResponse
{
public:
	std::vector<class ns1__lostPay * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:lostPay */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 69; } /* = unique id SOAP_TYPE_ns1__getLostPaysResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getLostPaysResponse(): soap(NULL) { ns1__getLostPaysResponse::soap_default(NULL); }
	virtual ~ns1__getLostPaysResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__lostPay
#define SOAP_TYPE_ns1__lostPay (70)
/* ns1:lostPay */
class SOAP_CMAC ns1__lostPay
{
public:
	wchar_t *barCode;	/* optional element of type xsd:string */
	wchar_t *billNo;	/* optional element of type xsd:string */
	float bookAmt;	/* required element of type xsd:float */
	wchar_t *certId;	/* optional element of type xsd:string */
	wchar_t *name;	/* optional element of type xsd:string */
	wchar_t *propNo;	/* optional element of type xsd:string */
	wchar_t *recoupType;	/* optional element of type xsd:string */
	float servFee;	/* required element of type xsd:float */
	float techFee;	/* required element of type xsd:float */
	wchar_t *title;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 70; } /* = unique id SOAP_TYPE_ns1__lostPay */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__lostPay(): barCode(NULL), billNo(NULL), certId(NULL), name(NULL), propNo(NULL), recoupType(NULL), title(NULL), soap(NULL) { ns1__lostPay::soap_default(NULL); }
	virtual ~ns1__lostPay() { }
};
#endif

#ifndef SOAP_TYPE_ns1__exceedFine1
#define SOAP_TYPE_ns1__exceedFine1 (71)
/* ns1:exceedFine1 */
class SOAP_CMAC ns1__exceedFine1
{
public:
	std::string *arg0;	/* optional element of type xsd:string */
	std::string *arg1;	/* optional element of type xsd:string */
	std::string *arg2;	/* optional element of type xsd:string */
	std::string *arg3;	/* optional element of type xsd:string */
	std::string *arg4;	/* optional element of type xsd:string */
	std::string *arg5;	/* optional element of type xsd:string */
	std::string *arg6;	/* optional element of type xsd:string */
	float arg7;	/* required element of type xsd:float */
	std::string *arg8;	/* optional element of type xsd:string */
	std::string *arg9;	/* optional element of type xsd:string */
	int arg10;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 71; } /* = unique id SOAP_TYPE_ns1__exceedFine1 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__exceedFine1(): arg0(NULL), arg1(NULL), arg2(NULL), arg3(NULL), arg4(NULL), arg5(NULL), arg6(NULL), arg8(NULL), arg9(NULL), soap(NULL) { ns1__exceedFine1::soap_default(NULL); }
	virtual ~ns1__exceedFine1() { }
};
#endif

#ifndef SOAP_TYPE_ns1__exceedFine1Response
#define SOAP_TYPE_ns1__exceedFine1Response (72)
/* ns1:exceedFine1Response */
class SOAP_CMAC ns1__exceedFine1Response
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 72; } /* = unique id SOAP_TYPE_ns1__exceedFine1Response */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__exceedFine1Response(): soap(NULL) { ns1__exceedFine1Response::soap_default(NULL); }
	virtual ~ns1__exceedFine1Response() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getRedrTypes
#define SOAP_TYPE_ns1__getRedrTypes (73)
/* ns1:getRedrTypes */
class SOAP_CMAC ns1__getRedrTypes
{
public:
	std::string *arg0;	/* optional element of type xsd:string */
	std::string *arg1;	/* optional element of type xsd:string */
	std::string *arg2;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 73; } /* = unique id SOAP_TYPE_ns1__getRedrTypes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getRedrTypes(): arg0(NULL), arg1(NULL), arg2(NULL), soap(NULL) { ns1__getRedrTypes::soap_default(NULL); }
	virtual ~ns1__getRedrTypes() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getRedrTypesResponse
#define SOAP_TYPE_ns1__getRedrTypesResponse (74)
/* ns1:getRedrTypesResponse */
class SOAP_CMAC ns1__getRedrTypesResponse
{
public:
	std::vector<ns1__simpleBean * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:simpleBean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 74; } /* = unique id SOAP_TYPE_ns1__getRedrTypesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getRedrTypesResponse(): soap(NULL) { ns1__getRedrTypesResponse::soap_default(NULL); }
	virtual ~ns1__getRedrTypesResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__relegate
#define SOAP_TYPE_ns1__relegate (47)
/* ns1:relegate */
class SOAP_CMAC ns1__relegate : public ns1__pregOrRelegate
{
public:
	wchar_t *relegateDate;	/* optional element of type xsd:string */
	wchar_t *relegateEndDate;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 47; } /* = unique id SOAP_TYPE_ns1__relegate */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__relegate(): relegateDate(NULL), relegateEndDate(NULL) { ns1__relegate::soap_default(NULL); }
	virtual ~ns1__relegate() { }
};
#endif

#ifndef SOAP_TYPE_ns1__preg
#define SOAP_TYPE_ns1__preg (63)
/* ns1:preg */
class SOAP_CMAC ns1__preg : public ns1__pregOrRelegate
{
public:
	wchar_t *pregDate;	/* optional element of type xsd:string */
	wchar_t *pregEndDate;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 63; } /* = unique id SOAP_TYPE_ns1__preg */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__preg(): pregDate(NULL), pregEndDate(NULL) { ns1__preg::soap_default(NULL); }
	virtual ~ns1__preg() { }
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (105)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	ns1__NoAuthorityException *ns1__NoAuthorityException_;	/* optional element of type ns1:NoAuthorityException */
	ns1__SystemException *ns1__SystemException_;	/* optional element of type ns1:SystemException */
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
	char *__any;
};
#endif

#ifndef SOAP_TYPE___ns1__getReader
#define SOAP_TYPE___ns1__getReader (113)
/* Operation wrapper: */
struct __ns1__getReader
{
public:
	ns1__getReader *ns1__getReader_;	/* optional element of type ns1:getReader */
};
#endif

#ifndef SOAP_TYPE___ns1__getItems
#define SOAP_TYPE___ns1__getItems (117)
/* Operation wrapper: */
struct __ns1__getItems
{
public:
	ns1__getItems *ns1__getItems_;	/* optional element of type ns1:getItems */
};
#endif

#ifndef SOAP_TYPE___ns1__getBook
#define SOAP_TYPE___ns1__getBook (121)
/* Operation wrapper: */
struct __ns1__getBook
{
public:
	ns1__getBook *ns1__getBook_;	/* optional element of type ns1:getBook */
};
#endif

#ifndef SOAP_TYPE___ns1__getCircs
#define SOAP_TYPE___ns1__getCircs (125)
/* Operation wrapper: */
struct __ns1__getCircs
{
public:
	ns1__getCircs *ns1__getCircs_;	/* optional element of type ns1:getCircs */
};
#endif

#ifndef SOAP_TYPE___ns1__getViolations
#define SOAP_TYPE___ns1__getViolations (129)
/* Operation wrapper: */
struct __ns1__getViolations
{
public:
	ns1__getViolations *ns1__getViolations_;	/* optional element of type ns1:getViolations */
};
#endif

#ifndef SOAP_TYPE___ns1__getDebts
#define SOAP_TYPE___ns1__getDebts (133)
/* Operation wrapper: */
struct __ns1__getDebts
{
public:
	ns1__getDebts *ns1__getDebts_;	/* optional element of type ns1:getDebts */
};
#endif

#ifndef SOAP_TYPE___ns1__getPregArrivals
#define SOAP_TYPE___ns1__getPregArrivals (137)
/* Operation wrapper: */
struct __ns1__getPregArrivals
{
public:
	ns1__getPregArrivals *ns1__getPregArrivals_;	/* optional element of type ns1:getPregArrivals */
};
#endif

#ifndef SOAP_TYPE___ns1__getRelegateArrivals
#define SOAP_TYPE___ns1__getRelegateArrivals (141)
/* Operation wrapper: */
struct __ns1__getRelegateArrivals
{
public:
	ns1__getRelegateArrivals *ns1__getRelegateArrivals_;	/* optional element of type ns1:getRelegateArrivals */
};
#endif

#ifndef SOAP_TYPE___ns1__getPregs
#define SOAP_TYPE___ns1__getPregs (145)
/* Operation wrapper: */
struct __ns1__getPregs
{
public:
	ns1__getPregs *ns1__getPregs_;	/* optional element of type ns1:getPregs */
};
#endif

#ifndef SOAP_TYPE___ns1__getRelegates
#define SOAP_TYPE___ns1__getRelegates (149)
/* Operation wrapper: */
struct __ns1__getRelegates
{
public:
	ns1__getRelegates *ns1__getRelegates_;	/* optional element of type ns1:getRelegates */
};
#endif

#ifndef SOAP_TYPE___ns1__getAccounts
#define SOAP_TYPE___ns1__getAccounts (153)
/* Operation wrapper: */
struct __ns1__getAccounts
{
public:
	ns1__getAccounts *ns1__getAccounts_;	/* optional element of type ns1:getAccounts */
};
#endif

#ifndef SOAP_TYPE___ns1__getLostPays
#define SOAP_TYPE___ns1__getLostPays (157)
/* Operation wrapper: */
struct __ns1__getLostPays
{
public:
	ns1__getLostPays *ns1__getLostPays_;	/* optional element of type ns1:getLostPays */
};
#endif

#ifndef SOAP_TYPE___ns1__exceedFine
#define SOAP_TYPE___ns1__exceedFine (161)
/* Operation wrapper: */
struct __ns1__exceedFine
{
public:
	ns1__exceedFine *ns1__exceedFine_;	/* optional element of type ns1:exceedFine */
};
#endif

#ifndef SOAP_TYPE___ns1__certLoss
#define SOAP_TYPE___ns1__certLoss (165)
/* Operation wrapper: */
struct __ns1__certLoss
{
public:
	ns1__certLoss *ns1__certLoss_;	/* optional element of type ns1:certLoss */
};
#endif

#ifndef SOAP_TYPE___ns1__logout
#define SOAP_TYPE___ns1__logout (169)
/* Operation wrapper: */
struct __ns1__logout
{
public:
	ns1__logout *ns1__logout_;	/* optional element of type ns1:logout */
};
#endif

#ifndef SOAP_TYPE___ns1__getLendHist
#define SOAP_TYPE___ns1__getLendHist (173)
/* Operation wrapper: */
struct __ns1__getLendHist
{
public:
	ns1__getLendHist *ns1__getLendHist_;	/* optional element of type ns1:getLendHist */
};
#endif

#ifndef SOAP_TYPE___ns1__getMarc
#define SOAP_TYPE___ns1__getMarc (177)
/* Operation wrapper: */
struct __ns1__getMarc
{
public:
	ns1__getMarc *ns1__getMarc_;	/* optional element of type ns1:getMarc */
};
#endif

#ifndef SOAP_TYPE___ns1__checkReader
#define SOAP_TYPE___ns1__checkReader (181)
/* Operation wrapper: */
struct __ns1__checkReader
{
public:
	ns1__checkReader *ns1__checkReader_;	/* optional element of type ns1:checkReader */
};
#endif

#ifndef SOAP_TYPE___ns1__voltFine
#define SOAP_TYPE___ns1__voltFine (185)
/* Operation wrapper: */
struct __ns1__voltFine
{
public:
	ns1__voltFine *ns1__voltFine_;	/* optional element of type ns1:voltFine */
};
#endif

#ifndef SOAP_TYPE___ns1__getViolations1
#define SOAP_TYPE___ns1__getViolations1 (189)
/* Operation wrapper: */
struct __ns1__getViolations1
{
public:
	ns1__getViolations1 *ns1__getViolations1_;	/* optional element of type ns1:getViolations1 */
};
#endif

#ifndef SOAP_TYPE___ns1__exceedFine1
#define SOAP_TYPE___ns1__exceedFine1 (193)
/* Operation wrapper: */
struct __ns1__exceedFine1
{
public:
	ns1__exceedFine1 *ns1__exceedFine1_;	/* optional element of type ns1:exceedFine1 */
};
#endif

#ifndef SOAP_TYPE___ns1__registerReader
#define SOAP_TYPE___ns1__registerReader (197)
/* Operation wrapper: */
struct __ns1__registerReader
{
public:
	ns1__registerReader *ns1__registerReader_;	/* optional element of type ns1:registerReader */
};
#endif

#ifndef SOAP_TYPE___ns1__getRedrTypes
#define SOAP_TYPE___ns1__getRedrTypes (201)
/* Operation wrapper: */
struct __ns1__getRedrTypes
{
public:
	ns1__getRedrTypes *ns1__getRedrTypes_;	/* optional element of type ns1:getRedrTypes */
};
#endif

#ifndef SOAP_TYPE___ns1__getDeps
#define SOAP_TYPE___ns1__getDeps (205)
/* Operation wrapper: */
struct __ns1__getDeps
{
public:
	ns1__getDeps *ns1__getDeps_;	/* optional element of type ns1:getDeps */
};
#endif

#ifndef SOAP_TYPE___ns1__getAccounts1
#define SOAP_TYPE___ns1__getAccounts1 (209)
/* Operation wrapper: */
struct __ns1__getAccounts1
{
public:
	ns1__getAccounts1 *ns1__getAccounts1_;	/* optional element of type ns1:getAccounts1 */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (210)
/* SOAP Header: */
struct SOAP_ENV__Header
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (211)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (213)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (214)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
};
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
